/// autogenerated analytical inverse kinematics code from ikfast program part of OpenRAVE
/// \author Rosen Diankov
///
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///     http://www.apache.org/licenses/LICENSE-2.0
/// 
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.
///
/// ikfast version 0x10000048 generated on 2016-01-24 23:54:59.153471
/// To compile with gcc:
///     gcc -lstdc++ ik.cpp
/// To compile without any main function as a shared object (might need -llapack):
///     gcc -fPIC -lstdc++ -DIKFAST_NO_MAIN -DIKFAST_CLIBRARY -shared -Wl,-soname,libik.so -o libik.so ik.cpp
#define IKFAST_HAS_LIBRARY
#include "ikfast.h" // found inside share/openrave-X.Y/python/ikfast.h
using namespace ikfast;

// check if the included ikfast version matches what this file was compiled with
#define IKFAST_COMPILE_ASSERT(x) extern int __dummy[(int)x]
IKFAST_COMPILE_ASSERT(IKFAST_VERSION==0x10000048);

#include <cmath>
#include <vector>
#include <limits>
#include <algorithm>
#include <complex>

#ifndef IKFAST_ASSERT
#include <stdexcept>
#include <sstream>
#include <iostream>

#ifdef _MSC_VER
#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __FUNCDNAME__
#endif
#endif

#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __func__
#endif

#define IKFAST_ASSERT(b) { if( !(b) ) { std::stringstream ss; ss << "ikfast exception: " << __FILE__ << ":" << __LINE__ << ": " <<__PRETTY_FUNCTION__ << ": Assertion '" << #b << "' failed"; throw std::runtime_error(ss.str()); } }

#endif

#if defined(_MSC_VER)
#define IKFAST_ALIGNED16(x) __declspec(align(16)) x
#else
#define IKFAST_ALIGNED16(x) x __attribute((aligned(16)))
#endif

#define IK2PI  ((IkReal)6.28318530717959)
#define IKPI  ((IkReal)3.14159265358979)
#define IKPI_2  ((IkReal)1.57079632679490)

#ifdef _MSC_VER
#ifndef isnan
#define isnan _isnan
#endif
#ifndef isinf
#define isinf _isinf
#endif
//#ifndef isfinite
//#define isfinite _isfinite
//#endif
#endif // _MSC_VER

// lapack routines
extern "C" {
  void dgetrf_ (const int* m, const int* n, double* a, const int* lda, int* ipiv, int* info);
  void zgetrf_ (const int* m, const int* n, std::complex<double>* a, const int* lda, int* ipiv, int* info);
  void dgetri_(const int* n, const double* a, const int* lda, int* ipiv, double* work, const int* lwork, int* info);
  void dgesv_ (const int* n, const int* nrhs, double* a, const int* lda, int* ipiv, double* b, const int* ldb, int* info);
  void dgetrs_(const char *trans, const int *n, const int *nrhs, double *a, const int *lda, int *ipiv, double *b, const int *ldb, int *info);
  void dgeev_(const char *jobvl, const char *jobvr, const int *n, double *a, const int *lda, double *wr, double *wi,double *vl, const int *ldvl, double *vr, const int *ldvr, double *work, const int *lwork, int *info);
}

using namespace std; // necessary to get std math routines

#ifdef IKFAST_NAMESPACE
namespace IKFAST_NAMESPACE {
#endif

inline float IKabs(float f) { return fabsf(f); }
inline double IKabs(double f) { return fabs(f); }

inline float IKsqr(float f) { return f*f; }
inline double IKsqr(double f) { return f*f; }

inline float IKlog(float f) { return logf(f); }
inline double IKlog(double f) { return log(f); }

// allows asin and acos to exceed 1
#ifndef IKFAST_SINCOS_THRESH
#define IKFAST_SINCOS_THRESH ((IkReal)2e-6)
#endif

// used to check input to atan2 for degenerate cases
#ifndef IKFAST_ATAN2_MAGTHRESH
#define IKFAST_ATAN2_MAGTHRESH ((IkReal)2e-6)
#endif

// minimum distance of separate solutions
#ifndef IKFAST_SOLUTION_THRESH
#define IKFAST_SOLUTION_THRESH ((IkReal)1e-6)
#endif

// there are checkpoints in ikfast that are evaluated to make sure they are 0. This threshold speicfies by how much they can deviate
#ifndef IKFAST_EVALCOND_THRESH
#define IKFAST_EVALCOND_THRESH ((IkReal)0.000005)
#endif


inline float IKasin(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(-IKPI_2);
else if( f >= 1 ) return float(IKPI_2);
return asinf(f);
}
inline double IKasin(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return -IKPI_2;
else if( f >= 1 ) return IKPI_2;
return asin(f);
}

// return positive value in [0,y)
inline float IKfmod(float x, float y)
{
    while(x < 0) {
        x += y;
    }
    return fmodf(x,y);
}

// return positive value in [0,y)
inline double IKfmod(double x, double y)
{
    while(x < 0) {
        x += y;
    }
    return fmod(x,y);
}

inline float IKacos(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(IKPI);
else if( f >= 1 ) return float(0);
return acosf(f);
}
inline double IKacos(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return IKPI;
else if( f >= 1 ) return 0;
return acos(f);
}
inline float IKsin(float f) { return sinf(f); }
inline double IKsin(double f) { return sin(f); }
inline float IKcos(float f) { return cosf(f); }
inline double IKcos(double f) { return cos(f); }
inline float IKtan(float f) { return tanf(f); }
inline double IKtan(double f) { return tan(f); }
inline float IKsqrt(float f) { if( f <= 0.0f ) return 0.0f; return sqrtf(f); }
inline double IKsqrt(double f) { if( f <= 0.0 ) return 0.0; return sqrt(f); }
inline float IKatan2Simple(float fy, float fx) {
    return atan2f(fy,fx);
}
inline float IKatan2(float fy, float fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return float(IKPI_2);
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2f(fy,fx);
}
inline double IKatan2Simple(double fy, double fx) {
    return atan2(fy,fx);
}
inline double IKatan2(double fy, double fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return IKPI_2;
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2(fy,fx);
}

template <typename T>
struct CheckValue
{
    T value;
    bool valid;
};

template <typename T>
inline CheckValue<T> IKatan2WithCheck(T fy, T fx, T epsilon)
{
    CheckValue<T> ret;
    ret.valid = false;
    ret.value = 0;
    if( !isnan(fy) && !isnan(fx) ) {
        if( IKabs(fy) >= IKFAST_ATAN2_MAGTHRESH || IKabs(fx) > IKFAST_ATAN2_MAGTHRESH ) {
            ret.value = IKatan2Simple(fy,fx);
            ret.valid = true;
        }
    }
    return ret;
}

inline float IKsign(float f) {
    if( f > 0 ) {
        return float(1);
    }
    else if( f < 0 ) {
        return float(-1);
    }
    return 0;
}

inline double IKsign(double f) {
    if( f > 0 ) {
        return 1.0;
    }
    else if( f < 0 ) {
        return -1.0;
    }
    return 0;
}

template <typename T>
inline CheckValue<T> IKPowWithIntegerCheck(T f, int n)
{
    CheckValue<T> ret;
    ret.valid = true;
    if( n == 0 ) {
        ret.value = 1.0;
        return ret;
    }
    else if( n == 1 )
    {
        ret.value = f;
        return ret;
    }
    else if( n < 0 )
    {
        if( f == 0 )
        {
            ret.valid = false;
            ret.value = (T)1.0e30;
            return ret;
        }
        if( n == -1 ) {
            ret.value = T(1.0)/f;
            return ret;
        }
    }

    int num = n > 0 ? n : -n;
    if( num == 2 ) {
        ret.value = f*f;
    }
    else if( num == 3 ) {
        ret.value = f*f*f;
    }
    else {
        ret.value = 1.0;
        while(num>0) {
            if( num & 1 ) {
                ret.value *= f;
            }
            num >>= 1;
            f *= f;
        }
    }
    
    if( n < 0 ) {
        ret.value = T(1.0)/ret.value;
    }
    return ret;
}

/// solves the forward kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API void ComputeFk(const IkReal* j, IkReal* eetrans, IkReal* eerot) {
IkReal x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19,x20,x21,x22,x23,x24,x25,x26,x27,x28,x29,x30,x31,x32,x33,x34,x35,x36,x37,x38,x39,x40,x41,x42,x43,x44,x45,x46,x47,x48,x49,x50,x51,x52,x53,x54,x55,x56,x57,x58,x59,x60,x61,x62,x63,x64,x65;
x0=IKsin(j[0]);
x1=IKcos(j[0]);
x2=IKcos(j[2]);
x3=IKsin(j[1]);
x4=IKsin(j[2]);
x5=IKcos(j[3]);
x6=IKcos(j[1]);
x7=IKsin(j[3]);
x8=IKcos(j[4]);
x9=IKsin(j[4]);
x10=IKcos(j[5]);
x11=IKsin(j[5]);
x12=IKsin(j[6]);
x13=IKcos(j[6]);
x14=((0.02)*x0);
x15=((0.046)*x8);
x16=((0.318)*x4);
x17=((1.0)*x11);
x18=((1.0)*x5);
x19=((0.046)*x9);
x20=((0.02)*x1);
x21=((1.0)*x7);
x22=((1.0)*x10);
x23=((0.046)*x5);
x24=((0.318)*x5);
x25=((1.0)*x3);
x26=(x2*x6);
x27=(x4*x6);
x28=(x2*x3);
x29=(x0*x4);
x30=(x1*x4);
x31=(x0*x6);
x32=(x1*x2);
x33=(x3*x5);
x34=(x6*x7);
x35=(x3*x7);
x36=(x1*x6);
x37=(x20*x4);
x38=(x14*x4);
x39=(x18*x3);
x40=((1.0)*x0*x2);
x41=(x18*x31);
x42=(x14*x28);
x43=(x25*x30);
x44=(x20*x28);
x45=((((-1.0)*x0*x2*x25))+x30);
x46=(((x29*x3))+x32);
x47=(((x1*x28))+x29);
x48=((((-1.0)*x43))+((x0*x2)));
x49=(x35+((x26*x5)));
x50=((((-1.0)*x39))+((x26*x7)));
x51=(x45*x7);
x52=(x38+x44);
x53=(x47*x7);
x54=(x11*x50);
x55=(((x31*x7))+((x45*x5)));
x56=(((x47*x5))+(((-1.0)*x21*x36)));
x57=(x53+((x36*x5)));
x58=(((x49*x9))+(((-1.0)*x27*x8)));
x59=(((x27*x9))+((x49*x8)));
x60=(x10*x58);
x61=(((x46*x8))+((x55*x9)));
x62=(((x56*x9))+((x48*x8)));
x63=(((x56*x8))+((x9*(((((-1.0)*x40))+x43)))));
x64=(((x55*x8))+((x9*(((((-1.0)*x32))+(((-1.0)*x25*x29)))))));
x65=(x10*x61);
eerot[0]=(((x10*((x41+(((-1.0)*x51))))))+((x11*x61)));
eerot[1]=(((x12*x64))+((x13*((((x11*(((((-1.0)*x41))+x51))))+x65)))));
eerot[2]=(((x13*x64))+(((-1.0)*x12*(((((1.0)*x65))+(((1.0)*x11*((x51+(((-1.0)*x31*x5)))))))))));
eetrans[0]=((0.155)+(((-1.0)*x37))+(((0.31)*x31))+((x11*((((x19*x55))+((x15*x46))))))+((x10*((((x23*x31))+(((-0.046)*x51))))))+((x14*x3))+((x14*x34))+x42+((x24*x31))+(((0.125)*x0))+(((0.009)*x1))+((x7*(((((-1.0)*x1*x16))+(((0.318)*x0*x28))))))+((x5*(((((-1.0)*x42))+x37)))));
eerot[3]=(((x11*x62))+((x10*(((((-1.0)*x18*x36))+(((-1.0)*x21*x47)))))));
eerot[4]=(((x12*x63))+((x13*((((x11*x57))+((x10*x62)))))));
eerot[5]=(((x13*x63))+((x12*(((((-1.0)*x17*x57))+(((-1.0)*x22*x62)))))));
IkReal x66=((1.0)*x20);
IkReal x67=((1.0)*x36);
eetrans[1]=((0.011)+(((-1.0)*x34*x66))+((x10*(((((-1.0)*x23*x67))+(((-0.046)*x53))))))+(((-0.125)*x1))+(((-1.0)*x24*x67))+((x11*((((x19*x56))+((x15*x48))))))+((x7*(((((-0.318)*x1*x28))+(((-1.0)*x0*x16))))))+((x5*x52))+(((-1.0)*x3*x66))+(((0.009)*x0))+(((-1.0)*x52))+(((-0.31)*x36)));
eerot[6]=(((x11*x58))+((x10*(((((-1.0)*x21*x26))+x39)))));
eerot[7]=(((x12*x59))+((x13*((x54+x60)))));
eerot[8]=(((x13*x59))+((x12*(((((-1.0)*x17*x50))+(((-1.0)*x22*x58)))))));
IkReal x68=(x26*x7);
IkReal x69=((0.02)*x26);
eetrans[2]=((-0.184)+(((-0.318)*x68))+(((0.31)*x3))+(((-0.02)*x6))+(((0.02)*x35))+((x5*x69))+((x10*((((x23*x3))+(((-0.046)*x68))))))+((x11*(((((-1.0)*x15*x27))+((x19*x49))))))+(((-1.0)*x69))+((x24*x3)));
}

IKFAST_API int GetNumFreeParameters() { return 1; }
IKFAST_API int* GetFreeParameters() { static int freeparams[] = {3}; return freeparams; }
IKFAST_API int GetNumJoints() { return 7; }

IKFAST_API int GetIkRealSize() { return sizeof(IkReal); }

IKFAST_API int GetIkType() { return 0x67000001; }

class IKSolver {
public:
IkReal j0,cj0,sj0,htj0,j0mul,j1,cj1,sj1,htj1,j1mul,j2,cj2,sj2,htj2,j2mul,j4,cj4,sj4,htj4,j4mul,j5,cj5,sj5,htj5,j5mul,j6,cj6,sj6,htj6,j6mul,j3,cj3,sj3,htj3,new_r00,r00,rxp0_0,new_r01,r01,rxp0_1,new_r02,r02,rxp0_2,new_r10,r10,rxp1_0,new_r11,r11,rxp1_1,new_r12,r12,rxp1_2,new_r20,r20,rxp2_0,new_r21,r21,rxp2_1,new_r22,r22,rxp2_2,new_px,px,npx,new_py,py,npy,new_pz,pz,npz,pp;
unsigned char _ij0[2], _nj0,_ij1[2], _nj1,_ij2[2], _nj2,_ij4[2], _nj4,_ij5[2], _nj5,_ij6[2], _nj6,_ij3[2], _nj3;

IkReal j100, cj100, sj100;
unsigned char _ij100[2], _nj100;
bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
j0=numeric_limits<IkReal>::quiet_NaN(); _ij0[0] = -1; _ij0[1] = -1; _nj0 = -1; j1=numeric_limits<IkReal>::quiet_NaN(); _ij1[0] = -1; _ij1[1] = -1; _nj1 = -1; j2=numeric_limits<IkReal>::quiet_NaN(); _ij2[0] = -1; _ij2[1] = -1; _nj2 = -1; j4=numeric_limits<IkReal>::quiet_NaN(); _ij4[0] = -1; _ij4[1] = -1; _nj4 = -1; j5=numeric_limits<IkReal>::quiet_NaN(); _ij5[0] = -1; _ij5[1] = -1; _nj5 = -1; j6=numeric_limits<IkReal>::quiet_NaN(); _ij6[0] = -1; _ij6[1] = -1; _nj6 = -1;  _ij3[0] = -1; _ij3[1] = -1; _nj3 = 0; 
for(int dummyiter = 0; dummyiter < 1; ++dummyiter) {
    solutions.Clear();
j3=pfree[0]; cj3=cos(pfree[0]); sj3=sin(pfree[0]), htj3=tan(pfree[0]*0.5);
r00 = eerot[0*3+0];
r01 = eerot[0*3+1];
r02 = eerot[0*3+2];
r10 = eerot[1*3+0];
r11 = eerot[1*3+1];
r12 = eerot[1*3+2];
r20 = eerot[2*3+0];
r21 = eerot[2*3+1];
r22 = eerot[2*3+2];
px = eetrans[0]; py = eetrans[1]; pz = eetrans[2];

new_r00=r01;
new_r01=r02;
new_r02=r00;
new_px=((-0.155)+px+(((-0.046)*r00)));
new_r10=r11;
new_r11=r12;
new_r12=r10;
new_py=((-0.011)+py+(((-0.046)*r10)));
new_r20=r21;
new_r21=r22;
new_r22=r20;
new_pz=((0.184)+pz+(((-0.046)*r20)));
r00 = new_r00; r01 = new_r01; r02 = new_r02; r10 = new_r10; r11 = new_r11; r12 = new_r12; r20 = new_r20; r21 = new_r21; r22 = new_r22; px = new_px; py = new_py; pz = new_pz;
IkReal x70=((1.0)*px);
IkReal x71=((1.0)*pz);
IkReal x72=((1.0)*py);
pp=((px*px)+(py*py)+(pz*pz));
npx=(((px*r00))+((py*r10))+((pz*r20)));
npy=(((px*r01))+((py*r11))+((pz*r21)));
npz=(((px*r02))+((py*r12))+((pz*r22)));
rxp0_0=((((-1.0)*r20*x72))+((pz*r10)));
rxp0_1=(((px*r20))+(((-1.0)*r00*x71)));
rxp0_2=((((-1.0)*r10*x70))+((py*r00)));
rxp1_0=((((-1.0)*r21*x72))+((pz*r11)));
rxp1_1=(((px*r21))+(((-1.0)*r01*x71)));
rxp1_2=(((py*r01))+(((-1.0)*r11*x70)));
rxp2_0=((((-1.0)*r22*x72))+((pz*r12)));
rxp2_1=(((px*r22))+(((-1.0)*r02*x71)));
rxp2_2=(((py*r02))+(((-1.0)*r12*x70)));
IkReal op[8+1], zeror[8];
int numroots;
IkReal x73=((0.018)*px);
IkReal x74=((0.19556)*cj3);
IkReal x75=((0.25)*py);
IkReal x76=((0.03784)*sj3);
IkReal x77=((1.0)*pp);
IkReal x78=((0.0124)*sj3);
IkReal x79=((0.19716)*cj3);
IkReal x80=(x77+x75);
IkReal x81=((0.04)+(((0.636)*sj3))+(((-0.04)*cj3)));
IkReal x82=((((0.5)*px))+(((0.036)*py)));
IkReal x83=(x77+x73);
IkReal x84=((0.181918)+x79+x78);
IkReal x85=((0.183518)+x76+x74);
IkReal x86=(x73+x85+(((-1.0)*x80)));
IkReal x87=(x73+x84+(((-1.0)*x80)));
IkReal x88=(x75+x85+(((-1.0)*x83)));
IkReal x89=(x75+x84+(((-1.0)*x83)));
IkReal gconst0=x81;
IkReal gconst1=x86;
IkReal gconst2=x87;
IkReal gconst3=x81;
IkReal gconst4=x86;
IkReal gconst5=x87;
IkReal gconst6=x82;
IkReal gconst7=x82;
IkReal gconst8=x82;
IkReal gconst9=x82;
IkReal gconst10=x81;
IkReal gconst11=x88;
IkReal gconst12=x89;
IkReal gconst13=x81;
IkReal gconst14=x88;
IkReal gconst15=x89;
IkReal x90=px*px;
IkReal x91=py*py;
IkReal x92=(gconst11*gconst5);
IkReal x93=(gconst15*gconst6);
IkReal x94=((0.018)*px);
IkReal x95=((1.0)*gconst0);
IkReal x96=(gconst12*gconst14);
IkReal x97=(gconst3*gconst4);
IkReal x98=((0.036)*py);
IkReal x99=(gconst12*gconst8);
IkReal x100=(gconst14*gconst7);
IkReal x101=(gconst1*gconst5);
IkReal x102=(gconst15*gconst7);
IkReal x103=(gconst1*gconst4);
IkReal x104=(gconst14*gconst6);
IkReal x105=((1.0)*gconst11);
IkReal x106=(gconst11*gconst9);
IkReal x107=((8.1e-5)*gconst5);
IkReal x108=(gconst5*gconst7);
IkReal x109=(gconst11*gconst8);
IkReal x110=(gconst1*gconst9);
IkReal x111=(gconst1*gconst14);
IkReal x112=((8.1e-5)*gconst4);
IkReal x113=(gconst2*gconst5);
IkReal x114=(gconst1*gconst8);
IkReal x115=(gconst2*gconst9);
IkReal x116=(gconst14*gconst2);
IkReal x117=(gconst5*gconst6);
IkReal x118=(gconst7*gconst8);
IkReal x119=(gconst11*gconst14);
IkReal x120=(gconst6*gconst9);
IkReal x121=(gconst12*gconst5);
IkReal x122=(gconst12*gconst4);
IkReal x123=(gconst12*gconst15);
IkReal x124=(gconst1*gconst15);
IkReal x125=(gconst2*gconst8);
IkReal x126=(gconst2*gconst4);
IkReal x127=(gconst12*gconst9);
IkReal x128=(gconst7*gconst9);
IkReal x129=(gconst4*gconst7);
IkReal x130=((1.0)*gconst6);
IkReal x131=(gconst4*gconst6);
IkReal x132=(gconst11*gconst15);
IkReal x133=(gconst15*gconst2);
IkReal x134=((1.0)*gconst1);
IkReal x135=(gconst6*gconst8);
IkReal x136=((1.0)*gconst10);
IkReal x137=((8.1e-5)*x118);
IkReal x138=((8.1e-5)*x120);
IkReal x139=((8.1e-5)*x92);
IkReal x140=((8.1e-5)*x124);
IkReal x141=(gconst12*x112);
IkReal x142=((8.1e-5)*x116);
IkReal x143=((8.1e-5)*x128);
IkReal x144=((8.1e-5)*x135);
IkReal x145=(gconst11*x112);
IkReal x146=((8.1e-5)*x111);
IkReal x147=((8.1e-5)*x133);
IkReal x148=(gconst12*x107);
IkReal x149=(gconst4*x90);
IkReal x150=(gconst2*x98);
IkReal x151=((4.0)*x91);
IkReal x152=((4.0)*px*py);
IkReal x153=(gconst8*x90);
IkReal x154=((1.0)*x90);
IkReal x155=(gconst13*x136);
IkReal x156=((2.0)*x90);
IkReal x157=(gconst11*gconst4*x94);
IkReal x158=(x128*x94);
IkReal x159=(x118*x90);
IkReal x160=(x124*x90);
IkReal x161=(x111*x94);
IkReal x162=(x120*x90);
IkReal x163=(x135*x94);
IkReal x164=(x121*x94);
IkReal x165=(x133*x94);
IkReal x166=(x116*x90);
IkReal x167=(x90*x92);
IkReal x168=(x122*x90);
IkReal x169=(x124*x94);
IkReal x170=(x120*x94);
IkReal x171=(x92*x94);
IkReal x172=(x116*x94);
IkReal x173=(x122*x94);
IkReal x174=(x118*x94);
IkReal x175=(gconst14*x155);
IkReal x176=(x132*x90);
IkReal x177=(x133*x154);
IkReal x178=(x128*x154);
IkReal x179=(x105*x149);
IkReal x180=(x130*x153);
IkReal x181=(x111*x154);
IkReal x182=(x121*x154);
IkReal x183=(x163+x161+x164+x165+x157+x158);
IkReal x184=(x171+x170+x173+x172+x174+x169);
IkReal x185=(x168+x162+x160+x166+x167+x159+x140+x141+x142+x137+x139+x138);
IkReal x186=(x179+x178+x177+x143+x144+x145+x146+x147+x148+x180+x181+x182);
op[0]=((((-1.0)*x123*x94))+(((-1.0)*x123*x154))+(((-8.1e-5)*x123))+(((8.1e-5)*x132))+(((-1.0)*x119*x94))+x176+((x90*x96))+(((-1.0)*x155*x96))+(((-1.0)*gconst14*x105*x90))+((x132*x94))+(((8.1e-5)*x96))+((x94*x96))+(((-8.1e-5)*x119)));
op[1]=((((-8.1e-5)*x102))+(((-8.1e-5)*x104))+(((-8.1e-5)*x109))+(((-1.0)*x127*x154))+((x123*x152))+(((-1.0)*x102*x94))+((x100*x94))+((x100*x90))+(((-1.0)*x132*x152))+(((8.1e-5)*x106))+(((8.1e-5)*x100))+(((-1.0)*x105*x153))+(((-1.0)*x127*x94))+(((-8.1e-5)*x127))+((x106*x90))+((x106*x94))+((x119*x152))+(((-1.0)*x102*x154))+((x90*x99))+((x90*x93))+(((-1.0)*x155*x99))+((x119*x98))+((x93*x94))+(((-1.0)*x104*x154))+(((8.1e-5)*x99))+(((8.1e-5)*x93))+(((-1.0)*x132*x98))+(((-1.0)*x109*x94))+(((-1.0)*x100*x155))+(((-1.0)*x152*x96))+(((-1.0)*x96*x98))+(((-1.0)*x104*x94))+((x123*x98))+((x94*x99)));
op[2]=(((x123*x156))+(((-1.0)*x98*x99))+(((-1.0)*gconst3*x136*x96))+((x102*x152))+(((-1.0)*x132*x156))+(((-1.0)*x123*x151))+(((-1.0)*x186))+(((-1.0)*x183))+((x102*x98))+x184+x185+(((-1.0)*x122*x155))+((x104*x152))+((x119*x156))+(((-1.0)*x116*x155))+((x127*x152))+(((0.000162)*x96))+((x127*x98))+((x109*x152))+(((-1.0)*x156*x96))+((x109*x98))+(((-1.0)*x100*x98))+(((-1.0)*x106*x152))+(((-0.000162)*x119))+(((-1.0)*x119*x151))+(((-1.0)*x118*x155))+(((-1.0)*x100*x152))+(((-1.0)*x152*x99))+(((-1.0)*x152*x93))+(((-1.0)*x106*x98))+((x132*x151))+(((-1.0)*x93*x98))+(((0.000162)*x132))+(((-0.000162)*x123))+(((-1.0)*gconst13*x95*x96))+((x104*x98))+((x151*x96)));
op[3]=((((-0.018)*gconst4*gconst6*px))+(((-0.018)*gconst1*gconst8*px))+(((0.000162)*gconst11*gconst9))+(((-0.000162)*gconst14*gconst6))+(((2.0)*gconst15*gconst7*(px*px)))+(((-4.0)*gconst12*gconst15*px*py))+(((0.018)*gconst4*gconst7*px))+(((0.036)*gconst12*gconst5*py))+(((-4.0)*gconst11*gconst8*(py*py)))+(((-0.036)*gconst1*gconst15*py))+((gconst5*gconst6*(px*px)))+(((8.1e-5)*gconst5*gconst6))+(((-0.018)*gconst5*gconst7*px))+(((2.0)*gconst11*gconst8*(px*px)))+(((0.000162)*gconst14*gconst7))+(((-0.000162)*gconst15*gconst7))+(((4.0)*gconst14*gconst7*(py*py)))+(((0.000162)*gconst15*gconst6))+(((-8.1e-5)*gconst5*gconst7))+(((-0.000162)*gconst12*gconst9))+(((-4.0)*gconst11*gconst5*px*py))+(((8.1e-5)*gconst2*gconst8))+(((-4.0)*gconst11*gconst14*px*py))+(((2.0)*gconst12*gconst9*(px*px)))+(((0.036)*gconst11*gconst4*py))+(((-2.0)*gconst11*gconst9*(px*px)))+(((-0.000162)*gconst11*gconst8))+(((-1.0)*gconst10*gconst13*gconst4*gconst7))+(((-4.0)*gconst12*gconst4*px*py))+(((0.036)*gconst1*gconst14*py))+(((-1.0)*gconst10*gconst12*gconst3*gconst8))+(((4.0)*gconst7*gconst9*px*py))+(((4.0)*gconst11*gconst9*(py*py)))+(((-1.0)*gconst10*gconst14*gconst3*gconst7))+(((8.1e-5)*gconst4*gconst7))+(((-0.036)*gconst12*gconst14*py))+(((4.0)*gconst1*gconst14*px*py))+(((-4.0)*gconst7*gconst8*px*py))+(((-4.0)*gconst14*gconst6*(py*py)))+(((-4.0)*gconst1*gconst15*px*py))+(((0.000162)*gconst12*gconst8))+(((0.036)*gconst7*gconst9*py))+(((-4.0)*gconst14*gconst2*px*py))+(((4.0)*gconst12*gconst5*px*py))+(((-0.036)*gconst12*gconst4*py))+(((-2.0)*gconst15*gconst6*(px*px)))+(((-0.036)*gconst7*gconst8*py))+(((0.036)*gconst12*gconst15*py))+((gconst2*gconst8*(px*px)))+(((-0.036)*gconst11*gconst5*py))+((gconst1*gconst9*(px*px)))+((gconst4*gconst7*(px*px)))+(((-4.0)*gconst12*gconst9*(py*py)))+(((-0.036)*gconst14*gconst2*py))+(((-1.0)*gconst5*gconst7*(px*px)))+(((-4.0)*gconst6*gconst9*px*py))+(((8.1e-5)*gconst1*gconst9))+(((-1.0)*gconst1*gconst8*(px*px)))+(((0.018)*gconst5*gconst6*px))+(((-2.0)*gconst12*gconst8*(px*px)))+(((-1.0)*gconst2*gconst9*(px*px)))+(((4.0)*gconst15*gconst2*px*py))+(((-1.0)*gconst4*gconst6*(px*px)))+(((4.0)*gconst6*gconst8*px*py))+(((-1.0)*gconst10*gconst13*gconst2*gconst8))+(((4.0)*gconst12*gconst14*px*py))+(((4.0)*gconst11*gconst15*px*py))+(((0.018)*gconst1*gconst9*px))+(((4.0)*gconst15*gconst6*(py*py)))+(((-0.036)*gconst6*gconst9*py))+(((2.0)*gconst14*gconst6*(px*px)))+(((-0.036)*gconst11*gconst15*py))+(((0.036)*gconst6*gconst8*py))+(((0.036)*gconst15*gconst2*py))+(((0.036)*gconst11*gconst14*py))+(((-8.1e-5)*gconst2*gconst9))+(((-2.0)*gconst14*gconst7*(px*px)))+(((-1.0)*gconst0*gconst13*gconst14*gconst7))+(((-1.0)*gconst0*gconst12*gconst13*gconst8))+(((-8.1e-5)*gconst1*gconst8))+(((-0.018)*gconst2*gconst9*px))+(((0.018)*gconst2*gconst8*px))+(((-8.1e-5)*gconst4*gconst6))+(((4.0)*gconst11*gconst4*px*py))+(((4.0)*gconst12*gconst8*(py*py)))+(((-4.0)*gconst15*gconst7*(py*py))));
op[4]=((((-4.0)*gconst1*gconst9*px*py))+(((-0.000162)*gconst7*gconst9))+(((0.000162)*gconst11*gconst5))+(((-2.0)*gconst1*gconst15*(px*px)))+(((4.0)*gconst14*gconst7*px*py))+(((-1.0)*gconst10*gconst14*gconst2*gconst3))+(((0.036)*gconst15*gconst7*py))+(((4.0)*gconst12*gconst4*(py*py)))+(((4.0)*gconst14*gconst2*(py*py)))+(((4.0)*gconst15*gconst6*px*py))+(((-4.0)*gconst15*gconst7*px*py))+(((4.0)*gconst11*gconst5*(py*py)))+(((-0.018)*gconst1*gconst4*px))+(((-0.000162)*gconst6*gconst8))+(((0.000162)*gconst1*gconst15))+(((4.0)*gconst7*gconst8*(py*py)))+(((-4.0)*gconst14*gconst6*px*py))+(((-2.0)*gconst6*gconst9*(px*px)))+(((-2.0)*gconst7*gconst8*(px*px)))+(((2.0)*gconst6*gconst8*(px*px)))+(((-4.0)*gconst5*gconst6*px*py))+(((-4.0)*gconst15*gconst2*(py*py)))+(((0.000162)*gconst14*gconst2))+(((2.0)*gconst7*gconst9*(px*px)))+(((-0.000162)*gconst15*gconst2))+(((-4.0)*gconst2*gconst8*px*py))+(((-0.036)*gconst15*gconst6*py))+(((0.000162)*gconst6*gconst9))+(((-1.0)*gconst0*gconst13*gconst7*gconst8))+(((-0.036)*gconst14*gconst7*py))+(((-0.000162)*gconst12*gconst5))+(((-8.1e-5)*gconst11*gconst14))+(((8.1e-5)*gconst2*gconst4))+(((4.0)*gconst11*gconst9*px*py))+(((-4.0)*gconst11*gconst8*px*py))+(((-0.036)*gconst11*gconst9*py))+(((4.0)*gconst5*gconst7*px*py))+(((-0.000162)*gconst11*gconst4))+(((-1.0)*gconst10*gconst12*gconst3*gconst4))+(((-4.0)*gconst12*gconst5*(py*py)))+(((2.0)*gconst12*gconst5*(px*px)))+(((0.036)*gconst1*gconst8*py))+(((0.036)*gconst11*gconst8*py))+(((0.018)*gconst2*gconst4*px))+(((8.1e-5)*gconst11*gconst15))+(((4.0)*gconst12*gconst8*px*py))+(((4.0)*gconst4*gconst6*px*py))+(((0.036)*gconst5*gconst7*py))+(((0.000162)*gconst12*gconst4))+(((-1.0)*gconst10*gconst3*gconst7*gconst8))+(((8.1e-5)*gconst12*gconst14))+(((0.018)*gconst11*gconst14*px))+(((-8.1e-5)*gconst12*gconst15))+((gconst11*gconst15*(px*px)))+(((-1.0)*gconst0*gconst12*gconst14*gconst3))+(((-0.018)*gconst11*gconst15*px))+(((4.0)*gconst1*gconst8*px*py))+((gconst12*gconst14*(px*px)))+(((4.0)*gconst2*gconst9*px*py))+(((-4.0)*gconst4*gconst7*px*py))+(((-0.018)*gconst12*gconst14*px))+(((-2.0)*gconst11*gconst5*(px*px)))+(((-0.036)*gconst5*gconst6*py))+((gconst2*gconst4*(px*px)))+(((-4.0)*gconst1*gconst14*(py*py)))+(((8.1e-5)*gconst1*gconst5))+(((-2.0)*gconst12*gconst4*(px*px)))+(((-1.0)*gconst11*gconst14*(px*px)))+((gconst1*gconst5*(px*px)))+(((-1.0)*gconst1*gconst4*(px*px)))+(((2.0)*gconst11*gconst4*(px*px)))+(((-1.0)*gconst12*gconst15*(px*px)))+(((-4.0)*gconst12*gconst9*px*py))+(((-0.036)*gconst12*gconst8*py))+(((0.000162)*gconst7*gconst8))+(((2.0)*gconst15*gconst2*(px*px)))+(((-1.0)*gconst10*gconst13*gconst2*gconst4))+(((-4.0)*gconst11*gconst4*(py*py)))+(((4.0)*gconst1*gconst15*(py*py)))+(((-2.0)*gconst14*gconst2*(px*px)))+(((0.036)*gconst4*gconst6*py))+(((4.0)*gconst6*gconst9*(py*py)))+(((0.036)*gconst12*gconst9*py))+(((-0.000162)*gconst1*gconst14))+(((-0.036)*gconst2*gconst8*py))+(((-1.0)*gconst2*gconst5*(px*px)))+(((-0.018)*gconst2*gconst5*px))+(((-8.1e-5)*gconst2*gconst5))+(((-0.036)*gconst1*gconst9*py))+(((0.036)*gconst14*gconst6*py))+(((-1.0)*gconst0*gconst13*gconst14*gconst2))+(((0.036)*gconst2*gconst9*py))+(((-0.036)*gconst4*gconst7*py))+(((2.0)*gconst1*gconst14*(px*px)))+(((-1.0)*gconst0*gconst12*gconst13*gconst4))+(((-4.0)*gconst7*gconst9*(py*py)))+(((-8.1e-5)*gconst1*gconst4))+(((0.018)*gconst1*gconst5*px))+(((0.018)*gconst12*gconst15*px))+(((-4.0)*gconst6*gconst8*(py*py))));
op[5]=((((-1.0)*gconst0*gconst13*gconst4*gconst7))+(((-8.1e-5)*gconst14*gconst6))+(((-4.0)*gconst5*gconst7*(py*py)))+(((0.036)*gconst12*gconst5*py))+(((0.018)*gconst14*gconst6*px))+(((-1.0)*gconst11*gconst8*(px*px)))+((gconst12*gconst8*(px*px)))+(((2.0)*gconst1*gconst8*(px*px)))+(((-0.036)*gconst1*gconst15*py))+(((-0.036)*gconst2*gconst4*py))+(((2.0)*gconst5*gconst7*(px*px)))+((gconst11*gconst9*(px*px)))+(((-1.0)*gconst0*gconst14*gconst3*gconst7))+(((-0.036)*gconst1*gconst5*py))+(((-0.018)*gconst12*gconst8*px))+(((0.018)*gconst11*gconst8*px))+(((-8.1e-5)*gconst15*gconst7))+(((2.0)*gconst2*gconst9*(px*px)))+(((0.036)*gconst1*gconst4*py))+(((-4.0)*gconst1*gconst8*(py*py)))+(((-1.0)*gconst10*gconst3*gconst4*gconst7))+(((4.0)*gconst6*gconst9*px*py))+(((-4.0)*gconst1*gconst14*px*py))+(((0.000162)*gconst1*gconst9))+(((0.036)*gconst11*gconst4*py))+(((-1.0)*gconst15*gconst7*(px*px)))+(((0.036)*gconst1*gconst14*py))+(((0.018)*gconst15*gconst7*px))+(((-1.0)*gconst14*gconst6*(px*px)))+(((-2.0)*gconst1*gconst9*(px*px)))+(((-4.0)*gconst2*gconst9*(py*py)))+(((2.0)*gconst4*gconst6*(px*px)))+(((-8.1e-5)*gconst12*gconst9))+(((0.036)*gconst7*gconst9*py))+(((-4.0)*gconst4*gconst6*(py*py)))+(((0.000162)*gconst4*gconst7))+(((4.0)*gconst2*gconst5*px*py))+(((-0.036)*gconst12*gconst4*py))+(((-0.036)*gconst7*gconst8*py))+(((-2.0)*gconst5*gconst6*(px*px)))+(((4.0)*gconst11*gconst5*px*py))+(((4.0)*gconst4*gconst7*(py*py)))+(((-0.036)*gconst11*gconst5*py))+(((-4.0)*gconst15*gconst2*px*py))+(((4.0)*gconst1*gconst15*px*py))+(((4.0)*gconst12*gconst4*px*py))+(((-4.0)*gconst7*gconst9*px*py))+(((-2.0)*gconst4*gconst7*(px*px)))+(((-1.0)*gconst10*gconst2*gconst3*gconst8))+(((-4.0)*gconst1*gconst5*px*py))+((gconst15*gconst6*(px*px)))+(((-0.036)*gconst14*gconst2*py))+((gconst14*gconst7*(px*px)))+(((4.0)*gconst1*gconst4*px*py))+(((0.036)*gconst2*gconst5*py))+(((-0.018)*gconst14*gconst7*px))+(((-0.000162)*gconst4*gconst6))+(((8.1e-5)*gconst11*gconst9))+(((-0.018)*gconst15*gconst6*px))+(((-4.0)*gconst6*gconst8*px*py))+(((4.0)*gconst1*gconst9*(py*py)))+(((-4.0)*gconst2*gconst4*px*py))+(((0.000162)*gconst5*gconst6))+(((-8.1e-5)*gconst11*gconst8))+(((-0.018)*gconst11*gconst9*px))+(((-4.0)*gconst12*gconst5*px*py))+(((-1.0)*gconst0*gconst13*gconst2*gconst8))+(((-0.036)*gconst6*gconst9*py))+(((-0.000162)*gconst5*gconst7))+(((0.036)*gconst6*gconst8*py))+(((0.036)*gconst15*gconst2*py))+(((8.1e-5)*gconst15*gconst6))+(((4.0)*gconst2*gconst8*(py*py)))+(((0.018)*gconst12*gconst9*px))+(((-1.0)*gconst0*gconst12*gconst3*gconst8))+(((-0.000162)*gconst2*gconst9))+(((4.0)*gconst7*gconst8*px*py))+(((-1.0)*gconst12*gconst9*(px*px)))+(((0.000162)*gconst2*gconst8))+(((-4.0)*gconst11*gconst4*px*py))+(((8.1e-5)*gconst12*gconst8))+(((-2.0)*gconst2*gconst8*(px*px)))+(((4.0)*gconst5*gconst6*(py*py)))+(((-0.000162)*gconst1*gconst8))+(((4.0)*gconst14*gconst2*px*py))+(((8.1e-5)*gconst14*gconst7)));
op[6]=((((-1.0)*x131*x152))+((x113*x156))+(((-1.0)*x115*x152))+(((-1.0)*x125*x98))+((x101*x151))+((x103*x156))+(((-1.0)*x114*x152))+((x126*x151))+((x117*x152))+(((-1.0)*gconst13*x126*x95))+(((-1.0)*x186))+(((-1.0)*x184))+((x114*x98))+((x110*x152))+x185+x183+(((-1.0)*gconst3*x116*x95))+(((-1.0)*x110*x98))+(((-1.0)*x103*x151))+(((-1.0)*x126*x156))+((x108*x98))+((x129*x152))+((x131*x98))+(((0.000162)*x101))+(((-1.0)*x117*x98))+(((-0.000162)*x103))+((x115*x98))+(((-0.000162)*x113))+(((-1.0)*x108*x152))+(((0.000162)*x126))+(((-1.0)*x129*x98))+(((-1.0)*gconst3*x118*x95))+(((-1.0)*gconst2*x136*x97))+(((-1.0)*x101*x156))+(((-1.0)*gconst12*x95*x97))+(((-1.0)*x113*x151))+((x125*x152)));
op[7]=(((x113*x98))+(((8.1e-5)*x110))+((x117*x90))+(((-1.0)*x115*x154))+(((-1.0)*x125*x94))+((x101*x152))+((gconst7*x112))+(((-1.0)*x114*x154))+((x126*x152))+(((-1.0)*gconst7*x107))+((gconst6*x107))+((x125*x90))+((x103*x98))+(((8.1e-5)*x125))+((x114*x94))+((x129*x90))+(((-1.0)*gconst6*x112))+(((-1.0)*x110*x94))+(((-1.0)*x103*x152))+(((-1.0)*gconst7*x95*x97))+((x108*x94))+((x131*x94))+(((-1.0)*x101*x98))+(((-1.0)*x117*x94))+(((-1.0)*x126*x98))+(((-1.0)*gconst3*x125*x95))+((x115*x94))+(((-1.0)*x108*x154))+(((-1.0)*x129*x94))+(((-1.0)*x113*x152))+((x110*x90))+(((-8.1e-5)*x115))+(((-8.1e-5)*x114))+(((-1.0)*x130*x149)));
op[8]=(((x113*x94))+((x126*x90))+((gconst2*x112))+(((-8.1e-5)*x103))+(((-1.0)*gconst2*x107))+(((8.1e-5)*x101))+(((-1.0)*gconst2*x95*x97))+((x103*x94))+((x101*x90))+(((-1.0)*x103*x154))+(((-1.0)*x101*x94))+(((-1.0)*x126*x94))+(((-1.0)*x113*x154)));
polyroots8(op,zeror,numroots);
IkReal j0array[8], cj0array[8], sj0array[8], tempj0array[1];
int numsolutions = 0;
for(int ij0 = 0; ij0 < numroots; ++ij0)
{
IkReal htj0 = zeror[ij0];
tempj0array[0]=((2.0)*(atan(htj0)));
for(int kj0 = 0; kj0 < 1; ++kj0)
{
j0array[numsolutions] = tempj0array[kj0];
if( j0array[numsolutions] > IKPI )
{
    j0array[numsolutions]-=IK2PI;
}
else if( j0array[numsolutions] < -IKPI )
{
    j0array[numsolutions]+=IK2PI;
}
sj0array[numsolutions] = IKsin(j0array[numsolutions]);
cj0array[numsolutions] = IKcos(j0array[numsolutions]);
numsolutions++;
}
}
bool j0valid[8]={true,true,true,true,true,true,true,true};
_nj0 = 8;
for(int ij0 = 0; ij0 < numsolutions; ++ij0)
    {
if( !j0valid[ij0] )
{
    continue;
}
    j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
htj0 = IKtan(j0/2);

_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < numsolutions; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
{
IkReal j1eval[2];
IkReal x187=cj0*cj0;
IkReal x188=px*px;
IkReal x189=py*py;
IkReal x190=pz*pz;
IkReal x191=(px*sj0);
IkReal x192=(cj0*py);
IkReal x193=(x191*x192);
IkReal x194=(x187*x189);
IkReal x195=(x187*x188);
j1eval[0]=((-1.0)+(((64.0)*x195))+(((128.0)*x193))+(((-64.0)*x188))+(((-64.0)*x194))+(((-64.0)*x190))+(((16.0)*x191))+(((-16.0)*x192)));
j1eval[1]=IKsign(((-0.015625)+(((0.25)*x191))+(((-1.0)*x194))+(((-1.0)*x190))+(((-1.0)*x188))+x195+(((-0.25)*x192))+(((2.0)*x193))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal j2eval[1];
j2eval[0]=((1.0)+(((15.9)*sj3))+(((-1.0)*cj3)));
if( IKabs(j2eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.26721335889799)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x196=(py*sj0);
IkReal x197=(cj0*px);
if( IKabs(((-117324726.61325)+(((13036080734.8056)*x197))+(((13036080734.8056)*x196)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-4967398332.72469)+(((5866236330.66251)*x197))+(((5866236330.66251)*x196))+(((-81475504592.5348)*cj0*py))+(((-325902018370.139)*pp))+(((81475504592.5348)*px*sj0)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-117324726.61325)+(((13036080734.8056)*x197))+(((13036080734.8056)*x196))))+IKsqr(((-4967398332.72469)+(((5866236330.66251)*x197))+(((5866236330.66251)*x196))+(((-81475504592.5348)*cj0*py))+(((-325902018370.139)*pp))+(((81475504592.5348)*px*sj0))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((-117324726.61325)+(((13036080734.8056)*x197))+(((13036080734.8056)*x196))), ((-4967398332.72469)+(((5866236330.66251)*x197))+(((5866236330.66251)*x196))+(((-81475504592.5348)*cj0*py))+(((-325902018370.139)*pp))+(((81475504592.5348)*px*sj0))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[2];
IkReal x198=(cj0*px);
IkReal x199=(py*sj0);
evalcond[0]=((-0.009)+x199+x198+(((-7.67101723549516e-11)*(IKsin(j2)))));
evalcond[1]=((-0.0152419992903604)+(((0.25)*px*sj0))+(((-3.06840689419807e-12)*(IKcos(j2))))+(((-1.0)*pp))+(((-0.25)*cj0*py))+(((0.018)*x199))+(((0.018)*x198)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1eval[3];
sj3=-0.125290571701305;
cj3=-0.992120086215235;
j3=3.26721331763958;
IkReal x200=cj2*cj2;
IkReal x201=(cj0*py);
IkReal x202=(px*sj0);
IkReal x203=((1.985855679629e+22)*cj2);
j1eval[0]=((-7.88518789033031e+16)+(((521443229.392223)*cj2))+(((-1.0)*x200)));
j1eval[1]=IKsign(((-1.20119271086946e+29)+(((7.94342271851599e+20)*cj2))+(((-1523353314564.0)*x200))));
j1eval[2]=((IKabs(((-2.58877712474722e+29)+(((-2.07102169979778e+30)*x201))+(((5.17755499346316e+30)*pz))+(((-1.0)*pz*x203))+(((2.07102169979778e+30)*x202)))))+(IKabs(((6.47194374182895e+29)+(((-1.0)*x201*x203))+(((2.07102169979778e+30)*pz))+(((-5.17755499346316e+30)*x202))+((x202*x203))+(((-2.48231959953625e+21)*cj2))+(((5.17755499346316e+30)*x201))))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[3];
sj3=-0.125290571701305;
cj3=-0.992120086215235;
j3=3.26721331763958;
IkReal x204=(px*sj0);
IkReal x205=((1.60896783582879e+16)*pz);
IkReal x206=(cj0*py);
IkReal x207=(cj2*x206);
j1eval[0]=((260721614.696111)+(((8.0)*cj2*x204))+(((-8.0)*x207))+(((2085772917.56889)*x206))+(((-834309047.144732)*pz))+(((-2085772917.56889)*x204))+(((-1.0)*cj2)));
j1eval[1]=((IKabs(((2574348167415.02)+(((-9873.934581203)*cj2))+((x204*x205))+(((-2.01120979478599e+15)*pz))+(((-1.0)*x205*x206)))))+(IKabs(((-6435871343315.16)+(((-9.46789165477202e-5)*(cj2*cj2)))+((pz*x205))+(((49369.68)*cj2))))));
j1eval[2]=IKsign(((40224195895719.8)+(((-321793567165758.0)*x204))+(((1234242.0)*cj2*x204))+(((-154280.25)*cj2))+(((321793567165758.0)*x206))+(((-1234242.0)*x207))+(((-128717408370751.0)*pz))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
sj3=-0.125290571701305;
cj3=-0.992120086215235;
j3=3.26721331763958;
j1eval[0]=((13036078.8616364)+(((260721614.696111)*pz))+(((-1.0)*cj2*pz))+(((-104288630.893091)*px*sj0))+(((104288630.893091)*cj0*py)));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j1]

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x208=((1.60896783582879e+16)*pz);
IkReal x209=(px*sj0);
IkReal x210=(cj0*py);
IkReal x211=(cj2*pz);
CheckValue<IkReal> x212=IKPowWithIntegerCheck(((16089676046343.9)+(((128717408370751.0)*x210))+(((-128717408370751.0)*x209))+(((321793567165758.0)*pz))+(((-1234242.0)*x211))),-1);
if(!x212.valid){
continue;
}
CheckValue<IkReal> x213=IKPowWithIntegerCheck(((-2.58877712474722e+29)+(((-2.07102169979778e+30)*x210))+(((1.985855679629e+22)*x211))+(((-5.17755499346316e+30)*pz))+(((2.07102169979778e+30)*x209))),-1);
if(!x213.valid){
continue;
}
if( IKabs(((x212.value)*(((-2574348167415.02)+(((9873.934581203)*cj2))+(((-2.01120979478599e+15)*pz))+(((-1.0)*x208*x210))+((x208*x209)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x213.value)*(((-1.65681712176827e+28)+(((2.58877749673158e+32)*(pz*pz))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x212.value)*(((-2574348167415.02)+(((9873.934581203)*cj2))+(((-2.01120979478599e+15)*pz))+(((-1.0)*x208*x210))+((x208*x209))))))+IKsqr(((x213.value)*(((-1.65681712176827e+28)+(((2.58877749673158e+32)*(pz*pz)))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2(((x212.value)*(((-2574348167415.02)+(((9873.934581203)*cj2))+(((-2.01120979478599e+15)*pz))+(((-1.0)*x208*x210))+((x208*x209))))), ((x213.value)*(((-1.65681712176827e+28)+(((2.58877749673158e+32)*(pz*pz)))))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x214=IKcos(j1);
IkReal x215=IKsin(j1);
IkReal x216=(px*sj0);
IkReal x217=((1.0)*pz);
IkReal x218=((7.67101723549516e-11)*cj2);
IkReal x219=(cj0*py);
IkReal x220=((0.04)*x215);
IkReal x221=((1.0)*x219);
evalcond[0]=(((x214*x218))+(((-0.00799999885047098)*x215))+(((-0.02)*x214))+(((-1.0)*x217)));
evalcond[1]=((0.00799999885047098)+(((-0.125)*x214))+((x214*x216))+(((-1.0)*x214*x221))+((pz*x215)));
evalcond[2]=((-0.125)+(((-0.02)*x215))+((x215*x218))+x216+(((0.00799999885047098)*x214))+(((-1.0)*x221)));
evalcond[3]=((-0.02)+(((-1.0)*x215*x221))+(((-0.125)*x215))+((x215*x216))+x218+(((-1.0)*x214*x217)));
evalcond[4]=((-0.0160419992903604)+(((-0.04)*pz*x214))+(((0.018)*cj0*px))+(((-0.005)*x215))+((x216*x220))+(((-1.0)*x219*x220))+(((-1.0)*pp))+(((0.018)*py*sj0))+(((-0.25)*x219))+(((0.25)*x216)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x630=((1.60896783582879e+16)*pz);
IkReal x631=(px*sj0);
IkReal x632=(cj0*py);
IkReal x633=((1234242.0)*cj2);
CheckValue<IkReal> x634=IKPowWithIntegerCheck(IKsign(((40224195895719.8)+(((-154280.25)*cj2))+(((321793567165758.0)*x632))+(((-321793567165758.0)*x631))+((x631*x633))+(((-1.0)*x632*x633))+(((-128717408370751.0)*pz)))),-1);
if(!x634.valid){
continue;
}
CheckValue<IkReal> x635 = IKatan2WithCheck(IkReal(((-6435871343315.16)+((pz*x630))+(((-9.46789165477202e-5)*(cj2*cj2)))+(((49369.68)*cj2)))),((2574348167415.02)+(((-1.0)*x630*x632))+(((-9873.934581203)*cj2))+(((-2.01120979478599e+15)*pz))+((x630*x631))),IKFAST_ATAN2_MAGTHRESH);
if(!x635.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x634.value)))+(x635.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x636=IKcos(j1);
IkReal x637=IKsin(j1);
IkReal x638=(px*sj0);
IkReal x639=((1.0)*pz);
IkReal x640=((7.67101723549516e-11)*cj2);
IkReal x641=(cj0*py);
IkReal x642=((0.04)*x637);
IkReal x643=((1.0)*x641);
evalcond[0]=(((x636*x640))+(((-0.02)*x636))+(((-1.0)*x639))+(((-0.00799999885047098)*x637)));
evalcond[1]=((0.00799999885047098)+(((-0.125)*x636))+((pz*x637))+((x636*x638))+(((-1.0)*x636*x643)));
evalcond[2]=((-0.125)+(((0.00799999885047098)*x636))+(((-0.02)*x637))+((x637*x640))+(((-1.0)*x643))+x638);
evalcond[3]=((-0.02)+(((-0.125)*x637))+(((-1.0)*x636*x639))+x640+(((-1.0)*x637*x643))+((x637*x638)));
evalcond[4]=((-0.0160419992903604)+(((0.018)*cj0*px))+((x638*x642))+(((-0.04)*pz*x636))+(((-1.0)*x641*x642))+(((0.25)*x638))+(((-1.0)*pp))+(((-0.25)*x641))+(((0.018)*py*sj0))+(((-0.005)*x637)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x644=(cj0*py);
IkReal x645=(px*sj0);
IkReal x646=((1.985855679629e+22)*cj2);
CheckValue<IkReal> x647=IKPowWithIntegerCheck(IKsign(((-1.20119271086946e+29)+(((7.94342271851599e+20)*cj2))+(((-1523353314564.0)*(cj2*cj2))))),-1);
if(!x647.valid){
continue;
}
CheckValue<IkReal> x648 = IKatan2WithCheck(IkReal(((6.47194374182895e+29)+(((2.07102169979778e+30)*pz))+((x645*x646))+(((-1.0)*x644*x646))+(((-5.17755499346316e+30)*x645))+(((5.17755499346316e+30)*x644))+(((-2.48231959953625e+21)*cj2)))),((-2.58877712474722e+29)+(((5.17755499346316e+30)*pz))+(((-2.07102169979778e+30)*x644))+(((2.07102169979778e+30)*x645))+(((-1.0)*pz*x646))),IKFAST_ATAN2_MAGTHRESH);
if(!x648.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x647.value)))+(x648.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x649=IKcos(j1);
IkReal x650=IKsin(j1);
IkReal x651=(px*sj0);
IkReal x652=((1.0)*pz);
IkReal x653=((7.67101723549516e-11)*cj2);
IkReal x654=(cj0*py);
IkReal x655=((0.04)*x650);
IkReal x656=((1.0)*x654);
evalcond[0]=((((-0.00799999885047098)*x650))+((x649*x653))+(((-1.0)*x652))+(((-0.02)*x649)));
evalcond[1]=((0.00799999885047098)+((pz*x650))+((x649*x651))+(((-0.125)*x649))+(((-1.0)*x649*x656)));
evalcond[2]=((-0.125)+(((-0.02)*x650))+(((-1.0)*x656))+(((0.00799999885047098)*x649))+x651+((x650*x653)));
evalcond[3]=((-0.02)+x653+(((-0.125)*x650))+(((-1.0)*x650*x656))+(((-1.0)*x649*x652))+((x650*x651)));
evalcond[4]=((-0.0160419992903604)+(((0.018)*cj0*px))+(((-0.04)*pz*x649))+((x651*x655))+(((0.25)*x651))+(((-1.0)*pp))+(((0.018)*py*sj0))+(((-0.25)*x654))+(((-0.005)*x650))+(((-1.0)*x654*x655)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j1, j2]

}
} while(0);
if( bgotonextstatement )
{
}
}
}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x657=(py*sj0);
IkReal x658=(cj0*px);
CheckValue<IkReal> x659=IKPowWithIntegerCheck(((0.02)+(((0.318)*sj3))+(((-0.02)*cj3))),-1);
if(!x659.valid){
continue;
}
CheckValue<IkReal> x660=IKPowWithIntegerCheck(((0.0008)+(((-0.0008)*cj3))+(((0.01272)*sj3))),-1);
if(!x660.valid){
continue;
}
if( IKabs(((x659.value)*(((0.009)+(((-1.0)*x657))+(((-1.0)*x658)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x660.value)*(((-0.182718)+(((-0.25)*px*sj0))+(((-0.018)*x657))+(((-0.018)*x658))+(((-0.19636)*cj3))+(((-0.02512)*sj3))+pp+(((0.25)*cj0*py)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x659.value)*(((0.009)+(((-1.0)*x657))+(((-1.0)*x658))))))+IKsqr(((x660.value)*(((-0.182718)+(((-0.25)*px*sj0))+(((-0.018)*x657))+(((-0.018)*x658))+(((-0.19636)*cj3))+(((-0.02512)*sj3))+pp+(((0.25)*cj0*py))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((x659.value)*(((0.009)+(((-1.0)*x657))+(((-1.0)*x658))))), ((x660.value)*(((-0.182718)+(((-0.25)*px*sj0))+(((-0.018)*x657))+(((-0.018)*x658))+(((-0.19636)*cj3))+(((-0.02512)*sj3))+pp+(((0.25)*cj0*py))))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[2];
IkReal x661=IKsin(j2);
IkReal x662=IKcos(j2);
IkReal x663=(cj0*px);
IkReal x664=(py*sj0);
IkReal x665=((0.02)*x661);
IkReal x666=((0.0008)*x662);
evalcond[0]=((-0.009)+(((-1.0)*cj3*x665))+x663+x665+x664+(((0.318)*sj3*x661)));
evalcond[1]=((0.182718)+(((0.018)*x663))+(((0.018)*x664))+(((-1.0)*cj3*x666))+(((0.19636)*cj3))+(((0.25)*px*sj0))+(((0.02512)*sj3))+(((-1.0)*pp))+x666+(((-0.25)*cj0*py))+(((0.01272)*sj3*x662)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1eval[2];
IkReal x667=((0.318)*cj3);
IkReal x668=(cj0*py);
IkReal x669=((8.0)*pz);
IkReal x670=(px*sj0);
IkReal x671=((8.0)*sj3);
IkReal x672=((127.2)*cj3);
IkReal x673=(cj2*pz);
IkReal x674=((0.02)*sj3);
j1eval[0]=((-15.5)+(((-1.0)*sj3))+(((-1.0)*cj2*cj3*x669))+((cj2*x669))+(((127.2)*sj3*x673))+((x670*x671))+((x670*x672))+(((-1.0)*x668*x672))+(((-1.0)*x668*x671))+(((124.0)*x670))+(((-15.9)*cj3))+(((-124.0)*x668))+x669);
j1eval[1]=IKsign(((-0.03875)+(((-0.02)*cj3*x673))+(((-0.31)*x668))+(((-0.03975)*cj3))+(((0.02)*pz))+((x670*x674))+(((-1.0)*x668*x674))+((x667*x670))+(((-0.0025)*sj3))+(((0.31)*x670))+(((-1.0)*x667*x668))+(((0.02)*x673))+(((0.318)*sj3*x673))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
IkReal x675=((8.0)*cj3);
IkReal x676=((0.02)*cj3);
IkReal x677=(cj2*sj3);
IkReal x678=(cj2*cj3);
IkReal x679=(pz*sj3);
IkReal x680=(px*sj0);
IkReal x681=(cj3*pz);
IkReal x682=(cj0*py);
IkReal x683=(cj2*x680);
IkReal x684=(cj2*x682);
j1eval[0]=((1.0)+(((15.9)*x677))+cj2+(((-1.0)*x675*x684))+(((-8.0)*x680))+(((-8.0)*x683))+(((127.2)*x677*x682))+(((8.0)*x679))+(((-127.2)*x677*x680))+(((127.2)*x681))+(((8.0)*x684))+(((8.0)*x682))+(((-1.0)*x678))+((x675*x683))+(((124.0)*pz)));
j1eval[1]=IKsign(((0.0025)+(((-0.318)*x677*x680))+(((0.0025)*cj2))+((x676*x683))+(((-0.02)*x683))+(((-0.02)*x680))+(((-0.0025)*x678))+(((0.02)*x684))+(((0.02)*x682))+(((0.318)*x677*x682))+(((0.31)*pz))+(((0.318)*x681))+(((0.03975)*x677))+(((0.02)*x679))+(((-1.0)*x676*x684))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
IkReal x685=cj0*cj0;
IkReal x686=px*px;
IkReal x687=py*py;
IkReal x688=pz*pz;
IkReal x689=(px*sj0);
IkReal x690=(cj0*py);
IkReal x691=(x689*x690);
IkReal x692=(x685*x687);
IkReal x693=(x685*x686);
j1eval[0]=((-1.0)+(((-16.0)*x690))+(((64.0)*x693))+(((16.0)*x689))+(((-64.0)*x692))+(((-64.0)*x688))+(((-64.0)*x686))+(((128.0)*x691)));
j1eval[1]=IKsign(((-0.015625)+(((2.0)*x691))+(((0.25)*x689))+(((-0.25)*x690))+x693+(((-1.0)*x686))+(((-1.0)*x688))+(((-1.0)*x692))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j1]

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x694=cj0*cj0;
IkReal x695=px*px;
IkReal x696=((0.318)*cj3);
IkReal x697=(cj0*py);
IkReal x698=(px*sj0);
IkReal x699=((0.0025)*cj2);
IkReal x700=((0.02)*pz);
IkReal x701=((0.02)*cj2);
IkReal x702=((0.02)*sj3);
IkReal x703=(cj3*x701);
IkReal x704=((0.318)*cj2*sj3);
CheckValue<IkReal> x705 = IKatan2WithCheck(IkReal(((0.0025)+(((-0.31)*pz))+(((0.02)*x697))+(((-1.0)*cj3*x699))+((x697*x701))+((x697*x704))+(((-1.0)*pz*x696))+x699+((x698*x703))+(((-1.0)*x698*x701))+(((-1.0)*x698*x704))+(((-1.0)*x697*x703))+(((0.03975)*cj2*sj3))+(((-1.0)*sj3*x700))+(((-0.02)*x698)))),((0.03875)+(((-0.31)*x698))+(((-1.0)*x696*x698))+((x696*x697))+(((0.31)*x697))+(((0.0025)*sj3))+((x697*x702))+((cj2*x700))+x700+(((-1.0)*x698*x702))+((pz*x704))+(((-1.0)*cj2*cj3*x700))+(((0.03975)*cj3))),IKFAST_ATAN2_MAGTHRESH);
if(!x705.valid){
continue;
}
CheckValue<IkReal> x706=IKPowWithIntegerCheck(IKsign(((-0.015625)+(((0.25)*x698))+((x694*x695))+(((-0.25)*x697))+(((-1.0)*(pz*pz)))+(((-1.0)*x694*(py*py)))+(((2.0)*x697*x698))+(((-1.0)*x695)))),-1);
if(!x706.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x705.value)+(((1.5707963267949)*(x706.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x707=IKcos(j1);
IkReal x708=IKsin(j1);
IkReal x709=((0.318)*cj3);
IkReal x710=((0.02)*sj3);
IkReal x711=(px*sj0);
IkReal x712=((0.02)*cj2);
IkReal x713=(cj0*py);
IkReal x714=((0.318)*cj2*sj3);
IkReal x715=((1.0)*x707);
IkReal x716=((0.04)*x708);
evalcond[0]=((-0.31)+((x707*x711))+(((-1.0)*x710))+(((-1.0)*x709))+(((-1.0)*x713*x715))+((pz*x708))+(((-0.125)*x707)));
evalcond[1]=((-0.02)+(((-1.0)*pz*x715))+(((-1.0)*x708*x713))+(((-1.0)*x714))+(((-1.0)*x712))+((cj3*x712))+((x708*x711))+(((-0.125)*x708)));
evalcond[2]=((((-1.0)*x707*x714))+(((-1.0)*x707*x712))+(((-1.0)*pz))+(((-0.02)*x707))+(((0.31)*x708))+((x708*x709))+((x708*x710))+((cj3*x707*x712)));
evalcond[3]=((-0.125)+(((-1.0)*x707*x709))+(((-1.0)*x707*x710))+(((-0.31)*x707))+(((-1.0)*x713))+(((-0.02)*x708))+((cj3*x708*x712))+(((-1.0)*x708*x714))+(((-1.0)*x708*x712))+x711);
evalcond[4]=((0.181918)+(((0.018)*cj0*px))+(((-0.25)*x713))+(((-0.04)*pz*x707))+((x711*x716))+(((0.19636)*cj3))+(((0.02512)*sj3))+(((-1.0)*pp))+(((-0.005)*x708))+(((0.018)*py*sj0))+(((-1.0)*x713*x716))+(((0.25)*x711)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x717=cj2*cj2;
IkReal x718=cj3*cj3;
IkReal x719=(cj2*cj3);
IkReal x720=(cj2*sj3);
IkReal x721=(px*sj0);
IkReal x722=(cj0*py);
IkReal x723=((0.02)*x722);
IkReal x724=((0.02)*cj2*x721);
IkReal x725=((0.01272)*sj3*x717);
CheckValue<IkReal> x726 = IKatan2WithCheck(IkReal(((-0.0004)+(((-0.101524)*x717))+(((0.0008)*cj3*x717))+(((0.0008)*x719))+(((-0.0008)*cj2))+(((-1.0)*x725))+(pz*pz)+(((0.100724)*x717*x718))+(((-0.01272)*x720))+((cj3*x725)))),((-0.0062)+(((-0.100724)*sj3*x719))+(((-0.01256)*cj2))+(((-0.00016)*x719))+(((-0.09898)*x720))+(((-0.125)*pz))+((pz*x721))+(((0.01272)*cj2*x718))+(((-0.00636)*cj3))+(((-1.0)*pz*x722))+(((-0.0004)*sj3))),IKFAST_ATAN2_MAGTHRESH);
if(!x726.valid){
continue;
}
CheckValue<IkReal> x727=IKPowWithIntegerCheck(IKsign(((0.0025)+(((-0.0025)*x719))+(((0.02)*x719*x721))+(((0.0025)*cj2))+(((-0.318)*x720*x721))+(((0.03975)*x720))+(((0.02)*pz*sj3))+(((0.318)*cj3*pz))+(((-1.0)*x724))+(((0.31)*pz))+((cj2*x723))+(((0.318)*x720*x722))+(((-0.02)*x721))+x723+(((-1.0)*x719*x723)))),-1);
if(!x727.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x726.value)+(((1.5707963267949)*(x727.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x728=IKcos(j1);
IkReal x729=IKsin(j1);
IkReal x730=((0.318)*cj3);
IkReal x731=((0.02)*sj3);
IkReal x732=(px*sj0);
IkReal x733=((0.02)*cj2);
IkReal x734=(cj0*py);
IkReal x735=((0.318)*cj2*sj3);
IkReal x736=((1.0)*x728);
IkReal x737=((0.04)*x729);
evalcond[0]=((-0.31)+(((-0.125)*x728))+((x728*x732))+(((-1.0)*x734*x736))+(((-1.0)*x730))+(((-1.0)*x731))+((pz*x729)));
evalcond[1]=((-0.02)+(((-0.125)*x729))+((x729*x732))+(((-1.0)*x733))+(((-1.0)*x735))+((cj3*x733))+(((-1.0)*pz*x736))+(((-1.0)*x729*x734)));
evalcond[2]=(((x729*x730))+((x729*x731))+(((-1.0)*pz))+(((-0.02)*x728))+(((0.31)*x729))+(((-1.0)*x728*x735))+(((-1.0)*x728*x733))+((cj3*x728*x733)));
evalcond[3]=((-0.125)+(((-1.0)*x734))+(((-0.31)*x728))+(((-0.02)*x729))+x732+((cj3*x729*x733))+(((-1.0)*x728*x731))+(((-1.0)*x728*x730))+(((-1.0)*x729*x733))+(((-1.0)*x729*x735)));
evalcond[4]=((0.181918)+(((0.018)*cj0*px))+(((-0.04)*pz*x728))+(((0.25)*x732))+(((0.19636)*cj3))+(((0.02512)*sj3))+(((-1.0)*x734*x737))+(((-0.25)*x734))+(((-0.005)*x729))+(((-1.0)*pp))+(((0.018)*py*sj0))+((x732*x737)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x738=cj3*cj3;
IkReal x739=((0.318)*cj3);
IkReal x740=(cj0*py);
IkReal x741=(px*sj0);
IkReal x742=(cj2*cj3);
IkReal x743=(cj2*pz);
IkReal x744=((0.02)*sj3);
IkReal x745=((0.02)*pz);
CheckValue<IkReal> x746 = IKatan2WithCheck(IkReal(((0.0062)+(((-1.0)*pz*x740))+(((0.00636)*cj3))+(((0.00016)*x742))+(((0.0004)*sj3))+(((-0.01272)*cj2*x738))+(((-0.125)*pz))+(((0.01256)*cj2))+(((0.09898)*cj2*sj3))+(((0.100724)*sj3*x742))+((pz*x741)))),((0.0965)+(((0.0124)*sj3))+(((0.19716)*cj3))+(((-1.0)*(pz*pz)))+(((0.01272)*cj3*sj3))+(((0.100724)*x738))),IKFAST_ATAN2_MAGTHRESH);
if(!x746.valid){
continue;
}
CheckValue<IkReal> x747=IKPowWithIntegerCheck(IKsign(((-0.03875)+(((0.31)*x741))+(((-0.03975)*cj3))+(((-0.31)*x740))+(((0.318)*sj3*x743))+(((-1.0)*x742*x745))+((x739*x741))+((x741*x744))+(((-0.0025)*sj3))+(((-1.0)*x740*x744))+x745+(((-1.0)*x739*x740))+(((0.02)*x743)))),-1);
if(!x747.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x746.value)+(((1.5707963267949)*(x747.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x748=IKcos(j1);
IkReal x749=IKsin(j1);
IkReal x750=((0.318)*cj3);
IkReal x751=((0.02)*sj3);
IkReal x752=(px*sj0);
IkReal x753=((0.02)*cj2);
IkReal x754=(cj0*py);
IkReal x755=((0.318)*cj2*sj3);
IkReal x756=((1.0)*x748);
IkReal x757=((0.04)*x749);
evalcond[0]=((-0.31)+(((-1.0)*x754*x756))+(((-0.125)*x748))+(((-1.0)*x750))+(((-1.0)*x751))+((x748*x752))+((pz*x749)));
evalcond[1]=((-0.02)+((cj3*x753))+(((-1.0)*pz*x756))+(((-0.125)*x749))+((x749*x752))+(((-1.0)*x749*x754))+(((-1.0)*x753))+(((-1.0)*x755)));
evalcond[2]=((((0.31)*x749))+(((-0.02)*x748))+(((-1.0)*pz))+((x749*x751))+((x749*x750))+(((-1.0)*x748*x755))+(((-1.0)*x748*x753))+((cj3*x748*x753)));
evalcond[3]=((-0.125)+((cj3*x749*x753))+(((-0.31)*x748))+(((-0.02)*x749))+(((-1.0)*x754))+x752+(((-1.0)*x749*x753))+(((-1.0)*x749*x755))+(((-1.0)*x748*x751))+(((-1.0)*x748*x750)));
evalcond[4]=((0.181918)+(((0.018)*cj0*px))+((x752*x757))+(((-1.0)*x754*x757))+(((0.19636)*cj3))+(((0.02512)*sj3))+(((-0.04)*pz*x748))+(((-1.0)*pp))+(((0.25)*x752))+(((0.018)*py*sj0))+(((-0.005)*x749))+(((-0.25)*x754)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x758=px*px;
IkReal x759=cj0*cj0;
IkReal x760=py*py;
IkReal x761=(cj0*py);
IkReal x762=((0.318)*cj3);
IkReal x763=(px*sj0);
IkReal x764=((25.0)*pp);
IkReal x765=((0.02)*sj3);
IkReal x766=((0.45)*px);
IkReal x767=(py*sj0);
IkReal x768=((0.628)*sj3);
IkReal x769=((4.909)*cj3);
IkReal x770=((6.25)*pz);
IkReal x771=((6.25)*x759);
IkReal x772=((0.45)*cj0*sj0);
CheckValue<IkReal> x773=IKPowWithIntegerCheck(IKsign(((-0.015625)+(((2.0)*x761*x763))+((x758*x759))+(((0.25)*x763))+(((-1.0)*(pz*pz)))+(((-1.0)*x758))+(((-0.25)*x761))+(((-1.0)*x759*x760)))),-1);
if(!x773.valid){
continue;
}
CheckValue<IkReal> x774 = IKatan2WithCheck(IkReal(((-0.56849375)+(((-12.5)*x761*x763))+(((-0.9)*px*py*x759))+(((-0.31)*pz))+(((-0.0785)*sj3))+(((-1.0)*x763*x764))+(((-3.7667)*x761))+((x758*x772))+(((-0.05625)*cj0*px))+((x761*x764))+((x763*x768))+((x763*x769))+(((3.7667)*x763))+(((6.25)*x758))+(((-1.0)*x758*x771))+(((-0.613625)*cj3))+((py*x766))+(((-0.05625)*x767))+((x760*x771))+(((-1.0)*x761*x768))+(((-1.0)*x761*x769))+(((-1.0)*x760*x772))+(((-1.0)*pz*x762))+(((-1.0)*pz*x765))+(((3.125)*pp)))),((0.03875)+(((-0.45)*pz*x767))+(((-1.0)*x763*x765))+(((-1.0)*x762*x763))+(((-1.0)*cj0*pz*x766))+(((0.31)*x761))+((x761*x762))+((x761*x765))+(((0.0025)*sj3))+((pz*x764))+(((-0.31)*x763))+(((-4.54795)*pz))+(((-1.0)*x763*x770))+((x761*x770))+(((0.03975)*cj3))+(((-1.0)*pz*x769))+(((-1.0)*pz*x768))),IKFAST_ATAN2_MAGTHRESH);
if(!x774.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x773.value)))+(x774.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[2];
IkReal x775=IKcos(j1);
IkReal x776=IKsin(j1);
IkReal x777=(px*sj0);
IkReal x778=(cj0*py);
IkReal x779=((0.04)*x776);
evalcond[0]=((-0.31)+((pz*x776))+(((-0.02)*sj3))+(((-0.318)*cj3))+(((-1.0)*x775*x778))+(((-0.125)*x775))+((x775*x777)));
evalcond[1]=((0.181918)+(((0.018)*cj0*px))+(((-1.0)*x778*x779))+((x777*x779))+(((-0.25)*x778))+(((0.19636)*cj3))+(((0.02512)*sj3))+(((-0.04)*pz*x775))+(((-1.0)*pp))+(((0.018)*py*sj0))+(((-0.005)*x776))+(((0.25)*x777)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j2eval[3];
IkReal x780=((1.0)*cj0);
j2eval[0]=((1.0)+(((15.9)*sj3))+(((-1.0)*cj3)));
j2eval[1]=IKsign(((0.02)+(((0.318)*sj3))+(((-0.02)*cj3))));
j2eval[2]=((IKabs(((0.009)+(((-1.0)*px*x780))+(((-1.0)*py*sj0)))))+(IKabs(((-0.02)+((px*sj0*sj1))+(((-1.0)*cj1*pz))+(((-0.125)*sj1))+(((-1.0)*py*sj1*x780))))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[2];
IkReal x781=((15.9)*sj3);
j2eval[0]=((1.0)+x781+(((-1.0)*cj3)));
j2eval[1]=((((-1.0)*cj1*x781))+((cj1*cj3))+(((-1.0)*cj1)));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  )
{
{
IkReal j2eval[1];
j2eval[0]=((1.0)+(((15.9)*sj3))+(((-1.0)*cj3)));
if( IKabs(j2eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[4];
bool bgotonextstatement = true;
do
{
IkReal x782=(px*sj0);
IkReal x783=(cj0*py);
IkReal x784=((0.04)*sj1);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.26721335889799)+j3)))), 6.28318530717959)));
evalcond[1]=((0.00799999885047098)+((cj1*x782))+((pz*sj1))+(((-1.0)*cj1*x783))+(((-0.125)*cj1)));
evalcond[2]=((-0.0160419992903604)+(((0.018)*cj0*px))+((x782*x784))+(((0.25)*x782))+(((-1.0)*pp))+(((0.018)*py*sj0))+(((-0.005)*sj1))+(((-0.04)*cj1*pz))+(((-0.25)*x783))+(((-1.0)*x783*x784)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x785=((13036080734.8056)*py);
IkReal x786=((13036080734.8056)*px);
if( IKabs(((-117324726.61325)+((sj0*x785))+((cj0*x786)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((260721614.696111)+(((-1.0)*sj0*sj1*x786))+(((13036080734.8056)*cj1*pz))+((cj0*sj1*x785))+(((1629510091.8507)*sj1)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-117324726.61325)+((sj0*x785))+((cj0*x786))))+IKsqr(((260721614.696111)+(((-1.0)*sj0*sj1*x786))+(((13036080734.8056)*cj1*pz))+((cj0*sj1*x785))+(((1629510091.8507)*sj1))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((-117324726.61325)+((sj0*x785))+((cj0*x786))), ((260721614.696111)+(((-1.0)*sj0*sj1*x786))+(((13036080734.8056)*cj1*pz))+((cj0*sj1*x785))+(((1629510091.8507)*sj1))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[5];
IkReal x787=IKcos(j2);
IkReal x788=(px*sj0);
IkReal x789=((1.0)*pz);
IkReal x790=(py*sj0);
IkReal x791=(cj0*px);
IkReal x792=(cj0*py);
IkReal x793=((7.67101723549516e-11)*x787);
evalcond[0]=((-0.009)+(((-7.67101723549516e-11)*(IKsin(j2))))+x791+x790);
evalcond[1]=((((-1.0)*x789))+((cj1*x793))+(((-0.00799999885047098)*sj1))+(((-0.02)*cj1)));
evalcond[2]=((-0.125)+(((-0.02)*sj1))+((sj1*x793))+(((0.00799999885047098)*cj1))+x788+(((-1.0)*x792)));
evalcond[3]=((-0.02)+((sj1*x788))+(((-1.0)*cj1*x789))+x793+(((-0.125)*sj1))+(((-1.0)*sj1*x792)));
evalcond[4]=((-0.0152419992903604)+(((0.018)*x791))+(((0.018)*x790))+(((-3.06840689419807e-12)*x787))+(((0.25)*x788))+(((-1.0)*pp))+(((-0.25)*x792)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x794=((0.02)*sj3);
IkReal x795=((0.318)*cj3);
IkReal x796=(x795+x794);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j1)))), 6.28318530717959)));
evalcond[1]=((-0.31)+(((-1.0)*x796))+pz);
evalcond[2]=((0.31)+(((-1.0)*pz))+x796);
evalcond[3]=((0.176918)+(((0.018)*cj0*px))+(((0.19636)*cj3))+(((0.02512)*sj3))+(((0.29)*px*sj0))+(((-1.0)*pp))+(((-0.29)*cj0*py))+(((0.018)*py*sj0)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[3];
sj1=1.0;
cj1=0;
j1=1.5707963267949;
IkReal x797=((1.0)*cj0);
j2eval[0]=((1.0)+(((15.9)*sj3))+(((-1.0)*cj3)));
j2eval[1]=((IKabs(((0.009)+(((-1.0)*px*x797))+(((-1.0)*py*sj0)))))+(IKabs(((-0.145)+((px*sj0))+(((-1.0)*py*x797))))));
j2eval[2]=IKsign(((0.02)+(((0.318)*sj3))+(((-0.02)*cj3))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[1];
sj1=1.0;
cj1=0;
j1=1.5707963267949;
j2eval[0]=((1.0)+(((15.9)*sj3))+(((-1.0)*cj3)));
if( IKabs(j2eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[3];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.26721335889799)+j3)))), 6.28318530717959)));
evalcond[1]=((0.00799999885047098)+pz);
evalcond[2]=((-0.0210419992903604)+(((0.018)*cj0*px))+(((0.29)*px*sj0))+(((-1.0)*pp))+(((-0.29)*cj0*py))+(((0.018)*py*sj0)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x798=((13036080734.8056)*sj0);
IkReal x799=((13036080734.8056)*cj0);
if( IKabs(((-117324726.61325)+((px*x799))+((py*x798)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((1890231706.54681)+(((-1.0)*px*x798))+((py*x799)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-117324726.61325)+((px*x799))+((py*x798))))+IKsqr(((1890231706.54681)+(((-1.0)*px*x798))+((py*x799))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((-117324726.61325)+((px*x799))+((py*x798))), ((1890231706.54681)+(((-1.0)*px*x798))+((py*x799))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[3];
IkReal x800=IKcos(j2);
IkReal x801=(cj0*px);
IkReal x802=(py*sj0);
IkReal x803=(px*sj0);
IkReal x804=(cj0*py);
evalcond[0]=((-0.009)+(((-7.67101723549516e-11)*(IKsin(j2))))+x801+x802);
evalcond[1]=((-0.145)+(((-1.0)*x804))+(((7.67101723549516e-11)*x800))+x803);
evalcond[2]=((-0.0152419992903604)+(((0.018)*x801))+(((0.018)*x802))+(((-3.06840689419807e-12)*x800))+(((-1.0)*pp))+(((0.25)*x803))+(((-0.25)*x804)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j2]

}
} while(0);
if( bgotonextstatement )
{
}
}
}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x805=(py*sj0);
IkReal x806=(cj0*px);
CheckValue<IkReal> x807=IKPowWithIntegerCheck(((0.02)+(((0.318)*sj3))+(((-0.02)*cj3))),-1);
if(!x807.valid){
continue;
}
CheckValue<IkReal> x808=IKPowWithIntegerCheck(((0.0008)+(((-0.0008)*cj3))+(((0.01272)*sj3))),-1);
if(!x808.valid){
continue;
}
if( IKabs(((x807.value)*(((0.009)+(((-1.0)*x805))+(((-1.0)*x806)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x808.value)*(((-0.182718)+(((-0.25)*px*sj0))+(((-0.19636)*cj3))+(((-0.02512)*sj3))+pp+(((0.25)*cj0*py))+(((-0.018)*x806))+(((-0.018)*x805)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x807.value)*(((0.009)+(((-1.0)*x805))+(((-1.0)*x806))))))+IKsqr(((x808.value)*(((-0.182718)+(((-0.25)*px*sj0))+(((-0.19636)*cj3))+(((-0.02512)*sj3))+pp+(((0.25)*cj0*py))+(((-0.018)*x806))+(((-0.018)*x805))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((x807.value)*(((0.009)+(((-1.0)*x805))+(((-1.0)*x806))))), ((x808.value)*(((-0.182718)+(((-0.25)*px*sj0))+(((-0.19636)*cj3))+(((-0.02512)*sj3))+pp+(((0.25)*cj0*py))+(((-0.018)*x806))+(((-0.018)*x805))))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[3];
IkReal x809=IKsin(j2);
IkReal x810=IKcos(j2);
IkReal x811=(cj0*px);
IkReal x812=(py*sj0);
IkReal x813=(px*sj0);
IkReal x814=(cj0*py);
IkReal x815=((0.02)*x810);
IkReal x816=((0.02)*x809);
IkReal x817=(sj3*x810);
IkReal x818=((0.0008)*x810);
evalcond[0]=((-0.009)+(((-1.0)*cj3*x816))+(((0.318)*sj3*x809))+x816+x812+x811);
evalcond[1]=((-0.145)+((cj3*x815))+(((-1.0)*x815))+(((-1.0)*x814))+(((-0.318)*x817))+x813);
evalcond[2]=((0.182718)+(((0.25)*x813))+(((-1.0)*cj3*x818))+(((-0.25)*x814))+(((0.19636)*cj3))+(((0.02512)*sj3))+(((0.018)*x811))+(((0.018)*x812))+(((-1.0)*pp))+(((0.01272)*x817))+x818);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x819=((1.0)*cj0);
CheckValue<IkReal> x820 = IKatan2WithCheck(IkReal(((0.009)+(((-1.0)*px*x819))+(((-1.0)*py*sj0)))),((-0.145)+(((-1.0)*py*x819))+((px*sj0))),IKFAST_ATAN2_MAGTHRESH);
if(!x820.valid){
continue;
}
CheckValue<IkReal> x821=IKPowWithIntegerCheck(IKsign(((0.02)+(((0.318)*sj3))+(((-0.02)*cj3)))),-1);
if(!x821.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(x820.value)+(((1.5707963267949)*(x821.value))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[3];
IkReal x822=IKsin(j2);
IkReal x823=IKcos(j2);
IkReal x824=(cj0*px);
IkReal x825=(py*sj0);
IkReal x826=(px*sj0);
IkReal x827=(cj0*py);
IkReal x828=((0.02)*x823);
IkReal x829=((0.02)*x822);
IkReal x830=(sj3*x823);
IkReal x831=((0.0008)*x823);
evalcond[0]=((-0.009)+x829+x825+x824+(((-1.0)*cj3*x829))+(((0.318)*sj3*x822)));
evalcond[1]=((-0.145)+(((-1.0)*x828))+(((-1.0)*x827))+(((-0.318)*x830))+x826+((cj3*x828)));
evalcond[2]=((0.182718)+(((0.018)*x825))+(((0.018)*x824))+(((0.25)*x826))+(((0.19636)*cj3))+(((0.02512)*sj3))+(((-0.25)*x827))+(((0.01272)*x830))+(((-1.0)*pp))+x831+(((-1.0)*cj3*x831)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x832=((-0.31)+(((-0.02)*sj3))+(((-0.318)*cj3))+(((-1.0)*pz)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j1)))), 6.28318530717959)));
evalcond[1]=x832;
evalcond[2]=x832;
evalcond[3]=((0.186918)+(((0.018)*cj0*px))+(((0.19636)*cj3))+(((0.02512)*sj3))+(((-1.0)*pp))+(((-0.21)*cj0*py))+(((0.018)*py*sj0))+(((0.21)*px*sj0)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[3];
sj1=-1.0;
cj1=0;
j1=-1.5707963267949;
IkReal x833=((1.0)*px);
j2eval[0]=((1.0)+(((15.9)*sj3))+(((-1.0)*cj3)));
j2eval[1]=IKsign(((0.02)+(((0.318)*sj3))+(((-0.02)*cj3))));
j2eval[2]=((IKabs(((0.105)+(((-1.0)*sj0*x833))+((cj0*py)))))+(IKabs(((0.009)+(((-1.0)*cj0*x833))+(((-1.0)*py*sj0))))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[1];
sj1=-1.0;
cj1=0;
j1=-1.5707963267949;
j2eval[0]=((1.0)+(((15.9)*sj3))+(((-1.0)*cj3)));
if( IKabs(j2eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[3];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.26721335889799)+j3)))), 6.28318530717959)));
evalcond[1]=((0.00799999885047098)+(((-1.0)*pz)));
evalcond[2]=((-0.0110419992903604)+(((0.018)*cj0*px))+(((-1.0)*pp))+(((-0.21)*cj0*py))+(((0.018)*py*sj0))+(((0.21)*px*sj0)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x834=((13036080734.8056)*sj0);
IkReal x835=((13036080734.8056)*cj0);
if( IKabs(((-117324726.61325)+((py*x834))+((px*x835)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1368788477.15459)+(((-1.0)*py*x835))+((px*x834)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-117324726.61325)+((py*x834))+((px*x835))))+IKsqr(((-1368788477.15459)+(((-1.0)*py*x835))+((px*x834))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((-117324726.61325)+((py*x834))+((px*x835))), ((-1368788477.15459)+(((-1.0)*py*x835))+((px*x834))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[3];
IkReal x836=IKcos(j2);
IkReal x837=(cj0*px);
IkReal x838=(py*sj0);
IkReal x839=(px*sj0);
IkReal x840=(cj0*py);
evalcond[0]=((-0.009)+(((-7.67101723549516e-11)*(IKsin(j2))))+x837+x838);
evalcond[1]=((0.105)+(((7.67101723549516e-11)*x836))+(((-1.0)*x839))+x840);
evalcond[2]=((-0.0152419992903604)+(((0.018)*x838))+(((0.018)*x837))+(((-1.0)*pp))+(((-3.06840689419807e-12)*x836))+(((0.25)*x839))+(((-0.25)*x840)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j2]

}
} while(0);
if( bgotonextstatement )
{
}
}
}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x841=(py*sj0);
IkReal x842=(cj0*px);
CheckValue<IkReal> x843=IKPowWithIntegerCheck(((0.02)+(((0.318)*sj3))+(((-0.02)*cj3))),-1);
if(!x843.valid){
continue;
}
CheckValue<IkReal> x844=IKPowWithIntegerCheck(((0.0008)+(((-0.0008)*cj3))+(((0.01272)*sj3))),-1);
if(!x844.valid){
continue;
}
if( IKabs(((x843.value)*(((0.009)+(((-1.0)*x842))+(((-1.0)*x841)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x844.value)*(((-0.182718)+(((-0.25)*px*sj0))+(((-0.018)*x841))+(((-0.018)*x842))+(((-0.19636)*cj3))+(((-0.02512)*sj3))+pp+(((0.25)*cj0*py)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x843.value)*(((0.009)+(((-1.0)*x842))+(((-1.0)*x841))))))+IKsqr(((x844.value)*(((-0.182718)+(((-0.25)*px*sj0))+(((-0.018)*x841))+(((-0.018)*x842))+(((-0.19636)*cj3))+(((-0.02512)*sj3))+pp+(((0.25)*cj0*py))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((x843.value)*(((0.009)+(((-1.0)*x842))+(((-1.0)*x841))))), ((x844.value)*(((-0.182718)+(((-0.25)*px*sj0))+(((-0.018)*x841))+(((-0.018)*x842))+(((-0.19636)*cj3))+(((-0.02512)*sj3))+pp+(((0.25)*cj0*py))))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[3];
IkReal x845=IKsin(j2);
IkReal x846=IKcos(j2);
IkReal x847=(cj0*px);
IkReal x848=(py*sj0);
IkReal x849=(px*sj0);
IkReal x850=(cj0*py);
IkReal x851=((0.02)*x846);
IkReal x852=((0.02)*x845);
IkReal x853=(sj3*x846);
IkReal x854=((0.0008)*x846);
evalcond[0]=((-0.009)+(((0.318)*sj3*x845))+(((-1.0)*cj3*x852))+x852+x847+x848);
evalcond[1]=((0.105)+(((-0.318)*x853))+(((-1.0)*x851))+((cj3*x851))+(((-1.0)*x849))+x850);
evalcond[2]=((0.182718)+(((0.018)*x848))+(((0.018)*x847))+(((0.19636)*cj3))+(((0.02512)*sj3))+(((-0.25)*x850))+(((-1.0)*cj3*x854))+(((-1.0)*pp))+(((0.01272)*x853))+x854+(((0.25)*x849)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x855=((1.0)*px);
CheckValue<IkReal> x856 = IKatan2WithCheck(IkReal(((0.009)+(((-1.0)*py*sj0))+(((-1.0)*cj0*x855)))),((0.105)+(((-1.0)*sj0*x855))+((cj0*py))),IKFAST_ATAN2_MAGTHRESH);
if(!x856.valid){
continue;
}
CheckValue<IkReal> x857=IKPowWithIntegerCheck(IKsign(((0.02)+(((0.318)*sj3))+(((-0.02)*cj3)))),-1);
if(!x857.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(x856.value)+(((1.5707963267949)*(x857.value))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[3];
IkReal x858=IKsin(j2);
IkReal x859=IKcos(j2);
IkReal x860=(cj0*px);
IkReal x861=(py*sj0);
IkReal x862=(px*sj0);
IkReal x863=(cj0*py);
IkReal x864=((0.02)*x859);
IkReal x865=((0.02)*x858);
IkReal x866=(sj3*x859);
IkReal x867=((0.0008)*x859);
evalcond[0]=((-0.009)+(((-1.0)*cj3*x865))+(((0.318)*sj3*x858))+x865+x861+x860);
evalcond[1]=((0.105)+(((-1.0)*x864))+((cj3*x864))+(((-1.0)*x862))+x863+(((-0.318)*x866)));
evalcond[2]=((0.182718)+(((-1.0)*cj3*x867))+(((0.19636)*cj3))+(((0.02512)*sj3))+(((0.25)*x862))+(((0.018)*x861))+(((0.018)*x860))+(((-1.0)*pp))+(((-0.25)*x863))+x867+(((0.01272)*x866)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j2]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x868=(py*sj0);
IkReal x869=(cj0*px);
CheckValue<IkReal> x870=IKPowWithIntegerCheck(((0.02)+(((0.318)*sj3))+(((-0.02)*cj3))),-1);
if(!x870.valid){
continue;
}
CheckValue<IkReal> x871=IKPowWithIntegerCheck(((0.0008)+(((-0.0008)*cj3))+(((0.01272)*sj3))),-1);
if(!x871.valid){
continue;
}
if( IKabs(((x870.value)*(((0.009)+(((-1.0)*x869))+(((-1.0)*x868)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x871.value)*(((-0.182718)+(((-0.25)*px*sj0))+(((-0.19636)*cj3))+(((-0.02512)*sj3))+pp+(((0.25)*cj0*py))+(((-0.018)*x868))+(((-0.018)*x869)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x870.value)*(((0.009)+(((-1.0)*x869))+(((-1.0)*x868))))))+IKsqr(((x871.value)*(((-0.182718)+(((-0.25)*px*sj0))+(((-0.19636)*cj3))+(((-0.02512)*sj3))+pp+(((0.25)*cj0*py))+(((-0.018)*x868))+(((-0.018)*x869))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((x870.value)*(((0.009)+(((-1.0)*x869))+(((-1.0)*x868))))), ((x871.value)*(((-0.182718)+(((-0.25)*px*sj0))+(((-0.19636)*cj3))+(((-0.02512)*sj3))+pp+(((0.25)*cj0*py))+(((-0.018)*x868))+(((-0.018)*x869))))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[5];
IkReal x872=IKsin(j2);
IkReal x873=IKcos(j2);
IkReal x874=(px*sj0);
IkReal x875=((0.02)*sj1);
IkReal x876=((0.318)*sj3);
IkReal x877=((1.0)*pz);
IkReal x878=(py*sj0);
IkReal x879=((0.318)*cj3);
IkReal x880=(cj0*px);
IkReal x881=(cj0*py);
IkReal x882=((0.02)*cj1);
IkReal x883=((0.02)*x872);
IkReal x884=((0.0008)*x873);
IkReal x885=((0.02)*x873);
IkReal x886=(x873*x882);
evalcond[0]=((-0.009)+(((-1.0)*cj3*x883))+((x872*x876))+x878+x880+x883);
evalcond[1]=((-0.02)+((cj3*x885))+(((-1.0)*x873*x876))+(((-1.0)*x885))+(((-1.0)*sj1*x881))+((sj1*x874))+(((-1.0)*cj1*x877))+(((-0.125)*sj1)));
evalcond[2]=(((cj3*x886))+((sj3*x875))+(((0.31)*sj1))+(((-1.0)*x882))+(((-1.0)*x886))+((sj1*x879))+(((-1.0)*cj1*x873*x876))+(((-1.0)*x877)));
evalcond[3]=((-0.125)+(((-1.0)*sj1*x873*x876))+(((-1.0)*x873*x875))+(((-1.0)*x881))+((cj3*x873*x875))+(((-1.0)*cj1*x879))+x874+(((-1.0)*sj3*x882))+(((-0.31)*cj1))+(((-1.0)*x875)));
evalcond[4]=((0.182718)+(((-1.0)*cj3*x884))+(((-0.25)*x881))+(((0.19636)*cj3))+(((0.01272)*sj3*x873))+(((0.02512)*sj3))+(((0.018)*x880))+(((0.25)*x874))+(((-1.0)*pp))+(((0.018)*x878))+x884);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x887=((0.02)*cj1);
IkReal x888=((0.318)*sj3);
CheckValue<IkReal> x889=IKPowWithIntegerCheck(((0.02)+x888+(((-0.02)*cj3))),-1);
if(!x889.valid){
continue;
}
CheckValue<IkReal> x890=IKPowWithIntegerCheck((((cj3*x887))+(((-1.0)*x887))+(((-1.0)*cj1*x888))),-1);
if(!x890.valid){
continue;
}
if( IKabs(((x889.value)*(((0.009)+(((-1.0)*py*sj0))+(((-1.0)*cj0*px)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x890.value)*(((((-0.02)*sj1*sj3))+(((-0.318)*cj3*sj1))+pz+x887+(((-0.31)*sj1)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x889.value)*(((0.009)+(((-1.0)*py*sj0))+(((-1.0)*cj0*px))))))+IKsqr(((x890.value)*(((((-0.02)*sj1*sj3))+(((-0.318)*cj3*sj1))+pz+x887+(((-0.31)*sj1))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((x889.value)*(((0.009)+(((-1.0)*py*sj0))+(((-1.0)*cj0*px))))), ((x890.value)*(((((-0.02)*sj1*sj3))+(((-0.318)*cj3*sj1))+pz+x887+(((-0.31)*sj1))))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[5];
IkReal x891=IKsin(j2);
IkReal x892=IKcos(j2);
IkReal x893=(px*sj0);
IkReal x894=((0.02)*sj1);
IkReal x895=((0.318)*sj3);
IkReal x896=((1.0)*pz);
IkReal x897=(py*sj0);
IkReal x898=((0.318)*cj3);
IkReal x899=(cj0*px);
IkReal x900=(cj0*py);
IkReal x901=((0.02)*cj1);
IkReal x902=((0.02)*x891);
IkReal x903=((0.0008)*x892);
IkReal x904=((0.02)*x892);
IkReal x905=(x892*x901);
evalcond[0]=((-0.009)+((x891*x895))+x897+x899+(((-1.0)*cj3*x902))+x902);
evalcond[1]=((-0.02)+(((-1.0)*x892*x895))+((sj1*x893))+((cj3*x904))+(((-1.0)*x904))+(((-1.0)*sj1*x900))+(((-1.0)*cj1*x896))+(((-0.125)*sj1)));
evalcond[2]=(((sj1*x898))+(((0.31)*sj1))+((cj3*x905))+(((-1.0)*x905))+(((-1.0)*x901))+(((-1.0)*x896))+(((-1.0)*cj1*x892*x895))+((sj3*x894)));
evalcond[3]=((-0.125)+(((-1.0)*x892*x894))+(((-1.0)*sj3*x901))+(((-1.0)*x894))+(((-1.0)*sj1*x892*x895))+(((-1.0)*x900))+x893+(((-1.0)*cj1*x898))+((cj3*x892*x894))+(((-0.31)*cj1)));
evalcond[4]=((0.182718)+(((0.19636)*cj3))+(((0.02512)*sj3))+(((0.018)*x899))+(((0.018)*x897))+(((-1.0)*pp))+(((-0.25)*x900))+(((-1.0)*cj3*x903))+x903+(((0.01272)*sj3*x892))+(((0.25)*x893)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x906=((1.0)*cj0);
CheckValue<IkReal> x907=IKPowWithIntegerCheck(IKsign(((0.02)+(((0.318)*sj3))+(((-0.02)*cj3)))),-1);
if(!x907.valid){
continue;
}
CheckValue<IkReal> x908 = IKatan2WithCheck(IkReal(((0.009)+(((-1.0)*px*x906))+(((-1.0)*py*sj0)))),((-0.02)+((px*sj0*sj1))+(((-1.0)*cj1*pz))+(((-1.0)*py*sj1*x906))+(((-0.125)*sj1))),IKFAST_ATAN2_MAGTHRESH);
if(!x908.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x907.value)))+(x908.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[5];
IkReal x909=IKsin(j2);
IkReal x910=IKcos(j2);
IkReal x911=(px*sj0);
IkReal x912=((0.02)*sj1);
IkReal x913=((0.318)*sj3);
IkReal x914=((1.0)*pz);
IkReal x915=(py*sj0);
IkReal x916=((0.318)*cj3);
IkReal x917=(cj0*px);
IkReal x918=(cj0*py);
IkReal x919=((0.02)*cj1);
IkReal x920=((0.02)*x909);
IkReal x921=((0.0008)*x910);
IkReal x922=((0.02)*x910);
IkReal x923=(x910*x919);
evalcond[0]=((-0.009)+((x909*x913))+(((-1.0)*cj3*x920))+x920+x917+x915);
evalcond[1]=((-0.02)+(((-1.0)*x922))+(((-1.0)*x910*x913))+((cj3*x922))+(((-1.0)*sj1*x918))+(((-1.0)*cj1*x914))+(((-0.125)*sj1))+((sj1*x911)));
evalcond[2]=((((-1.0)*x923))+(((0.31)*sj1))+(((-1.0)*x919))+(((-1.0)*x914))+((sj3*x912))+((cj3*x923))+(((-1.0)*cj1*x910*x913))+((sj1*x916)));
evalcond[3]=((-0.125)+(((-1.0)*sj1*x910*x913))+((cj3*x910*x912))+(((-1.0)*x912))+(((-1.0)*x910*x912))+(((-1.0)*sj3*x919))+(((-1.0)*x918))+(((-1.0)*cj1*x916))+x911+(((-0.31)*cj1)));
evalcond[4]=((0.182718)+(((-1.0)*cj3*x921))+(((0.19636)*cj3))+(((0.02512)*sj3))+(((-0.25)*x918))+(((-1.0)*pp))+(((0.01272)*sj3*x910))+(((0.018)*x917))+(((0.018)*x915))+x921+(((0.25)*x911)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}
    }
}
return solutions.GetNumSolutions()>0;
}
inline void rotationfunction0(IkSolutionListBase<IkReal>& solutions) {
for(int rotationiter = 0; rotationiter < 1; ++rotationiter) {
IkReal x222=(cj3*sj1);
IkReal x223=(sj0*sj2);
IkReal x224=((1.0)*sj3);
IkReal x225=(cj1*cj3);
IkReal x226=(cj0*sj2);
IkReal x227=((1.0)*cj1*sj2);
IkReal x228=(((cj2*sj0))+(((-1.0)*sj1*x226)));
IkReal x229=(((cj0*cj2))+((sj1*x223)));
IkReal x230=(((cj2*x222))+(((-1.0)*cj1*x224)));
IkReal x231=(((cj2*x225))+((sj1*sj3)));
IkReal x232=((((-1.0)*cj1*cj2*x224))+x222);
IkReal x233=((((-1.0)*cj2*sj1*x224))+(((-1.0)*x225)));
IkReal x234=(((cj3*x223))+((cj0*x230)));
IkReal x235=(((cj3*x226))+(((-1.0)*sj0*x230)));
IkReal x236=((((-1.0)*x223*x224))+((cj0*x233)));
IkReal x237=((((-1.0)*sj3*x226))+(((-1.0)*sj0*x233)));
new_r00=(((r00*x229))+((r10*x228))+(((-1.0)*r20*x227)));
new_r01=(((r01*x229))+((r11*x228))+(((-1.0)*r21*x227)));
new_r02=(((r12*x228))+((r02*x229))+(((-1.0)*r22*x227)));
new_r10=(((r10*x234))+((r00*x235))+((r20*x231)));
new_r11=(((r11*x234))+((r01*x235))+((r21*x231)));
new_r12=(((r02*x235))+((r12*x234))+((r22*x231)));
new_r20=(((r10*x236))+((r00*x237))+((r20*x232)));
new_r21=(((r11*x236))+((r01*x237))+((r21*x232)));
new_r22=(((r02*x237))+((r12*x236))+((r22*x232)));
{
IkReal j5array[2], cj5array[2], sj5array[2];
bool j5valid[2]={false};
_nj5 = 2;
cj5array[0]=new_r22;
if( cj5array[0] >= -1-IKFAST_SINCOS_THRESH && cj5array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j5valid[0] = j5valid[1] = true;
    j5array[0] = IKacos(cj5array[0]);
    sj5array[0] = IKsin(j5array[0]);
    cj5array[1] = cj5array[0];
    j5array[1] = -j5array[0];
    sj5array[1] = -sj5array[0];
}
else if( isnan(cj5array[0]) )
{
    // probably any value will work
    j5valid[0] = true;
    cj5array[0] = 1; sj5array[0] = 0; j5array[0] = 0;
}
for(int ij5 = 0; ij5 < 2; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 2; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
IkReal j4eval[2];
IkReal x238=(cj3*sj1);
IkReal x239=(sj0*sj2);
IkReal x240=((1.0)*sj3);
IkReal x241=(cj1*cj3);
IkReal x242=(cj0*sj2);
IkReal x243=((1.0)*cj1*sj2);
IkReal x244=x228;
IkReal x245=x229;
IkReal x246=x230;
IkReal x247=x231;
IkReal x248=x232;
IkReal x249=x233;
IkReal x250=(((cj0*x246))+((cj3*x239)));
IkReal x251=((((-1.0)*sj0*x246))+((cj3*x242)));
IkReal x252=(((cj0*x249))+(((-1.0)*x239*x240)));
IkReal x253=((((-1.0)*sj3*x242))+(((-1.0)*sj0*x249)));
new_r00=(((r00*x245))+((r10*x244))+(((-1.0)*r20*x243)));
new_r01=(((r01*x245))+((r11*x244))+(((-1.0)*r21*x243)));
new_r02=(((r02*x245))+((r12*x244))+(((-1.0)*r22*x243)));
new_r10=(((r00*x251))+((r10*x250))+((r20*x247)));
new_r11=(((r11*x250))+((r01*x251))+((r21*x247)));
new_r12=(((r22*x247))+((r12*x250))+((r02*x251)));
new_r20=(((r00*x253))+((r10*x252))+((r20*x248)));
new_r21=(((r11*x252))+((r01*x253))+((r21*x248)));
new_r22=(((r22*x248))+((r12*x252))+((r02*x253)));
j4eval[0]=sj5;
j4eval[1]=IKsign(sj5);
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
{
IkReal j4eval[1];
IkReal x254=(cj3*sj1);
IkReal x255=(sj0*sj2);
IkReal x256=((1.0)*sj3);
IkReal x257=(cj1*cj3);
IkReal x258=(cj0*sj2);
IkReal x259=((1.0)*cj1*sj2);
IkReal x260=x228;
IkReal x261=x229;
IkReal x262=x230;
IkReal x263=x231;
IkReal x264=x232;
IkReal x265=x233;
IkReal x266=(((cj3*x255))+((cj0*x262)));
IkReal x267=(((cj3*x258))+(((-1.0)*sj0*x262)));
IkReal x268=(((cj0*x265))+(((-1.0)*x255*x256)));
IkReal x269=((((-1.0)*sj3*x258))+(((-1.0)*sj0*x265)));
new_r00=((((-1.0)*r20*x259))+((r00*x261))+((r10*x260)));
new_r01=((((-1.0)*r21*x259))+((r11*x260))+((r01*x261)));
new_r02=((((-1.0)*r22*x259))+((r02*x261))+((r12*x260)));
new_r10=(((r00*x267))+((r10*x266))+((r20*x263)));
new_r11=(((r21*x263))+((r11*x266))+((r01*x267)));
new_r12=(((r22*x263))+((r02*x267))+((r12*x266)));
new_r20=(((r00*x269))+((r10*x268))+((r20*x264)));
new_r21=(((r21*x264))+((r11*x268))+((r01*x269)));
new_r22=(((r22*x264))+((r02*x269))+((r12*x268)));
j4eval[0]=sj5;
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[6];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j5))), 6.28318530717959)));
evalcond[1]=((-1.0)+new_r22);
evalcond[2]=new_r20;
evalcond[3]=new_r02;
evalcond[4]=new_r12;
evalcond[5]=new_r21;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[2], cj4array[2], sj4array[2];
bool j4valid[2]={false};
_nj4 = 2;
CheckValue<IkReal> x271 = IKatan2WithCheck(IkReal(new_r02),new_r12,IKFAST_ATAN2_MAGTHRESH);
if(!x271.valid){
continue;
}
IkReal x270=x271.value;
j4array[0]=((-1.0)*x270);
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
j4array[1]=((3.14159265358979)+(((-1.0)*x270)));
sj4array[1]=IKsin(j4array[1]);
cj4array[1]=IKcos(j4array[1]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
if( j4array[1] > IKPI )
{
    j4array[1]-=IK2PI;
}
else if( j4array[1] < -IKPI )
{    j4array[1]+=IK2PI;
}
j4valid[1] = true;
for(int ij4 = 0; ij4 < 2; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 2; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[1];
evalcond[0]=(((new_r12*(IKcos(j4))))+(((-1.0)*new_r02*(IKsin(j4)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x272=((1.0)*new_r01);
if( IKabs(((((-1.0)*cj4*x272))+(((-1.0)*new_r00*sj4)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj4*new_r00))+(((-1.0)*sj4*x272)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj4*x272))+(((-1.0)*new_r00*sj4))))+IKsqr((((cj4*new_r00))+(((-1.0)*sj4*x272))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((((-1.0)*cj4*x272))+(((-1.0)*new_r00*sj4))), (((cj4*new_r00))+(((-1.0)*sj4*x272))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x273=IKsin(j6);
IkReal x274=IKcos(j6);
IkReal x275=((1.0)*sj4);
IkReal x276=((1.0)*x274);
IkReal x277=(sj4*x273);
IkReal x278=(sj4*x274);
IkReal x279=(cj4*x273);
IkReal x280=(cj4*x276);
evalcond[0]=(((cj4*new_r01))+((new_r11*sj4))+x273);
evalcond[1]=(x278+x279+new_r01);
evalcond[2]=(((cj4*new_r00))+((new_r10*sj4))+(((-1.0)*x276)));
evalcond[3]=((((-1.0)*x273))+((cj4*new_r10))+(((-1.0)*new_r00*x275)));
evalcond[4]=((((-1.0)*new_r01*x275))+((cj4*new_r11))+(((-1.0)*x276)));
evalcond[5]=(x277+(((-1.0)*x280))+new_r00);
evalcond[6]=(x277+(((-1.0)*x280))+new_r11);
evalcond[7]=((((-1.0)*x274*x275))+(((-1.0)*x279))+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j5)))), 6.28318530717959)));
evalcond[1]=((1.0)+new_r22);
evalcond[2]=new_r20;
evalcond[3]=new_r02;
evalcond[4]=new_r12;
evalcond[5]=new_r21;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[2], cj4array[2], sj4array[2];
bool j4valid[2]={false};
_nj4 = 2;
CheckValue<IkReal> x282 = IKatan2WithCheck(IkReal(new_r02),new_r12,IKFAST_ATAN2_MAGTHRESH);
if(!x282.valid){
continue;
}
IkReal x281=x282.value;
j4array[0]=((-1.0)*x281);
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
j4array[1]=((3.14159265358979)+(((-1.0)*x281)));
sj4array[1]=IKsin(j4array[1]);
cj4array[1]=IKcos(j4array[1]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
if( j4array[1] > IKPI )
{
    j4array[1]-=IK2PI;
}
else if( j4array[1] < -IKPI )
{    j4array[1]+=IK2PI;
}
j4valid[1] = true;
for(int ij4 = 0; ij4 < 2; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 2; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[1];
evalcond[0]=(((new_r12*(IKcos(j4))))+(((-1.0)*new_r02*(IKsin(j4)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x283=((1.0)*new_r00);
if( IKabs((((cj4*new_r01))+(((-1.0)*sj4*x283)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r01*sj4))+(((-1.0)*cj4*x283)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((cj4*new_r01))+(((-1.0)*sj4*x283))))+IKsqr(((((-1.0)*new_r01*sj4))+(((-1.0)*cj4*x283))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2((((cj4*new_r01))+(((-1.0)*sj4*x283))), ((((-1.0)*new_r01*sj4))+(((-1.0)*cj4*x283))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x284=IKcos(j6);
IkReal x285=IKsin(j6);
IkReal x286=((1.0)*sj4);
IkReal x287=((1.0)*x285);
IkReal x288=(sj4*x284);
IkReal x289=((1.0)*x284);
IkReal x290=(cj4*x287);
evalcond[0]=(((cj4*new_r00))+((new_r10*sj4))+x284);
evalcond[1]=(((cj4*new_r01))+((new_r11*sj4))+(((-1.0)*x287)));
evalcond[2]=(new_r00+((cj4*x284))+((sj4*x285)));
evalcond[3]=(((cj4*new_r10))+(((-1.0)*new_r00*x286))+(((-1.0)*x287)));
evalcond[4]=(((cj4*new_r11))+(((-1.0)*new_r01*x286))+(((-1.0)*x289)));
evalcond[5]=((((-1.0)*x290))+x288+new_r01);
evalcond[6]=((((-1.0)*x290))+x288+new_r10);
evalcond[7]=((((-1.0)*cj4*x289))+(((-1.0)*x285*x286))+new_r11);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j4, j6]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x292=IKPowWithIntegerCheck(sj5,-1);
if(!x292.valid){
continue;
}
IkReal x291=x292.value;
CheckValue<IkReal> x293=IKPowWithIntegerCheck(new_r12,-1);
if(!x293.valid){
continue;
}
if( IKabs((x291*(x293.value)*(((1.0)+(((-1.0)*(new_r02*new_r02)))+(((-1.0)*(cj5*cj5))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r02*x291)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x291*(x293.value)*(((1.0)+(((-1.0)*(new_r02*new_r02)))+(((-1.0)*(cj5*cj5)))))))+IKsqr((new_r02*x291))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2((x291*(x293.value)*(((1.0)+(((-1.0)*(new_r02*new_r02)))+(((-1.0)*(cj5*cj5)))))), (new_r02*x291));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x294=IKcos(j4);
IkReal x295=IKsin(j4);
IkReal x296=((1.0)*sj5);
IkReal x297=((1.0)*cj5);
IkReal x298=(new_r12*x295);
IkReal x299=(new_r02*x294);
evalcond[0]=(new_r02+(((-1.0)*x294*x296)));
evalcond[1]=((((-1.0)*x295*x296))+new_r12);
evalcond[2]=(((new_r12*x294))+(((-1.0)*new_r02*x295)));
evalcond[3]=((((-1.0)*x296))+x298+x299);
evalcond[4]=(((cj5*x299))+((cj5*x298))+(((-1.0)*new_r22*x296)));
evalcond[5]=((((-1.0)*new_r20*x297))+(((-1.0)*new_r00*x294*x296))+(((-1.0)*new_r10*x295*x296)));
evalcond[6]=((((-1.0)*new_r21*x297))+(((-1.0)*new_r11*x295*x296))+(((-1.0)*new_r01*x294*x296)));
evalcond[7]=((1.0)+(((-1.0)*x296*x298))+(((-1.0)*x296*x299))+(((-1.0)*new_r22*x297)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j6eval[2];
IkReal x300=(cj3*sj1);
IkReal x301=(sj0*sj2);
IkReal x302=((1.0)*sj3);
IkReal x303=(cj1*cj3);
IkReal x304=(cj0*sj2);
IkReal x305=((1.0)*cj1*sj2);
IkReal x306=x228;
IkReal x307=x229;
IkReal x308=x230;
IkReal x309=x231;
IkReal x310=x232;
IkReal x311=x233;
IkReal x312=(((cj3*x301))+((cj0*x308)));
IkReal x313=(((cj3*x304))+(((-1.0)*sj0*x308)));
IkReal x314=((((-1.0)*x301*x302))+((cj0*x311)));
IkReal x315=((((-1.0)*sj3*x304))+(((-1.0)*sj0*x311)));
new_r00=((((-1.0)*r20*x305))+((r10*x306))+((r00*x307)));
new_r01=(((r11*x306))+(((-1.0)*r21*x305))+((r01*x307)));
new_r02=((((-1.0)*r22*x305))+((r02*x307))+((r12*x306)));
new_r10=(((r20*x309))+((r00*x313))+((r10*x312)));
new_r11=(((r11*x312))+((r21*x309))+((r01*x313)));
new_r12=(((r22*x309))+((r02*x313))+((r12*x312)));
new_r20=(((r20*x310))+((r00*x315))+((r10*x314)));
new_r21=(((r11*x314))+((r01*x315))+((r21*x310)));
new_r22=(((r02*x315))+((r12*x314))+((r22*x310)));
j6eval[0]=sj5;
j6eval[1]=IKsign(sj5);
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  )
{
{
IkReal j6eval[2];
IkReal x316=(cj3*sj1);
IkReal x317=(sj0*sj2);
IkReal x318=((1.0)*sj3);
IkReal x319=(cj1*cj3);
IkReal x320=(cj0*sj2);
IkReal x321=((1.0)*cj1*sj2);
IkReal x322=x228;
IkReal x323=x229;
IkReal x324=x230;
IkReal x325=x231;
IkReal x326=x232;
IkReal x327=x233;
IkReal x328=(((cj0*x324))+((cj3*x317)));
IkReal x329=((((-1.0)*sj0*x324))+((cj3*x320)));
IkReal x330=(((cj0*x327))+(((-1.0)*x317*x318)));
IkReal x331=((((-1.0)*sj0*x327))+(((-1.0)*sj3*x320)));
new_r00=(((r00*x323))+((r10*x322))+(((-1.0)*r20*x321)));
new_r01=(((r11*x322))+((r01*x323))+(((-1.0)*r21*x321)));
new_r02=(((r02*x323))+((r12*x322))+(((-1.0)*r22*x321)));
new_r10=(((r20*x325))+((r00*x329))+((r10*x328)));
new_r11=(((r21*x325))+((r11*x328))+((r01*x329)));
new_r12=(((r02*x329))+((r12*x328))+((r22*x325)));
new_r20=(((r00*x331))+((r20*x326))+((r10*x330)));
new_r21=(((r01*x331))+((r11*x330))+((r21*x326)));
new_r22=(((r12*x330))+((r02*x331))+((r22*x326)));
j6eval[0]=sj4;
j6eval[1]=sj5;
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  )
{
{
IkReal j6eval[3];
IkReal x332=(cj3*sj1);
IkReal x333=(sj0*sj2);
IkReal x334=((1.0)*sj3);
IkReal x335=(cj1*cj3);
IkReal x336=(cj0*sj2);
IkReal x337=((1.0)*cj1*sj2);
IkReal x338=x228;
IkReal x339=x229;
IkReal x340=x230;
IkReal x341=x231;
IkReal x342=x232;
IkReal x343=x233;
IkReal x344=(((cj3*x333))+((cj0*x340)));
IkReal x345=(((cj3*x336))+(((-1.0)*sj0*x340)));
IkReal x346=((((-1.0)*x333*x334))+((cj0*x343)));
IkReal x347=((((-1.0)*sj0*x343))+(((-1.0)*sj3*x336)));
new_r00=(((r00*x339))+(((-1.0)*r20*x337))+((r10*x338)));
new_r01=(((r01*x339))+((r11*x338))+(((-1.0)*r21*x337)));
new_r02=(((r12*x338))+((r02*x339))+(((-1.0)*r22*x337)));
new_r10=(((r00*x345))+((r20*x341))+((r10*x344)));
new_r11=(((r01*x345))+((r21*x341))+((r11*x344)));
new_r12=(((r22*x341))+((r02*x345))+((r12*x344)));
new_r20=(((r00*x347))+((r20*x342))+((r10*x346)));
new_r21=(((r01*x347))+((r21*x342))+((r11*x346)));
new_r22=(((r22*x342))+((r02*x347))+((r12*x346)));
j6eval[0]=cj4;
j6eval[1]=cj5;
j6eval[2]=sj5;
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[12];
bool bgotonextstatement = true;
do
{
IkReal x348=(new_r22+(((-1.0)*cj5)));
IkReal x349=((((-1.0)*sj5))+new_r12);
IkReal x350=((1.0)*cj5);
IkReal x351=((1.0)*sj5);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j4)))), 6.28318530717959)));
evalcond[1]=x348;
evalcond[2]=x348;
evalcond[3]=new_r02;
evalcond[4]=x349;
evalcond[5]=x349;
evalcond[6]=((((-1.0)*new_r22*x351))+((cj5*new_r12)));
evalcond[7]=((((-1.0)*new_r10*x351))+(((-1.0)*new_r20*x350)));
evalcond[8]=((((-1.0)*new_r11*x351))+(((-1.0)*new_r21*x350)));
evalcond[9]=((1.0)+(((-1.0)*new_r22*x350))+(((-1.0)*new_r12*x351)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x352 = IKatan2WithCheck(IkReal(new_r21),((-1.0)*new_r20),IKFAST_ATAN2_MAGTHRESH);
if(!x352.valid){
continue;
}
CheckValue<IkReal> x353=IKPowWithIntegerCheck(IKsign(new_r12),-1);
if(!x353.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x352.value)+(((1.5707963267949)*(x353.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x354=IKsin(j6);
IkReal x355=IKcos(j6);
IkReal x356=((1.0)*new_r12);
IkReal x357=((1.0)*x355);
evalcond[0]=(new_r20+((new_r12*x355)));
evalcond[1]=(((new_r22*x354))+new_r11);
evalcond[2]=(new_r21+(((-1.0)*x354*x356)));
evalcond[3]=((((-1.0)*new_r22*x357))+new_r10);
evalcond[4]=((((-1.0)*x354))+(((-1.0)*new_r00)));
evalcond[5]=((((-1.0)*x357))+(((-1.0)*new_r01)));
evalcond[6]=(x354+((new_r11*new_r22))+(((-1.0)*new_r21*x356)));
evalcond[7]=((((-1.0)*x357))+((new_r10*new_r22))+(((-1.0)*new_r20*x356)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x358=(new_r22+(((-1.0)*cj5)));
IkReal x359=((1.0)*cj5);
IkReal x360=((1.0)*sj5);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j4)))), 6.28318530717959)));
evalcond[1]=x358;
evalcond[2]=x358;
evalcond[3]=new_r02;
evalcond[4]=(sj5+new_r12);
evalcond[5]=((((-1.0)*x360))+(((-1.0)*new_r12)));
evalcond[6]=((((-1.0)*new_r12*x359))+(((-1.0)*new_r22*x360)));
evalcond[7]=(((new_r10*sj5))+(((-1.0)*new_r20*x359)));
evalcond[8]=(((new_r11*sj5))+(((-1.0)*new_r21*x359)));
evalcond[9]=((1.0)+(((-1.0)*new_r22*x359))+((new_r12*sj5)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r00)+IKsqr(new_r01)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(new_r00, new_r01);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x361=IKsin(j6);
IkReal x362=IKcos(j6);
IkReal x363=((1.0)*new_r22);
IkReal x364=((1.0)*x362);
evalcond[0]=(new_r21+((new_r12*x361)));
evalcond[1]=((((-1.0)*x361))+new_r00);
evalcond[2]=((((-1.0)*x364))+new_r01);
evalcond[3]=((((-1.0)*new_r12*x364))+new_r20);
evalcond[4]=(((new_r22*x361))+(((-1.0)*new_r11)));
evalcond[5]=((((-1.0)*x362*x363))+(((-1.0)*new_r10)));
evalcond[6]=(x361+((new_r12*new_r21))+(((-1.0)*new_r11*x363)));
evalcond[7]=((((-1.0)*x364))+((new_r12*new_r20))+(((-1.0)*new_r10*x363)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x365=((1.0)*cj4);
IkReal x366=((1.0)*sj4);
IkReal x367=(((cj4*new_r12))+(((-1.0)*new_r02*x366)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j5)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=((((-1.0)*x365))+new_r02);
evalcond[3]=((((-1.0)*x366))+new_r12);
evalcond[4]=x367;
evalcond[5]=x367;
evalcond[6]=((-1.0)+((new_r12*sj4))+((cj4*new_r02)));
evalcond[7]=(((cj4*new_r01))+((new_r11*sj4)));
evalcond[8]=(((cj4*new_r00))+((new_r10*sj4)));
evalcond[9]=((((-1.0)*new_r00*x365))+(((-1.0)*new_r10*x366)));
evalcond[10]=((((-1.0)*new_r11*x366))+(((-1.0)*new_r01*x365)));
evalcond[11]=((1.0)+(((-1.0)*new_r12*x366))+(((-1.0)*new_r02*x365)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*new_r20))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(new_r21, ((-1.0)*new_r20));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x368=IKcos(j6);
IkReal x369=IKsin(j6);
IkReal x370=((1.0)*new_r12);
IkReal x371=((1.0)*x369);
IkReal x372=((1.0)*x368);
evalcond[0]=(x368+new_r20);
evalcond[1]=((((-1.0)*x371))+new_r21);
evalcond[2]=(new_r01+((new_r12*x368)));
evalcond[3]=(new_r00+((new_r12*x369)));
evalcond[4]=(new_r11+(((-1.0)*new_r02*x372)));
evalcond[5]=(new_r10+(((-1.0)*new_r02*x371)));
evalcond[6]=((((-1.0)*new_r00*x370))+(((-1.0)*x371))+((new_r02*new_r10)));
evalcond[7]=((((-1.0)*x372))+((new_r02*new_r11))+(((-1.0)*new_r01*x370)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x373=((((-1.0)*new_r02*sj4))+((cj4*new_r12)));
IkReal x374=(((cj4*new_r00))+((new_r10*sj4)));
IkReal x375=(((cj4*new_r01))+((new_r11*sj4)));
IkReal x376=((1.0)+((new_r12*sj4))+((cj4*new_r02)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j5)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=(cj4+new_r02);
evalcond[3]=(sj4+new_r12);
evalcond[4]=x373;
evalcond[5]=x373;
evalcond[6]=x376;
evalcond[7]=x375;
evalcond[8]=x374;
evalcond[9]=x374;
evalcond[10]=x375;
evalcond[11]=x376;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r21), new_r20);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x377=IKcos(j6);
IkReal x378=IKsin(j6);
IkReal x379=((1.0)*new_r02);
IkReal x380=((1.0)*new_r12);
IkReal x381=((1.0)*x377);
evalcond[0]=(x378+new_r21);
evalcond[1]=((((-1.0)*x381))+new_r20);
evalcond[2]=(new_r11+((new_r02*x377)));
evalcond[3]=(new_r10+((new_r02*x378)));
evalcond[4]=(new_r01+(((-1.0)*x377*x380)));
evalcond[5]=((((-1.0)*x378*x380))+new_r00);
evalcond[6]=((((-1.0)*x378))+((new_r00*new_r12))+(((-1.0)*new_r10*x379)));
evalcond[7]=(((new_r01*new_r12))+(((-1.0)*new_r11*x379))+(((-1.0)*x381)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x382=((((-1.0)*new_r02*sj4))+((cj4*new_r12)));
IkReal x383=(((new_r12*sj4))+((cj4*new_r02)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j5))), 6.28318530717959)));
evalcond[1]=((-1.0)+new_r22);
evalcond[2]=new_r20;
evalcond[3]=new_r02;
evalcond[4]=new_r12;
evalcond[5]=new_r21;
evalcond[6]=x382;
evalcond[7]=x382;
evalcond[8]=x383;
evalcond[9]=x383;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x384=((1.0)*new_r01);
if( IKabs(((((-1.0)*cj4*x384))+(((-1.0)*new_r00*sj4)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj4*new_r00))+(((-1.0)*sj4*x384)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj4*x384))+(((-1.0)*new_r00*sj4))))+IKsqr((((cj4*new_r00))+(((-1.0)*sj4*x384))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((((-1.0)*cj4*x384))+(((-1.0)*new_r00*sj4))), (((cj4*new_r00))+(((-1.0)*sj4*x384))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x385=IKsin(j6);
IkReal x386=IKcos(j6);
IkReal x387=((1.0)*sj4);
IkReal x388=((1.0)*x386);
IkReal x389=(sj4*x385);
IkReal x390=(sj4*x386);
IkReal x391=(cj4*x385);
IkReal x392=(cj4*x388);
evalcond[0]=(((cj4*new_r01))+((new_r11*sj4))+x385);
evalcond[1]=(x391+x390+new_r01);
evalcond[2]=(((cj4*new_r00))+((new_r10*sj4))+(((-1.0)*x388)));
evalcond[3]=(((cj4*new_r10))+(((-1.0)*new_r00*x387))+(((-1.0)*x385)));
evalcond[4]=(((cj4*new_r11))+(((-1.0)*new_r01*x387))+(((-1.0)*x388)));
evalcond[5]=((((-1.0)*x392))+x389+new_r00);
evalcond[6]=((((-1.0)*x392))+x389+new_r11);
evalcond[7]=((((-1.0)*x391))+(((-1.0)*x386*x387))+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x393=(cj4*new_r02);
IkReal x394=(new_r12*sj4);
IkReal x395=((((-1.0)*new_r02*sj4))+((cj4*new_r12)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j5)))), 6.28318530717959)));
evalcond[1]=((1.0)+new_r22);
evalcond[2]=new_r20;
evalcond[3]=new_r02;
evalcond[4]=new_r12;
evalcond[5]=new_r21;
evalcond[6]=x395;
evalcond[7]=x395;
evalcond[8]=(x394+x393);
evalcond[9]=((((-1.0)*x393))+(((-1.0)*x394)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x396=((1.0)*new_r00);
if( IKabs(((((-1.0)*sj4*x396))+((cj4*new_r01)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*cj4*x396))+(((-1.0)*new_r01*sj4)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*sj4*x396))+((cj4*new_r01))))+IKsqr(((((-1.0)*cj4*x396))+(((-1.0)*new_r01*sj4))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((((-1.0)*sj4*x396))+((cj4*new_r01))), ((((-1.0)*cj4*x396))+(((-1.0)*new_r01*sj4))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x397=IKcos(j6);
IkReal x398=IKsin(j6);
IkReal x399=((1.0)*sj4);
IkReal x400=((1.0)*x398);
IkReal x401=(sj4*x397);
IkReal x402=((1.0)*x397);
IkReal x403=(cj4*x400);
evalcond[0]=(((cj4*new_r00))+((new_r10*sj4))+x397);
evalcond[1]=(((cj4*new_r01))+((new_r11*sj4))+(((-1.0)*x400)));
evalcond[2]=(((cj4*x397))+new_r00+((sj4*x398)));
evalcond[3]=(((cj4*new_r10))+(((-1.0)*new_r00*x399))+(((-1.0)*x400)));
evalcond[4]=((((-1.0)*new_r01*x399))+((cj4*new_r11))+(((-1.0)*x402)));
evalcond[5]=(x401+new_r01+(((-1.0)*x403)));
evalcond[6]=(x401+new_r10+(((-1.0)*x403)));
evalcond[7]=((((-1.0)*x398*x399))+new_r11+(((-1.0)*cj4*x402)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x404=(new_r22+(((-1.0)*cj5)));
IkReal x405=((((-1.0)*sj5))+new_r02);
IkReal x406=((1.0)*cj5);
IkReal x407=((1.0)*sj5);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j4))), 6.28318530717959)));
evalcond[1]=x404;
evalcond[2]=x404;
evalcond[3]=x405;
evalcond[4]=new_r12;
evalcond[5]=x405;
evalcond[6]=(((cj5*new_r02))+(((-1.0)*new_r22*x407)));
evalcond[7]=((((-1.0)*new_r20*x406))+(((-1.0)*new_r00*x407)));
evalcond[8]=((((-1.0)*new_r21*x406))+(((-1.0)*new_r01*x407)));
evalcond[9]=((1.0)+(((-1.0)*new_r02*x407))+(((-1.0)*new_r22*x406)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r10)+IKsqr(new_r11)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(new_r10, new_r11);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x408=IKcos(j6);
IkReal x409=IKsin(j6);
IkReal x410=((1.0)*new_r02);
IkReal x411=((1.0)*x408);
evalcond[0]=(new_r20+((new_r02*x408)));
evalcond[1]=(new_r10+(((-1.0)*x409)));
evalcond[2]=(new_r11+(((-1.0)*x411)));
evalcond[3]=(((new_r22*x409))+new_r01);
evalcond[4]=(new_r21+(((-1.0)*x409*x410)));
evalcond[5]=(new_r00+(((-1.0)*new_r22*x411)));
evalcond[6]=(((new_r01*new_r22))+x409+(((-1.0)*new_r21*x410)));
evalcond[7]=(((new_r00*new_r22))+(((-1.0)*new_r20*x410))+(((-1.0)*x411)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x412=(new_r22+(((-1.0)*cj5)));
IkReal x413=((1.0)*cj5);
IkReal x414=((1.0)*sj5);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j4)))), 6.28318530717959)));
evalcond[1]=x412;
evalcond[2]=x412;
evalcond[3]=(sj5+new_r02);
evalcond[4]=new_r12;
evalcond[5]=((((-1.0)*new_r02))+(((-1.0)*x414)));
evalcond[6]=((((-1.0)*new_r02*x413))+(((-1.0)*new_r22*x414)));
evalcond[7]=(((new_r00*sj5))+(((-1.0)*new_r20*x413)));
evalcond[8]=(((new_r01*sj5))+(((-1.0)*new_r21*x413)));
evalcond[9]=((1.0)+((new_r02*sj5))+(((-1.0)*new_r22*x413)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x415 = IKatan2WithCheck(IkReal(((-1.0)*new_r21)),new_r20,IKFAST_ATAN2_MAGTHRESH);
if(!x415.valid){
continue;
}
CheckValue<IkReal> x416=IKPowWithIntegerCheck(IKsign(new_r02),-1);
if(!x416.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x415.value)+(((1.5707963267949)*(x416.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x417=IKsin(j6);
IkReal x418=IKcos(j6);
IkReal x419=((1.0)*new_r01);
IkReal x420=((1.0)*new_r00);
IkReal x421=((1.0)*x418);
evalcond[0]=(new_r21+((new_r02*x417)));
evalcond[1]=((((-1.0)*new_r02*x421))+new_r20);
evalcond[2]=((((-1.0)*new_r10))+(((-1.0)*x417)));
evalcond[3]=((((-1.0)*x421))+(((-1.0)*new_r11)));
evalcond[4]=(((new_r22*x417))+(((-1.0)*x419)));
evalcond[5]=((((-1.0)*new_r22*x421))+(((-1.0)*x420)));
evalcond[6]=(x417+((new_r02*new_r21))+(((-1.0)*new_r22*x419)));
evalcond[7]=((((-1.0)*new_r22*x420))+(((-1.0)*x421))+((new_r02*new_r20)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j6]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x423=IKPowWithIntegerCheck(sj5,-1);
if(!x423.valid){
continue;
}
IkReal x422=x423.value;
CheckValue<IkReal> x424=IKPowWithIntegerCheck(cj4,-1);
if(!x424.valid){
continue;
}
CheckValue<IkReal> x425=IKPowWithIntegerCheck(cj5,-1);
if(!x425.valid){
continue;
}
if( IKabs((x422*(x424.value)*(x425.value)*((((new_r20*sj4))+(((-1.0)*new_r01*sj5)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*x422)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x422*(x424.value)*(x425.value)*((((new_r20*sj4))+(((-1.0)*new_r01*sj5))))))+IKsqr(((-1.0)*new_r20*x422))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2((x422*(x424.value)*(x425.value)*((((new_r20*sj4))+(((-1.0)*new_r01*sj5))))), ((-1.0)*new_r20*x422));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[12];
IkReal x426=IKsin(j6);
IkReal x427=IKcos(j6);
IkReal x428=((1.0)*sj5);
IkReal x429=((1.0)*sj4);
IkReal x430=(cj5*sj4);
IkReal x431=(cj4*new_r01);
IkReal x432=(cj4*new_r00);
IkReal x433=((1.0)*x427);
IkReal x434=(cj5*x426);
IkReal x435=((1.0)*x426);
evalcond[0]=(((sj5*x427))+new_r20);
evalcond[1]=((((-1.0)*x426*x428))+new_r21);
evalcond[2]=(((new_r11*sj4))+x431+x434);
evalcond[3]=((((-1.0)*x435))+(((-1.0)*new_r00*x429))+((cj4*new_r10)));
evalcond[4]=((((-1.0)*x433))+((cj4*new_r11))+(((-1.0)*new_r01*x429)));
evalcond[5]=(((sj4*x427))+((cj4*x434))+new_r01);
evalcond[6]=(((new_r10*sj4))+(((-1.0)*cj5*x433))+x432);
evalcond[7]=(((sj4*x426))+new_r00+(((-1.0)*cj4*cj5*x433)));
evalcond[8]=(((x426*x430))+(((-1.0)*cj4*x433))+new_r11);
evalcond[9]=((((-1.0)*cj5*x427*x429))+(((-1.0)*cj4*x435))+new_r10);
evalcond[10]=(((cj5*x431))+((new_r11*x430))+x426+(((-1.0)*new_r21*x428)));
evalcond[11]=((((-1.0)*x433))+((cj5*x432))+((new_r10*x430))+(((-1.0)*new_r20*x428)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x437=IKPowWithIntegerCheck(sj5,-1);
if(!x437.valid){
continue;
}
IkReal x436=x437.value;
CheckValue<IkReal> x438=IKPowWithIntegerCheck(sj4,-1);
if(!x438.valid){
continue;
}
if( IKabs((x436*(x438.value)*(((((-1.0)*new_r00*sj5))+(((-1.0)*cj4*cj5*new_r20)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*x436)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x436*(x438.value)*(((((-1.0)*new_r00*sj5))+(((-1.0)*cj4*cj5*new_r20))))))+IKsqr(((-1.0)*new_r20*x436))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2((x436*(x438.value)*(((((-1.0)*new_r00*sj5))+(((-1.0)*cj4*cj5*new_r20))))), ((-1.0)*new_r20*x436));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[12];
IkReal x439=IKsin(j6);
IkReal x440=IKcos(j6);
IkReal x441=((1.0)*sj5);
IkReal x442=((1.0)*sj4);
IkReal x443=(cj5*sj4);
IkReal x444=(cj4*new_r01);
IkReal x445=(cj4*new_r00);
IkReal x446=((1.0)*x440);
IkReal x447=(cj5*x439);
IkReal x448=((1.0)*x439);
evalcond[0]=(((sj5*x440))+new_r20);
evalcond[1]=((((-1.0)*x439*x441))+new_r21);
evalcond[2]=(((new_r11*sj4))+x444+x447);
evalcond[3]=((((-1.0)*x448))+(((-1.0)*new_r00*x442))+((cj4*new_r10)));
evalcond[4]=((((-1.0)*x446))+(((-1.0)*new_r01*x442))+((cj4*new_r11)));
evalcond[5]=(((sj4*x440))+((cj4*x447))+new_r01);
evalcond[6]=(((new_r10*sj4))+(((-1.0)*cj5*x446))+x445);
evalcond[7]=(((sj4*x439))+(((-1.0)*cj4*cj5*x446))+new_r00);
evalcond[8]=(((x439*x443))+(((-1.0)*cj4*x446))+new_r11);
evalcond[9]=((((-1.0)*cj4*x448))+(((-1.0)*cj5*x440*x442))+new_r10);
evalcond[10]=(((cj5*x444))+((new_r11*x443))+x439+(((-1.0)*new_r21*x441)));
evalcond[11]=((((-1.0)*x446))+((cj5*x445))+((new_r10*x443))+(((-1.0)*new_r20*x441)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x449=IKPowWithIntegerCheck(IKsign(sj5),-1);
if(!x449.valid){
continue;
}
CheckValue<IkReal> x450 = IKatan2WithCheck(IkReal(new_r21),((-1.0)*new_r20),IKFAST_ATAN2_MAGTHRESH);
if(!x450.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(((1.5707963267949)*(x449.value)))+(x450.value));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[12];
IkReal x451=IKsin(j6);
IkReal x452=IKcos(j6);
IkReal x453=((1.0)*sj5);
IkReal x454=((1.0)*sj4);
IkReal x455=(cj5*sj4);
IkReal x456=(cj4*new_r01);
IkReal x457=(cj4*new_r00);
IkReal x458=((1.0)*x452);
IkReal x459=(cj5*x451);
IkReal x460=((1.0)*x451);
evalcond[0]=(new_r20+((sj5*x452)));
evalcond[1]=((((-1.0)*x451*x453))+new_r21);
evalcond[2]=(((new_r11*sj4))+x459+x456);
evalcond[3]=(((cj4*new_r10))+(((-1.0)*x460))+(((-1.0)*new_r00*x454)));
evalcond[4]=(((cj4*new_r11))+(((-1.0)*new_r01*x454))+(((-1.0)*x458)));
evalcond[5]=(((cj4*x459))+((sj4*x452))+new_r01);
evalcond[6]=(((new_r10*sj4))+(((-1.0)*cj5*x458))+x457);
evalcond[7]=((((-1.0)*cj4*cj5*x458))+((sj4*x451))+new_r00);
evalcond[8]=((((-1.0)*cj4*x458))+new_r11+((x451*x455)));
evalcond[9]=((((-1.0)*cj4*x460))+new_r10+(((-1.0)*cj5*x452*x454)));
evalcond[10]=((((-1.0)*new_r21*x453))+((cj5*x456))+((new_r11*x455))+x451);
evalcond[11]=(((cj5*x457))+((new_r10*x455))+(((-1.0)*new_r20*x453))+(((-1.0)*x458)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x461=IKPowWithIntegerCheck(IKsign(sj5),-1);
if(!x461.valid){
continue;
}
CheckValue<IkReal> x462 = IKatan2WithCheck(IkReal(new_r12),new_r02,IKFAST_ATAN2_MAGTHRESH);
if(!x462.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(((1.5707963267949)*(x461.value)))+(x462.value));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x463=IKcos(j4);
IkReal x464=IKsin(j4);
IkReal x465=((1.0)*sj5);
IkReal x466=((1.0)*cj5);
IkReal x467=(new_r12*x464);
IkReal x468=(new_r02*x463);
evalcond[0]=((((-1.0)*x463*x465))+new_r02);
evalcond[1]=((((-1.0)*x464*x465))+new_r12);
evalcond[2]=(((new_r12*x463))+(((-1.0)*new_r02*x464)));
evalcond[3]=((((-1.0)*x465))+x468+x467);
evalcond[4]=(((cj5*x467))+((cj5*x468))+(((-1.0)*new_r22*x465)));
evalcond[5]=((((-1.0)*new_r00*x463*x465))+(((-1.0)*new_r20*x466))+(((-1.0)*new_r10*x464*x465)));
evalcond[6]=((((-1.0)*new_r21*x466))+(((-1.0)*new_r01*x463*x465))+(((-1.0)*new_r11*x464*x465)));
evalcond[7]=((1.0)+(((-1.0)*x465*x468))+(((-1.0)*x465*x467))+(((-1.0)*new_r22*x466)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j6eval[2];
IkReal x469=(cj3*sj1);
IkReal x470=(sj0*sj2);
IkReal x471=((1.0)*sj3);
IkReal x472=(cj1*cj3);
IkReal x473=(cj0*sj2);
IkReal x474=((1.0)*cj1*sj2);
IkReal x475=x228;
IkReal x476=x229;
IkReal x477=x230;
IkReal x478=x231;
IkReal x479=x232;
IkReal x480=x233;
IkReal x481=(((cj3*x470))+((cj0*x477)));
IkReal x482=(((cj3*x473))+(((-1.0)*sj0*x477)));
IkReal x483=(((cj0*x480))+(((-1.0)*x470*x471)));
IkReal x484=((((-1.0)*sj0*x480))+(((-1.0)*sj3*x473)));
new_r00=(((r10*x475))+(((-1.0)*r20*x474))+((r00*x476)));
new_r01=((((-1.0)*r21*x474))+((r11*x475))+((r01*x476)));
new_r02=(((r02*x476))+(((-1.0)*r22*x474))+((r12*x475)));
new_r10=(((r20*x478))+((r10*x481))+((r00*x482)));
new_r11=(((r21*x478))+((r11*x481))+((r01*x482)));
new_r12=(((r02*x482))+((r12*x481))+((r22*x478)));
new_r20=(((r20*x479))+((r10*x483))+((r00*x484)));
new_r21=(((r21*x479))+((r11*x483))+((r01*x484)));
new_r22=(((r02*x484))+((r12*x483))+((r22*x479)));
j6eval[0]=sj5;
j6eval[1]=IKsign(sj5);
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  )
{
{
IkReal j6eval[2];
IkReal x485=(cj3*sj1);
IkReal x486=(sj0*sj2);
IkReal x487=((1.0)*sj3);
IkReal x488=(cj1*cj3);
IkReal x489=(cj0*sj2);
IkReal x490=((1.0)*cj1*sj2);
IkReal x491=x228;
IkReal x492=x229;
IkReal x493=x230;
IkReal x494=x231;
IkReal x495=x232;
IkReal x496=x233;
IkReal x497=(((cj3*x486))+((cj0*x493)));
IkReal x498=(((cj3*x489))+(((-1.0)*sj0*x493)));
IkReal x499=((((-1.0)*x486*x487))+((cj0*x496)));
IkReal x500=((((-1.0)*sj3*x489))+(((-1.0)*sj0*x496)));
new_r00=(((r10*x491))+((r00*x492))+(((-1.0)*r20*x490)));
new_r01=((((-1.0)*r21*x490))+((r11*x491))+((r01*x492)));
new_r02=(((r02*x492))+((r12*x491))+(((-1.0)*r22*x490)));
new_r10=(((r10*x497))+((r00*x498))+((r20*x494)));
new_r11=(((r11*x497))+((r21*x494))+((r01*x498)));
new_r12=(((r02*x498))+((r22*x494))+((r12*x497)));
new_r20=(((r00*x500))+((r10*x499))+((r20*x495)));
new_r21=(((r11*x499))+((r01*x500))+((r21*x495)));
new_r22=(((r22*x495))+((r12*x499))+((r02*x500)));
j6eval[0]=sj4;
j6eval[1]=sj5;
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  )
{
{
IkReal j6eval[3];
IkReal x501=(cj3*sj1);
IkReal x502=(sj0*sj2);
IkReal x503=((1.0)*sj3);
IkReal x504=(cj1*cj3);
IkReal x505=(cj0*sj2);
IkReal x506=((1.0)*cj1*sj2);
IkReal x507=x228;
IkReal x508=x229;
IkReal x509=x230;
IkReal x510=x231;
IkReal x511=x232;
IkReal x512=x233;
IkReal x513=(((cj3*x502))+((cj0*x509)));
IkReal x514=(((cj3*x505))+(((-1.0)*sj0*x509)));
IkReal x515=(((cj0*x512))+(((-1.0)*x502*x503)));
IkReal x516=((((-1.0)*sj3*x505))+(((-1.0)*sj0*x512)));
new_r00=((((-1.0)*r20*x506))+((r10*x507))+((r00*x508)));
new_r01=(((r01*x508))+((r11*x507))+(((-1.0)*r21*x506)));
new_r02=((((-1.0)*r22*x506))+((r12*x507))+((r02*x508)));
new_r10=(((r20*x510))+((r10*x513))+((r00*x514)));
new_r11=(((r01*x514))+((r11*x513))+((r21*x510)));
new_r12=(((r02*x514))+((r22*x510))+((r12*x513)));
new_r20=(((r20*x511))+((r10*x515))+((r00*x516)));
new_r21=(((r01*x516))+((r11*x515))+((r21*x511)));
new_r22=(((r02*x516))+((r22*x511))+((r12*x515)));
j6eval[0]=cj4;
j6eval[1]=cj5;
j6eval[2]=sj5;
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[12];
bool bgotonextstatement = true;
do
{
IkReal x517=(new_r22+(((-1.0)*cj5)));
IkReal x518=((((-1.0)*sj5))+new_r12);
IkReal x519=((1.0)*cj5);
IkReal x520=((1.0)*sj5);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j4)))), 6.28318530717959)));
evalcond[1]=x517;
evalcond[2]=x517;
evalcond[3]=new_r02;
evalcond[4]=x518;
evalcond[5]=x518;
evalcond[6]=((((-1.0)*new_r22*x520))+((cj5*new_r12)));
evalcond[7]=((((-1.0)*new_r10*x520))+(((-1.0)*new_r20*x519)));
evalcond[8]=((((-1.0)*new_r11*x520))+(((-1.0)*new_r21*x519)));
evalcond[9]=((1.0)+(((-1.0)*new_r12*x520))+(((-1.0)*new_r22*x519)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x521 = IKatan2WithCheck(IkReal(new_r21),((-1.0)*new_r20),IKFAST_ATAN2_MAGTHRESH);
if(!x521.valid){
continue;
}
CheckValue<IkReal> x522=IKPowWithIntegerCheck(IKsign(new_r12),-1);
if(!x522.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x521.value)+(((1.5707963267949)*(x522.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x523=IKsin(j6);
IkReal x524=IKcos(j6);
IkReal x525=((1.0)*new_r12);
IkReal x526=((1.0)*x524);
evalcond[0]=(((new_r12*x524))+new_r20);
evalcond[1]=(new_r11+((new_r22*x523)));
evalcond[2]=((((-1.0)*x523*x525))+new_r21);
evalcond[3]=((((-1.0)*new_r22*x526))+new_r10);
evalcond[4]=((((-1.0)*x523))+(((-1.0)*new_r00)));
evalcond[5]=((((-1.0)*x526))+(((-1.0)*new_r01)));
evalcond[6]=((((-1.0)*new_r21*x525))+x523+((new_r11*new_r22)));
evalcond[7]=((((-1.0)*new_r20*x525))+(((-1.0)*x526))+((new_r10*new_r22)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x527=(new_r22+(((-1.0)*cj5)));
IkReal x528=((1.0)*cj5);
IkReal x529=((1.0)*sj5);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j4)))), 6.28318530717959)));
evalcond[1]=x527;
evalcond[2]=x527;
evalcond[3]=new_r02;
evalcond[4]=(sj5+new_r12);
evalcond[5]=((((-1.0)*x529))+(((-1.0)*new_r12)));
evalcond[6]=((((-1.0)*new_r22*x529))+(((-1.0)*new_r12*x528)));
evalcond[7]=(((new_r10*sj5))+(((-1.0)*new_r20*x528)));
evalcond[8]=(((new_r11*sj5))+(((-1.0)*new_r21*x528)));
evalcond[9]=((1.0)+(((-1.0)*new_r22*x528))+((new_r12*sj5)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r00)+IKsqr(new_r01)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(new_r00, new_r01);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x530=IKsin(j6);
IkReal x531=IKcos(j6);
IkReal x532=((1.0)*new_r22);
IkReal x533=((1.0)*x531);
evalcond[0]=(((new_r12*x530))+new_r21);
evalcond[1]=((((-1.0)*x530))+new_r00);
evalcond[2]=((((-1.0)*x533))+new_r01);
evalcond[3]=((((-1.0)*new_r12*x533))+new_r20);
evalcond[4]=((((-1.0)*new_r11))+((new_r22*x530)));
evalcond[5]=((((-1.0)*x531*x532))+(((-1.0)*new_r10)));
evalcond[6]=((((-1.0)*new_r11*x532))+((new_r12*new_r21))+x530);
evalcond[7]=((((-1.0)*x533))+(((-1.0)*new_r10*x532))+((new_r12*new_r20)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x534=((1.0)*cj4);
IkReal x535=((1.0)*sj4);
IkReal x536=(((cj4*new_r12))+(((-1.0)*new_r02*x535)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j5)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=((((-1.0)*x534))+new_r02);
evalcond[3]=((((-1.0)*x535))+new_r12);
evalcond[4]=x536;
evalcond[5]=x536;
evalcond[6]=((-1.0)+((new_r12*sj4))+((cj4*new_r02)));
evalcond[7]=(((cj4*new_r01))+((new_r11*sj4)));
evalcond[8]=(((cj4*new_r00))+((new_r10*sj4)));
evalcond[9]=((((-1.0)*new_r00*x534))+(((-1.0)*new_r10*x535)));
evalcond[10]=((((-1.0)*new_r11*x535))+(((-1.0)*new_r01*x534)));
evalcond[11]=((1.0)+(((-1.0)*new_r12*x535))+(((-1.0)*new_r02*x534)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*new_r20))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(new_r21, ((-1.0)*new_r20));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x537=IKcos(j6);
IkReal x538=IKsin(j6);
IkReal x539=((1.0)*new_r12);
IkReal x540=((1.0)*x538);
IkReal x541=((1.0)*x537);
evalcond[0]=(x537+new_r20);
evalcond[1]=((((-1.0)*x540))+new_r21);
evalcond[2]=(((new_r12*x537))+new_r01);
evalcond[3]=(((new_r12*x538))+new_r00);
evalcond[4]=(new_r11+(((-1.0)*new_r02*x541)));
evalcond[5]=(new_r10+(((-1.0)*new_r02*x540)));
evalcond[6]=((((-1.0)*new_r00*x539))+(((-1.0)*x540))+((new_r02*new_r10)));
evalcond[7]=((((-1.0)*x541))+(((-1.0)*new_r01*x539))+((new_r02*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x542=((((-1.0)*new_r02*sj4))+((cj4*new_r12)));
IkReal x543=(((cj4*new_r00))+((new_r10*sj4)));
IkReal x544=(((cj4*new_r01))+((new_r11*sj4)));
IkReal x545=((1.0)+((new_r12*sj4))+((cj4*new_r02)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j5)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=(cj4+new_r02);
evalcond[3]=(sj4+new_r12);
evalcond[4]=x542;
evalcond[5]=x542;
evalcond[6]=x545;
evalcond[7]=x544;
evalcond[8]=x543;
evalcond[9]=x543;
evalcond[10]=x544;
evalcond[11]=x545;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r21), new_r20);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x546=IKcos(j6);
IkReal x547=IKsin(j6);
IkReal x548=((1.0)*new_r02);
IkReal x549=((1.0)*new_r12);
IkReal x550=((1.0)*x546);
evalcond[0]=(x547+new_r21);
evalcond[1]=((((-1.0)*x550))+new_r20);
evalcond[2]=(((new_r02*x546))+new_r11);
evalcond[3]=(((new_r02*x547))+new_r10);
evalcond[4]=(new_r01+(((-1.0)*x546*x549)));
evalcond[5]=((((-1.0)*x547*x549))+new_r00);
evalcond[6]=((((-1.0)*x547))+((new_r00*new_r12))+(((-1.0)*new_r10*x548)));
evalcond[7]=(((new_r01*new_r12))+(((-1.0)*new_r11*x548))+(((-1.0)*x550)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x551=((((-1.0)*new_r02*sj4))+((cj4*new_r12)));
IkReal x552=(((new_r12*sj4))+((cj4*new_r02)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j5))), 6.28318530717959)));
evalcond[1]=((-1.0)+new_r22);
evalcond[2]=new_r20;
evalcond[3]=new_r02;
evalcond[4]=new_r12;
evalcond[5]=new_r21;
evalcond[6]=x551;
evalcond[7]=x551;
evalcond[8]=x552;
evalcond[9]=x552;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x553=((1.0)*new_r01);
if( IKabs(((((-1.0)*new_r00*sj4))+(((-1.0)*cj4*x553)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj4*new_r00))+(((-1.0)*sj4*x553)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r00*sj4))+(((-1.0)*cj4*x553))))+IKsqr((((cj4*new_r00))+(((-1.0)*sj4*x553))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((((-1.0)*new_r00*sj4))+(((-1.0)*cj4*x553))), (((cj4*new_r00))+(((-1.0)*sj4*x553))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x554=IKsin(j6);
IkReal x555=IKcos(j6);
IkReal x556=((1.0)*sj4);
IkReal x557=((1.0)*x555);
IkReal x558=(sj4*x554);
IkReal x559=(sj4*x555);
IkReal x560=(cj4*x554);
IkReal x561=(cj4*x557);
evalcond[0]=(((cj4*new_r01))+((new_r11*sj4))+x554);
evalcond[1]=(x559+x560+new_r01);
evalcond[2]=(((cj4*new_r00))+((new_r10*sj4))+(((-1.0)*x557)));
evalcond[3]=((((-1.0)*x554))+((cj4*new_r10))+(((-1.0)*new_r00*x556)));
evalcond[4]=(((cj4*new_r11))+(((-1.0)*new_r01*x556))+(((-1.0)*x557)));
evalcond[5]=(x558+new_r00+(((-1.0)*x561)));
evalcond[6]=(x558+new_r11+(((-1.0)*x561)));
evalcond[7]=((((-1.0)*x555*x556))+(((-1.0)*x560))+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x562=(cj4*new_r02);
IkReal x563=(new_r12*sj4);
IkReal x564=((((-1.0)*new_r02*sj4))+((cj4*new_r12)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j5)))), 6.28318530717959)));
evalcond[1]=((1.0)+new_r22);
evalcond[2]=new_r20;
evalcond[3]=new_r02;
evalcond[4]=new_r12;
evalcond[5]=new_r21;
evalcond[6]=x564;
evalcond[7]=x564;
evalcond[8]=(x562+x563);
evalcond[9]=((((-1.0)*x563))+(((-1.0)*x562)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x565=((1.0)*new_r00);
if( IKabs(((((-1.0)*sj4*x565))+((cj4*new_r01)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r01*sj4))+(((-1.0)*cj4*x565)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*sj4*x565))+((cj4*new_r01))))+IKsqr(((((-1.0)*new_r01*sj4))+(((-1.0)*cj4*x565))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((((-1.0)*sj4*x565))+((cj4*new_r01))), ((((-1.0)*new_r01*sj4))+(((-1.0)*cj4*x565))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x566=IKcos(j6);
IkReal x567=IKsin(j6);
IkReal x568=((1.0)*sj4);
IkReal x569=((1.0)*x567);
IkReal x570=(sj4*x566);
IkReal x571=((1.0)*x566);
IkReal x572=(cj4*x569);
evalcond[0]=(((cj4*new_r00))+((new_r10*sj4))+x566);
evalcond[1]=(((cj4*new_r01))+((new_r11*sj4))+(((-1.0)*x569)));
evalcond[2]=(((sj4*x567))+new_r00+((cj4*x566)));
evalcond[3]=((((-1.0)*new_r00*x568))+((cj4*new_r10))+(((-1.0)*x569)));
evalcond[4]=(((cj4*new_r11))+(((-1.0)*x571))+(((-1.0)*new_r01*x568)));
evalcond[5]=((((-1.0)*x572))+x570+new_r01);
evalcond[6]=((((-1.0)*x572))+x570+new_r10);
evalcond[7]=((((-1.0)*cj4*x571))+(((-1.0)*x567*x568))+new_r11);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x573=(new_r22+(((-1.0)*cj5)));
IkReal x574=((((-1.0)*sj5))+new_r02);
IkReal x575=((1.0)*cj5);
IkReal x576=((1.0)*sj5);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j4))), 6.28318530717959)));
evalcond[1]=x573;
evalcond[2]=x573;
evalcond[3]=x574;
evalcond[4]=new_r12;
evalcond[5]=x574;
evalcond[6]=((((-1.0)*new_r22*x576))+((cj5*new_r02)));
evalcond[7]=((((-1.0)*new_r20*x575))+(((-1.0)*new_r00*x576)));
evalcond[8]=((((-1.0)*new_r21*x575))+(((-1.0)*new_r01*x576)));
evalcond[9]=((1.0)+(((-1.0)*new_r22*x575))+(((-1.0)*new_r02*x576)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r10)+IKsqr(new_r11)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(new_r10, new_r11);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x577=IKcos(j6);
IkReal x578=IKsin(j6);
IkReal x579=((1.0)*new_r02);
IkReal x580=((1.0)*x577);
evalcond[0]=(new_r20+((new_r02*x577)));
evalcond[1]=((((-1.0)*x578))+new_r10);
evalcond[2]=(new_r11+(((-1.0)*x580)));
evalcond[3]=(((new_r22*x578))+new_r01);
evalcond[4]=((((-1.0)*x578*x579))+new_r21);
evalcond[5]=((((-1.0)*new_r22*x580))+new_r00);
evalcond[6]=(((new_r01*new_r22))+x578+(((-1.0)*new_r21*x579)));
evalcond[7]=(((new_r00*new_r22))+(((-1.0)*new_r20*x579))+(((-1.0)*x580)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x581=(new_r22+(((-1.0)*cj5)));
IkReal x582=((1.0)*cj5);
IkReal x583=((1.0)*sj5);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j4)))), 6.28318530717959)));
evalcond[1]=x581;
evalcond[2]=x581;
evalcond[3]=(sj5+new_r02);
evalcond[4]=new_r12;
evalcond[5]=((((-1.0)*new_r02))+(((-1.0)*x583)));
evalcond[6]=((((-1.0)*new_r22*x583))+(((-1.0)*new_r02*x582)));
evalcond[7]=(((new_r00*sj5))+(((-1.0)*new_r20*x582)));
evalcond[8]=(((new_r01*sj5))+(((-1.0)*new_r21*x582)));
evalcond[9]=((1.0)+((new_r02*sj5))+(((-1.0)*new_r22*x582)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x584 = IKatan2WithCheck(IkReal(((-1.0)*new_r21)),new_r20,IKFAST_ATAN2_MAGTHRESH);
if(!x584.valid){
continue;
}
CheckValue<IkReal> x585=IKPowWithIntegerCheck(IKsign(new_r02),-1);
if(!x585.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x584.value)+(((1.5707963267949)*(x585.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x586=IKsin(j6);
IkReal x587=IKcos(j6);
IkReal x588=((1.0)*new_r01);
IkReal x589=((1.0)*new_r00);
IkReal x590=((1.0)*x587);
evalcond[0]=(((new_r02*x586))+new_r21);
evalcond[1]=((((-1.0)*new_r02*x590))+new_r20);
evalcond[2]=((((-1.0)*x586))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*x590))+(((-1.0)*new_r11)));
evalcond[4]=(((new_r22*x586))+(((-1.0)*x588)));
evalcond[5]=((((-1.0)*new_r22*x590))+(((-1.0)*x589)));
evalcond[6]=((((-1.0)*new_r22*x588))+x586+((new_r02*new_r21)));
evalcond[7]=((((-1.0)*new_r22*x589))+(((-1.0)*x590))+((new_r02*new_r20)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j6]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x592=IKPowWithIntegerCheck(sj5,-1);
if(!x592.valid){
continue;
}
IkReal x591=x592.value;
CheckValue<IkReal> x593=IKPowWithIntegerCheck(cj4,-1);
if(!x593.valid){
continue;
}
CheckValue<IkReal> x594=IKPowWithIntegerCheck(cj5,-1);
if(!x594.valid){
continue;
}
if( IKabs((x591*(x593.value)*(x594.value)*((((new_r20*sj4))+(((-1.0)*new_r01*sj5)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*x591)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x591*(x593.value)*(x594.value)*((((new_r20*sj4))+(((-1.0)*new_r01*sj5))))))+IKsqr(((-1.0)*new_r20*x591))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2((x591*(x593.value)*(x594.value)*((((new_r20*sj4))+(((-1.0)*new_r01*sj5))))), ((-1.0)*new_r20*x591));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[12];
IkReal x595=IKsin(j6);
IkReal x596=IKcos(j6);
IkReal x597=((1.0)*sj5);
IkReal x598=((1.0)*sj4);
IkReal x599=(cj5*sj4);
IkReal x600=(cj4*new_r01);
IkReal x601=(cj4*new_r00);
IkReal x602=((1.0)*x596);
IkReal x603=(cj5*x595);
IkReal x604=((1.0)*x595);
evalcond[0]=(new_r20+((sj5*x596)));
evalcond[1]=((((-1.0)*x595*x597))+new_r21);
evalcond[2]=(((new_r11*sj4))+x603+x600);
evalcond[3]=((((-1.0)*new_r00*x598))+((cj4*new_r10))+(((-1.0)*x604)));
evalcond[4]=(((cj4*new_r11))+(((-1.0)*new_r01*x598))+(((-1.0)*x602)));
evalcond[5]=(((sj4*x596))+new_r01+((cj4*x603)));
evalcond[6]=(((new_r10*sj4))+x601+(((-1.0)*cj5*x602)));
evalcond[7]=(((sj4*x595))+new_r00+(((-1.0)*cj4*cj5*x602)));
evalcond[8]=(((x595*x599))+(((-1.0)*cj4*x602))+new_r11);
evalcond[9]=((((-1.0)*cj5*x596*x598))+(((-1.0)*cj4*x604))+new_r10);
evalcond[10]=(((cj5*x600))+(((-1.0)*new_r21*x597))+((new_r11*x599))+x595);
evalcond[11]=(((cj5*x601))+(((-1.0)*new_r20*x597))+((new_r10*x599))+(((-1.0)*x602)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x606=IKPowWithIntegerCheck(sj5,-1);
if(!x606.valid){
continue;
}
IkReal x605=x606.value;
CheckValue<IkReal> x607=IKPowWithIntegerCheck(sj4,-1);
if(!x607.valid){
continue;
}
if( IKabs((x605*(x607.value)*(((((-1.0)*new_r00*sj5))+(((-1.0)*cj4*cj5*new_r20)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*x605)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x605*(x607.value)*(((((-1.0)*new_r00*sj5))+(((-1.0)*cj4*cj5*new_r20))))))+IKsqr(((-1.0)*new_r20*x605))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2((x605*(x607.value)*(((((-1.0)*new_r00*sj5))+(((-1.0)*cj4*cj5*new_r20))))), ((-1.0)*new_r20*x605));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[12];
IkReal x608=IKsin(j6);
IkReal x609=IKcos(j6);
IkReal x610=((1.0)*sj5);
IkReal x611=((1.0)*sj4);
IkReal x612=(cj5*sj4);
IkReal x613=(cj4*new_r01);
IkReal x614=(cj4*new_r00);
IkReal x615=((1.0)*x609);
IkReal x616=(cj5*x608);
IkReal x617=((1.0)*x608);
evalcond[0]=(((sj5*x609))+new_r20);
evalcond[1]=(new_r21+(((-1.0)*x608*x610)));
evalcond[2]=(((new_r11*sj4))+x616+x613);
evalcond[3]=(((cj4*new_r10))+(((-1.0)*x617))+(((-1.0)*new_r00*x611)));
evalcond[4]=(((cj4*new_r11))+(((-1.0)*x615))+(((-1.0)*new_r01*x611)));
evalcond[5]=(((sj4*x609))+new_r01+((cj4*x616)));
evalcond[6]=(((new_r10*sj4))+(((-1.0)*cj5*x615))+x614);
evalcond[7]=(((sj4*x608))+(((-1.0)*cj4*cj5*x615))+new_r00);
evalcond[8]=(((x608*x612))+(((-1.0)*cj4*x615))+new_r11);
evalcond[9]=((((-1.0)*cj5*x609*x611))+(((-1.0)*cj4*x617))+new_r10);
evalcond[10]=((((-1.0)*new_r21*x610))+((new_r11*x612))+x608+((cj5*x613)));
evalcond[11]=(((new_r10*x612))+(((-1.0)*x615))+((cj5*x614))+(((-1.0)*new_r20*x610)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x618=IKPowWithIntegerCheck(IKsign(sj5),-1);
if(!x618.valid){
continue;
}
CheckValue<IkReal> x619 = IKatan2WithCheck(IkReal(new_r21),((-1.0)*new_r20),IKFAST_ATAN2_MAGTHRESH);
if(!x619.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(((1.5707963267949)*(x618.value)))+(x619.value));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[12];
IkReal x620=IKsin(j6);
IkReal x621=IKcos(j6);
IkReal x622=((1.0)*sj5);
IkReal x623=((1.0)*sj4);
IkReal x624=(cj5*sj4);
IkReal x625=(cj4*new_r01);
IkReal x626=(cj4*new_r00);
IkReal x627=((1.0)*x621);
IkReal x628=(cj5*x620);
IkReal x629=((1.0)*x620);
evalcond[0]=(((sj5*x621))+new_r20);
evalcond[1]=((((-1.0)*x620*x622))+new_r21);
evalcond[2]=(((new_r11*sj4))+x625+x628);
evalcond[3]=((((-1.0)*new_r00*x623))+((cj4*new_r10))+(((-1.0)*x629)));
evalcond[4]=((((-1.0)*new_r01*x623))+((cj4*new_r11))+(((-1.0)*x627)));
evalcond[5]=(((sj4*x621))+((cj4*x628))+new_r01);
evalcond[6]=(((new_r10*sj4))+(((-1.0)*cj5*x627))+x626);
evalcond[7]=(((sj4*x620))+(((-1.0)*cj4*cj5*x627))+new_r00);
evalcond[8]=((((-1.0)*cj4*x627))+new_r11+((x620*x624)));
evalcond[9]=((((-1.0)*cj4*x629))+(((-1.0)*cj5*x621*x623))+new_r10);
evalcond[10]=(((cj5*x625))+(((-1.0)*new_r21*x622))+((new_r11*x624))+x620);
evalcond[11]=((((-1.0)*x627))+((cj5*x626))+((new_r10*x624))+(((-1.0)*new_r20*x622)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}
}
}
}
}static inline void polyroots3(IkReal rawcoeffs[3+1], IkReal rawroots[3], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots2(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[3];
    const int maxsteps = 110;
    for(int i = 0; i < 3; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[3];
    IkReal err[3];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 3; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 3; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 3; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 3; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[3] = {false};
    for(int i = 0; i < 3; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 3; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots2(IkReal rawcoeffs[2+1], IkReal rawroots[2], int& numroots) {
    IkReal det = rawcoeffs[1]*rawcoeffs[1]-4*rawcoeffs[0]*rawcoeffs[2];
    if( det < 0 ) {
        numroots=0;
    }
    else if( det == 0 ) {
        rawroots[0] = -0.5*rawcoeffs[1]/rawcoeffs[0];
        numroots = 1;
    }
    else {
        det = IKsqrt(det);
        rawroots[0] = (-rawcoeffs[1]+det)/(2*rawcoeffs[0]);
        rawroots[1] = (-rawcoeffs[1]-det)/(2*rawcoeffs[0]);//rawcoeffs[2]/(rawcoeffs[0]*rawroots[0]);
        numroots = 2;
    }
}
static inline void polyroots5(IkReal rawcoeffs[5+1], IkReal rawroots[5], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots4(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[5];
    const int maxsteps = 110;
    for(int i = 0; i < 5; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[5];
    IkReal err[5];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 5; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 5; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 5; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 5; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[5] = {false};
    for(int i = 0; i < 5; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 5; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots4(IkReal rawcoeffs[4+1], IkReal rawroots[4], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots3(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[4];
    const int maxsteps = 110;
    for(int i = 0; i < 4; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[4];
    IkReal err[4];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 4; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 4; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 4; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 4; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[4] = {false};
    for(int i = 0; i < 4; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 4; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots7(IkReal rawcoeffs[7+1], IkReal rawroots[7], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots6(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[7];
    const int maxsteps = 110;
    for(int i = 0; i < 7; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[7];
    IkReal err[7];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 7; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 7; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 7; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 7; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[7] = {false};
    for(int i = 0; i < 7; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 7; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots6(IkReal rawcoeffs[6+1], IkReal rawroots[6], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots5(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[6];
    const int maxsteps = 110;
    for(int i = 0; i < 6; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[6];
    IkReal err[6];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 6; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 6; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 6; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 6; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[6] = {false};
    for(int i = 0; i < 6; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 6; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots8(IkReal rawcoeffs[8+1], IkReal rawroots[8], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots7(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[8];
    const int maxsteps = 110;
    for(int i = 0; i < 8; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[8];
    IkReal err[8];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 8; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 8; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 8; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 8; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[8] = {false};
    for(int i = 0; i < 8; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 8; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
};


/// solves the inverse kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API bool ComputeIk2(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions, void* pOpenRAVEManip) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API const char* GetKinematicsHash() { return "<robot:GenericRobot - tiago (52f72caad381e7543aa8e1a0d39be57b)>"; }

IKFAST_API const char* GetIkFastVersion() { return "0x10000048"; }

#ifdef IKFAST_NAMESPACE
} // end namespace
#endif

#ifndef IKFAST_NO_MAIN
#include <stdio.h>
#include <stdlib.h>
#ifdef IKFAST_NAMESPACE
using namespace IKFAST_NAMESPACE;
#endif
int main(int argc, char** argv)
{
    if( argc != 12+GetNumFreeParameters()+1 ) {
        printf("\nUsage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\n\n"
               "Returns the ik solutions given the transformation of the end effector specified by\n"
               "a 3x3 rotation R (rXX), and a 3x1 translation (tX).\n"
               "There are %d free parameters that have to be specified.\n\n",GetNumFreeParameters());
        return 1;
    }

    IkSolutionList<IkReal> solutions;
    std::vector<IkReal> vfree(GetNumFreeParameters());
    IkReal eerot[9],eetrans[3];
    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);
    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);
    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);
    for(std::size_t i = 0; i < vfree.size(); ++i)
        vfree[i] = atof(argv[13+i]);
    bool bSuccess = ComputeIk(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, solutions);

    if( !bSuccess ) {
        fprintf(stderr,"Failed to get ik solution\n");
        return -1;
    }

    printf("Found %d ik solutions:\n", (int)solutions.GetNumSolutions());
    std::vector<IkReal> solvalues(GetNumJoints());
    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {
        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);
        printf("sol%d (free=%d): ", (int)i, (int)sol.GetFree().size());
        std::vector<IkReal> vsolfree(sol.GetFree().size());
        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);
        for( std::size_t j = 0; j < solvalues.size(); ++j)
            printf("%.15f, ", solvalues[j]);
        printf("\n");
    }
    return 0;
}

#endif
