/// autogenerated analytical inverse kinematics code from ikfast program part of OpenRAVE
/// \author Rosen Diankov
///
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///     http://www.apache.org/licenses/LICENSE-2.0
/// 
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.
///
/// ikfast version 0x10000048 generated on 2016-01-24 23:53:15.625743
/// To compile with gcc:
///     gcc -lstdc++ ik.cpp
/// To compile without any main function as a shared object (might need -llapack):
///     gcc -fPIC -lstdc++ -DIKFAST_NO_MAIN -DIKFAST_CLIBRARY -shared -Wl,-soname,libik.so -o libik.so ik.cpp
#define IKFAST_HAS_LIBRARY
#include "ikfast.h" // found inside share/openrave-X.Y/python/ikfast.h
using namespace ikfast;

// check if the included ikfast version matches what this file was compiled with
#define IKFAST_COMPILE_ASSERT(x) extern int __dummy[(int)x]
IKFAST_COMPILE_ASSERT(IKFAST_VERSION==0x10000048);

#include <cmath>
#include <vector>
#include <limits>
#include <algorithm>
#include <complex>

#ifndef IKFAST_ASSERT
#include <stdexcept>
#include <sstream>
#include <iostream>

#ifdef _MSC_VER
#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __FUNCDNAME__
#endif
#endif

#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __func__
#endif

#define IKFAST_ASSERT(b) { if( !(b) ) { std::stringstream ss; ss << "ikfast exception: " << __FILE__ << ":" << __LINE__ << ": " <<__PRETTY_FUNCTION__ << ": Assertion '" << #b << "' failed"; throw std::runtime_error(ss.str()); } }

#endif

#if defined(_MSC_VER)
#define IKFAST_ALIGNED16(x) __declspec(align(16)) x
#else
#define IKFAST_ALIGNED16(x) x __attribute((aligned(16)))
#endif

#define IK2PI  ((IkReal)6.28318530717959)
#define IKPI  ((IkReal)3.14159265358979)
#define IKPI_2  ((IkReal)1.57079632679490)

#ifdef _MSC_VER
#ifndef isnan
#define isnan _isnan
#endif
#ifndef isinf
#define isinf _isinf
#endif
//#ifndef isfinite
//#define isfinite _isfinite
//#endif
#endif // _MSC_VER

// lapack routines
extern "C" {
  void dgetrf_ (const int* m, const int* n, double* a, const int* lda, int* ipiv, int* info);
  void zgetrf_ (const int* m, const int* n, std::complex<double>* a, const int* lda, int* ipiv, int* info);
  void dgetri_(const int* n, const double* a, const int* lda, int* ipiv, double* work, const int* lwork, int* info);
  void dgesv_ (const int* n, const int* nrhs, double* a, const int* lda, int* ipiv, double* b, const int* ldb, int* info);
  void dgetrs_(const char *trans, const int *n, const int *nrhs, double *a, const int *lda, int *ipiv, double *b, const int *ldb, int *info);
  void dgeev_(const char *jobvl, const char *jobvr, const int *n, double *a, const int *lda, double *wr, double *wi,double *vl, const int *ldvl, double *vr, const int *ldvr, double *work, const int *lwork, int *info);
}

using namespace std; // necessary to get std math routines

#ifdef IKFAST_NAMESPACE
namespace IKFAST_NAMESPACE {
#endif

inline float IKabs(float f) { return fabsf(f); }
inline double IKabs(double f) { return fabs(f); }

inline float IKsqr(float f) { return f*f; }
inline double IKsqr(double f) { return f*f; }

inline float IKlog(float f) { return logf(f); }
inline double IKlog(double f) { return log(f); }

// allows asin and acos to exceed 1
#ifndef IKFAST_SINCOS_THRESH
#define IKFAST_SINCOS_THRESH ((IkReal)2e-6)
#endif

// used to check input to atan2 for degenerate cases
#ifndef IKFAST_ATAN2_MAGTHRESH
#define IKFAST_ATAN2_MAGTHRESH ((IkReal)2e-6)
#endif

// minimum distance of separate solutions
#ifndef IKFAST_SOLUTION_THRESH
#define IKFAST_SOLUTION_THRESH ((IkReal)1e-6)
#endif

// there are checkpoints in ikfast that are evaluated to make sure they are 0. This threshold speicfies by how much they can deviate
#ifndef IKFAST_EVALCOND_THRESH
#define IKFAST_EVALCOND_THRESH ((IkReal)0.000005)
#endif


inline float IKasin(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(-IKPI_2);
else if( f >= 1 ) return float(IKPI_2);
return asinf(f);
}
inline double IKasin(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return -IKPI_2;
else if( f >= 1 ) return IKPI_2;
return asin(f);
}

// return positive value in [0,y)
inline float IKfmod(float x, float y)
{
    while(x < 0) {
        x += y;
    }
    return fmodf(x,y);
}

// return positive value in [0,y)
inline double IKfmod(double x, double y)
{
    while(x < 0) {
        x += y;
    }
    return fmod(x,y);
}

inline float IKacos(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(IKPI);
else if( f >= 1 ) return float(0);
return acosf(f);
}
inline double IKacos(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return IKPI;
else if( f >= 1 ) return 0;
return acos(f);
}
inline float IKsin(float f) { return sinf(f); }
inline double IKsin(double f) { return sin(f); }
inline float IKcos(float f) { return cosf(f); }
inline double IKcos(double f) { return cos(f); }
inline float IKtan(float f) { return tanf(f); }
inline double IKtan(double f) { return tan(f); }
inline float IKsqrt(float f) { if( f <= 0.0f ) return 0.0f; return sqrtf(f); }
inline double IKsqrt(double f) { if( f <= 0.0 ) return 0.0; return sqrt(f); }
inline float IKatan2Simple(float fy, float fx) {
    return atan2f(fy,fx);
}
inline float IKatan2(float fy, float fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return float(IKPI_2);
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2f(fy,fx);
}
inline double IKatan2Simple(double fy, double fx) {
    return atan2(fy,fx);
}
inline double IKatan2(double fy, double fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return IKPI_2;
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2(fy,fx);
}

template <typename T>
struct CheckValue
{
    T value;
    bool valid;
};

template <typename T>
inline CheckValue<T> IKatan2WithCheck(T fy, T fx, T epsilon)
{
    CheckValue<T> ret;
    ret.valid = false;
    ret.value = 0;
    if( !isnan(fy) && !isnan(fx) ) {
        if( IKabs(fy) >= IKFAST_ATAN2_MAGTHRESH || IKabs(fx) > IKFAST_ATAN2_MAGTHRESH ) {
            ret.value = IKatan2Simple(fy,fx);
            ret.valid = true;
        }
    }
    return ret;
}

inline float IKsign(float f) {
    if( f > 0 ) {
        return float(1);
    }
    else if( f < 0 ) {
        return float(-1);
    }
    return 0;
}

inline double IKsign(double f) {
    if( f > 0 ) {
        return 1.0;
    }
    else if( f < 0 ) {
        return -1.0;
    }
    return 0;
}

template <typename T>
inline CheckValue<T> IKPowWithIntegerCheck(T f, int n)
{
    CheckValue<T> ret;
    ret.valid = true;
    if( n == 0 ) {
        ret.value = 1.0;
        return ret;
    }
    else if( n == 1 )
    {
        ret.value = f;
        return ret;
    }
    else if( n < 0 )
    {
        if( f == 0 )
        {
            ret.valid = false;
            ret.value = (T)1.0e30;
            return ret;
        }
        if( n == -1 ) {
            ret.value = T(1.0)/f;
            return ret;
        }
    }

    int num = n > 0 ? n : -n;
    if( num == 2 ) {
        ret.value = f*f;
    }
    else if( num == 3 ) {
        ret.value = f*f*f;
    }
    else {
        ret.value = 1.0;
        while(num>0) {
            if( num & 1 ) {
                ret.value *= f;
            }
            num >>= 1;
            f *= f;
        }
    }
    
    if( n < 0 ) {
        ret.value = T(1.0)/ret.value;
    }
    return ret;
}

/// solves the forward kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API void ComputeFk(const IkReal* j, IkReal* eetrans, IkReal* eerot) {
IkReal x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19,x20,x21,x22,x23,x24,x25,x26,x27,x28,x29,x30,x31,x32,x33,x34,x35,x36,x37,x38,x39,x40,x41,x42,x43,x44,x45,x46,x47,x48,x49,x50,x51,x52,x53,x54,x55,x56,x57,x58,x59,x60,x61,x62,x63,x64,x65;
x0=IKsin(j[0]);
x1=IKcos(j[0]);
x2=IKcos(j[2]);
x3=IKsin(j[1]);
x4=IKsin(j[2]);
x5=IKcos(j[3]);
x6=IKcos(j[1]);
x7=IKsin(j[3]);
x8=IKcos(j[4]);
x9=IKsin(j[4]);
x10=IKcos(j[5]);
x11=IKsin(j[5]);
x12=IKsin(j[6]);
x13=IKcos(j[6]);
x14=((0.02)*x0);
x15=((0.046)*x8);
x16=((0.318)*x4);
x17=((1.0)*x11);
x18=((1.0)*x5);
x19=((0.046)*x9);
x20=((0.02)*x1);
x21=((1.0)*x7);
x22=((1.0)*x10);
x23=((0.046)*x5);
x24=((0.318)*x5);
x25=((1.0)*x3);
x26=(x2*x6);
x27=(x4*x6);
x28=(x2*x3);
x29=(x0*x4);
x30=(x1*x4);
x31=(x0*x6);
x32=(x1*x2);
x33=(x3*x5);
x34=(x6*x7);
x35=(x3*x7);
x36=(x1*x6);
x37=(x20*x4);
x38=(x14*x4);
x39=(x18*x3);
x40=((1.0)*x0*x2);
x41=(x18*x31);
x42=(x14*x28);
x43=(x25*x30);
x44=(x20*x28);
x45=((((-1.0)*x0*x2*x25))+x30);
x46=(((x29*x3))+x32);
x47=(((x1*x28))+x29);
x48=((((-1.0)*x43))+((x0*x2)));
x49=(x35+((x26*x5)));
x50=((((-1.0)*x39))+((x26*x7)));
x51=(x45*x7);
x52=(x38+x44);
x53=(x47*x7);
x54=(x11*x50);
x55=(((x31*x7))+((x45*x5)));
x56=(((x47*x5))+(((-1.0)*x21*x36)));
x57=(x53+((x36*x5)));
x58=(((x49*x9))+(((-1.0)*x27*x8)));
x59=(((x27*x9))+((x49*x8)));
x60=(x10*x58);
x61=(((x46*x8))+((x55*x9)));
x62=(((x56*x9))+((x48*x8)));
x63=(((x56*x8))+((x9*(((((-1.0)*x40))+x43)))));
x64=(((x55*x8))+((x9*(((((-1.0)*x32))+(((-1.0)*x25*x29)))))));
x65=(x10*x61);
eerot[0]=(((x10*((x41+(((-1.0)*x51))))))+((x11*x61)));
eerot[1]=(((x12*x64))+((x13*((((x11*(((((-1.0)*x41))+x51))))+x65)))));
eerot[2]=(((x13*x64))+(((-1.0)*x12*(((((1.0)*x65))+(((1.0)*x11*((x51+(((-1.0)*x31*x5)))))))))));
eetrans[0]=((0.155)+(((-1.0)*x37))+(((0.31)*x31))+((x11*((((x19*x55))+((x15*x46))))))+((x10*((((x23*x31))+(((-0.046)*x51))))))+((x14*x3))+((x14*x34))+x42+((x24*x31))+(((0.125)*x0))+(((0.009)*x1))+((x7*(((((-1.0)*x1*x16))+(((0.318)*x0*x28))))))+((x5*(((((-1.0)*x42))+x37)))));
eerot[3]=(((x11*x62))+((x10*(((((-1.0)*x18*x36))+(((-1.0)*x21*x47)))))));
eerot[4]=(((x12*x63))+((x13*((((x11*x57))+((x10*x62)))))));
eerot[5]=(((x13*x63))+((x12*(((((-1.0)*x17*x57))+(((-1.0)*x22*x62)))))));
IkReal x66=((1.0)*x20);
IkReal x67=((1.0)*x36);
eetrans[1]=((0.011)+(((-1.0)*x34*x66))+((x10*(((((-1.0)*x23*x67))+(((-0.046)*x53))))))+(((-0.125)*x1))+(((-1.0)*x24*x67))+((x11*((((x19*x56))+((x15*x48))))))+((x7*(((((-0.318)*x1*x28))+(((-1.0)*x0*x16))))))+((x5*x52))+(((-1.0)*x3*x66))+(((0.009)*x0))+(((-1.0)*x52))+(((-0.31)*x36)));
eerot[6]=(((x11*x58))+((x10*(((((-1.0)*x21*x26))+x39)))));
eerot[7]=(((x12*x59))+((x13*((x54+x60)))));
eerot[8]=(((x13*x59))+((x12*(((((-1.0)*x17*x50))+(((-1.0)*x22*x58)))))));
IkReal x68=(x26*x7);
IkReal x69=((0.02)*x26);
eetrans[2]=((-0.184)+(((-0.318)*x68))+(((0.31)*x3))+(((-0.02)*x6))+(((0.02)*x35))+((x5*x69))+((x10*((((x23*x3))+(((-0.046)*x68))))))+((x11*(((((-1.0)*x15*x27))+((x19*x49))))))+(((-1.0)*x69))+((x24*x3)));
}

IKFAST_API int GetNumFreeParameters() { return 1; }
IKFAST_API int* GetFreeParameters() { static int freeparams[] = {1}; return freeparams; }
IKFAST_API int GetNumJoints() { return 7; }

IKFAST_API int GetIkRealSize() { return sizeof(IkReal); }

IKFAST_API int GetIkType() { return 0x67000001; }

class IKSolver {
public:
IkReal j0,cj0,sj0,htj0,j0mul,j2,cj2,sj2,htj2,j2mul,j3,cj3,sj3,htj3,j3mul,j4,cj4,sj4,htj4,j4mul,j5,cj5,sj5,htj5,j5mul,j6,cj6,sj6,htj6,j6mul,j1,cj1,sj1,htj1,new_r00,r00,rxp0_0,new_r01,r01,rxp0_1,new_r02,r02,rxp0_2,new_r10,r10,rxp1_0,new_r11,r11,rxp1_1,new_r12,r12,rxp1_2,new_r20,r20,rxp2_0,new_r21,r21,rxp2_1,new_r22,r22,rxp2_2,new_px,px,npx,new_py,py,npy,new_pz,pz,npz,pp;
unsigned char _ij0[2], _nj0,_ij2[2], _nj2,_ij3[2], _nj3,_ij4[2], _nj4,_ij5[2], _nj5,_ij6[2], _nj6,_ij1[2], _nj1;

IkReal j100, cj100, sj100;
unsigned char _ij100[2], _nj100;
bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
j0=numeric_limits<IkReal>::quiet_NaN(); _ij0[0] = -1; _ij0[1] = -1; _nj0 = -1; j2=numeric_limits<IkReal>::quiet_NaN(); _ij2[0] = -1; _ij2[1] = -1; _nj2 = -1; j3=numeric_limits<IkReal>::quiet_NaN(); _ij3[0] = -1; _ij3[1] = -1; _nj3 = -1; j4=numeric_limits<IkReal>::quiet_NaN(); _ij4[0] = -1; _ij4[1] = -1; _nj4 = -1; j5=numeric_limits<IkReal>::quiet_NaN(); _ij5[0] = -1; _ij5[1] = -1; _nj5 = -1; j6=numeric_limits<IkReal>::quiet_NaN(); _ij6[0] = -1; _ij6[1] = -1; _nj6 = -1;  _ij1[0] = -1; _ij1[1] = -1; _nj1 = 0; 
for(int dummyiter = 0; dummyiter < 1; ++dummyiter) {
    solutions.Clear();
j1=pfree[0]; cj1=cos(pfree[0]); sj1=sin(pfree[0]), htj1=tan(pfree[0]*0.5);
r00 = eerot[0*3+0];
r01 = eerot[0*3+1];
r02 = eerot[0*3+2];
r10 = eerot[1*3+0];
r11 = eerot[1*3+1];
r12 = eerot[1*3+2];
r20 = eerot[2*3+0];
r21 = eerot[2*3+1];
r22 = eerot[2*3+2];
px = eetrans[0]; py = eetrans[1]; pz = eetrans[2];

new_r00=r01;
new_r01=r02;
new_r02=r00;
new_px=((-0.155)+px+(((-0.046)*r00)));
new_r10=r11;
new_r11=r12;
new_r12=r10;
new_py=((-0.011)+py+(((-0.046)*r10)));
new_r20=r21;
new_r21=r22;
new_r22=r20;
new_pz=((0.184)+pz+(((-0.046)*r20)));
r00 = new_r00; r01 = new_r01; r02 = new_r02; r10 = new_r10; r11 = new_r11; r12 = new_r12; r20 = new_r20; r21 = new_r21; r22 = new_r22; px = new_px; py = new_py; pz = new_pz;
IkReal x70=((1.0)*px);
IkReal x71=((1.0)*pz);
IkReal x72=((1.0)*py);
pp=((px*px)+(py*py)+(pz*pz));
npx=(((px*r00))+((py*r10))+((pz*r20)));
npy=(((px*r01))+((py*r11))+((pz*r21)));
npz=(((px*r02))+((py*r12))+((pz*r22)));
rxp0_0=((((-1.0)*r20*x72))+((pz*r10)));
rxp0_1=(((px*r20))+(((-1.0)*r00*x71)));
rxp0_2=((((-1.0)*r10*x70))+((py*r00)));
rxp1_0=((((-1.0)*r21*x72))+((pz*r11)));
rxp1_1=(((px*r21))+(((-1.0)*r01*x71)));
rxp1_2=(((py*r01))+(((-1.0)*r11*x70)));
rxp2_0=((((-1.0)*r22*x72))+((pz*r12)));
rxp2_1=(((px*r22))+(((-1.0)*r02*x71)));
rxp2_2=(((py*r02))+(((-1.0)*r12*x70)));
IkReal op[8+1], zeror[8];
int numroots;
IkReal x73=(pz*sj1);
IkReal x74=((0.018)*px);
IkReal x75=((0.125)*cj1);
IkReal x76=(cj1*py);
IkReal x77=((0.25)*py);
IkReal x78=((0.005)*sj1);
IkReal x79=((1.0)*pp);
IkReal x80=((0.04)*py*sj1);
IkReal x81=((0.04)*cj1*pz);
IkReal x82=(x76+x73);
IkReal x83=((((1.0)*x76))+x75);
IkReal x84=(x77+x80);
IkReal x85=((-0.628)+(((-1.0)*x75))+x82);
IkReal x86=((0.008)+(((-1.0)*x75))+x82);
IkReal x87=((-0.628)+x73+(((-1.0)*x83)));
IkReal x88=((0.008)+x73+(((-1.0)*x83)));
IkReal x89=((((0.5)*px))+(((0.08)*px*sj1))+(((0.036)*py)));
IkReal x90=(x79+x78+x81);
IkReal x91=(x74+x90);
IkReal x92=(x84+x90);
IkReal x93=((0.378278)+x74+(((-1.0)*x92)));
IkReal x94=((-0.014442)+x74+(((-1.0)*x92)));
IkReal x95=((0.378278)+x84+(((-1.0)*x91)));
IkReal x96=((-0.014442)+x84+(((-1.0)*x91)));
IkReal gconst0=x87;
IkReal gconst1=x88;
IkReal gconst2=x93;
IkReal gconst3=x94;
IkReal gconst4=x87;
IkReal gconst5=x88;
IkReal gconst6=x93;
IkReal gconst7=x94;
IkReal gconst8=x89;
IkReal gconst9=x89;
IkReal gconst10=x89;
IkReal gconst11=x89;
IkReal gconst12=x85;
IkReal gconst13=x86;
IkReal gconst14=x95;
IkReal gconst15=x96;
IkReal gconst16=x85;
IkReal gconst17=x86;
IkReal gconst18=x95;
IkReal gconst19=x96;
IkReal x97=cj1*cj1;
IkReal x98=px*px;
IkReal x99=(gconst0*gconst15);
IkReal x100=(gconst5*gconst6);
IkReal x101=(gconst17*gconst18);
IkReal x102=((1.0)*gconst1);
IkReal x103=(gconst13*gconst14);
IkReal x104=(gconst11*gconst16);
IkReal x105=(gconst1*gconst2);
IkReal x106=(gconst16*gconst9);
IkReal x107=(gconst18*gconst9);
IkReal x108=(gconst0*gconst3);
IkReal x109=(gconst12*gconst15);
IkReal x110=(gconst12*gconst9);
IkReal x111=((0.0020096)*gconst13);
IkReal x112=(gconst15*gconst18);
IkReal x113=(gconst16*gconst19);
IkReal x114=(gconst4*gconst7);
IkReal x115=(gconst18*gconst5);
IkReal x116=((0.0025240576)*gconst4);
IkReal x117=(gconst3*gconst6);
IkReal x118=((0.0016)*gconst10);
IkReal x119=((0.0020096)*gconst3);
IkReal x120=(gconst10*gconst17);
IkReal x121=(gconst12*gconst3);
IkReal x122=(gconst0*gconst9);
IkReal x123=(gconst2*gconst6);
IkReal x124=((0.0020096)*gconst1);
IkReal x125=(gconst1*gconst8);
IkReal x126=(gconst17*gconst6);
IkReal x127=(gconst13*gconst2);
IkReal x128=(gconst16*gconst7);
IkReal x129=(gconst11*gconst4);
IkReal x130=((0.0020096)*gconst4);
IkReal x131=(gconst13*gconst8);
IkReal x132=(gconst10*gconst5);
IkReal x133=((0.0025240576)*gconst16);
IkReal x134=(gconst19*gconst4);
IkReal x135=((0.0016)*gconst6);
IkReal x136=(gconst1*gconst14);
IkReal x137=(gconst15*gconst16);
IkReal x138=(gconst1*x133);
IkReal x139=((0.0016)*gconst18*gconst3);
IkReal x140=(gconst15*x135);
IkReal x141=(gconst16*x119);
IkReal x142=(gconst18*x124);
IkReal x143=(gconst9*x118);
IkReal x144=(gconst15*x130);
IkReal x145=(gconst6*x111);
IkReal x146=(gconst13*x116);
IkReal x147=((2.0)*cj1*px);
IkReal x148=((1.0)*x134);
IkReal x149=(gconst2*x132);
IkReal x150=((0.0040192)*cj1*px);
IkReal x151=((0.0050481152)*cj1*px);
IkReal x152=(gconst9*x150);
IkReal x153=(gconst10*x150);
IkReal x154=((0.0100962304)*x97*x98);
IkReal x155=((4.0)*x97*x98);
IkReal x156=(x154+x153+x152+x140+x141+x142+x143+x144+x145+x146+x139+x138);
op[0]=((((-1.0)*x109*x113))+((x103*x113))+(((-1.0)*gconst13*x133))+(((-1.0)*gconst18*x111))+(((-0.0016)*x112))+(((-1.0)*x101*x103))+(((-0.0020096)*x137))+((x101*x109)));
op[1]=((((-0.0020096)*x106))+(((-1.0)*gconst15*x113*x147))+(((-1.0)*gconst12*gconst19*x106))+(((-1.0)*gconst19*x109*x147))+(((-1.0)*gconst14*x101*x147))+(((-1.0)*gconst10*x111))+(((-1.0)*x103*x120))+((x103*x104))+(((-1.0)*x101*x131))+((x113*x131))+(((-0.0016)*x107))+(((-1.0)*gconst13*x151))+((x109*x120))+(((-1.0)*gconst15*x150))+((gconst18*x109*x147))+(((-1.0)*gconst18*x150))+((x101*x110))+((gconst14*x113*x147))+(((-1.0)*gconst15*x118))+(((-1.0)*gconst18*x103*x147))+(((-1.0)*x104*x109))+(((-1.0)*gconst16*x151))+((gconst19*x103*x147))+((gconst15*x101*x147)));
op[2]=(((gconst9*x101*x147))+((x101*x121))+((gconst15*x120*x147))+(((-1.0)*x156))+(((-1.0)*x113*x99))+(((-0.0040192)*x137))+((gconst14*gconst19*x155))+(((-1.0)*gconst19*x110*x147))+(((-1.0)*gconst11*x109*x147))+(((-1.0)*x109*x128))+(((-1.0)*gconst15*x104*x147))+((gconst14*x104*x147))+((x103*x134))+((x101*x99))+(((-1.0)*x103*x115))+((gconst11*x103*x147))+((x103*x128))+(((-0.0040192)*gconst13*gconst18))+(((-1.0)*x103*x126))+((x109*x115))+(((-1.0)*gconst10*x103*x147))+((x113*x127))+((x112*x155))+((gconst12*x107*x147))+((x113*x136))+(((-1.0)*x113*x121))+(((-0.0032)*x112))+(((-1.0)*x101*x127))+(((-1.0)*gconst8*x101*x147))+((x109*x126))+((x104*x131))+(((-1.0)*gconst14*x101*x102))+(((-1.0)*x120*x131))+(((-1.0)*gconst14*gconst18*x155))+(((-1.0)*gconst15*gconst19*x155))+(((-1.0)*x109*x148))+(((-0.0050481152)*gconst13*gconst16))+(((-1.0)*gconst19*x106*x147))+(((-1.0)*x104*x110))+((gconst8*x113*x147))+(((-1.0)*gconst14*x120*x147))+((x110*x120))+((gconst10*x109*x147))+(((-1.0)*gconst18*x131*x147))+((gconst19*x131*x147)));
op[3]=((((-2.0)*cj1*gconst12*gconst19*gconst3*px))+(((-1.0)*gconst13*gconst18*gconst5*gconst8))+(((-2.0)*cj1*gconst11*gconst12*gconst9*px))+(((2.0)*cj1*gconst13*gconst14*gconst7*px))+(((2.0)*cj1*gconst11*gconst16*gconst8*px))+(((2.0)*cj1*gconst14*gconst16*gconst7*px))+(((-1.0)*gconst10*gconst13*gconst14*gconst5))+((gconst0*gconst17*gconst18*gconst9))+((gconst10*gconst12*gconst17*gconst3))+((gconst12*gconst17*gconst6*gconst9))+(((-0.0080384)*cj1*gconst15*px))+(((2.0)*cj1*gconst11*gconst13*gconst8*px))+(((-1.0)*gconst13*gconst17*gconst6*gconst8))+(((-0.0016)*gconst10*gconst3))+((gconst12*gconst18*gconst5*gconst9))+((gconst10*gconst12*gconst15*gconst5))+(((-2.0)*cj1*gconst10*gconst17*gconst8*px))+(((-2.0)*cj1*gconst13*gconst18*gconst2*px))+(((-2.0)*cj1*gconst13*gconst14*gconst6*px))+(((-1.0)*gconst1*gconst10*gconst14*gconst17))+(((-2.0)*cj1*gconst14*gconst18*gconst5*px))+((gconst0*gconst10*gconst15*gconst17))+(((-1.0)*gconst12*gconst16*gconst7*gconst9))+(((-0.0020096)*gconst4*gconst9))+(((-1.0)*gconst11*gconst12*gconst15*gconst4))+(((4.0)*gconst10*gconst15*(cj1*cj1)*(px*px)))+(((2.0)*cj1*gconst15*gconst17*gconst6*px))+((gconst13*gconst16*gconst7*gconst8))+(((2.0)*cj1*gconst10*gconst17*gconst9*px))+(((-0.0032)*gconst18*gconst9))+(((-0.0040192)*cj1*gconst3*px))+(((-4.0)*gconst18*gconst8*(cj1*cj1)*(px*px)))+((gconst11*gconst13*gconst14*gconst4))+(((-2.0)*cj1*gconst14*gconst17*gconst6*px))+((gconst1*gconst16*gconst19*gconst8))+(((-1.0)*gconst0*gconst16*gconst19*gconst9))+(((-2.0)*cj1*gconst10*gconst13*gconst8*px))+(((2.0)*cj1*gconst15*gconst18*gconst5*px))+(((-0.0100962304)*cj1*gconst13*px))+(((-4.0)*gconst19*gconst9*(cj1*cj1)*(px*px)))+(((-0.0040192)*gconst16*gconst9))+(((-4.0)*gconst10*gconst14*(cj1*cj1)*(px*px)))+(((4.0)*gconst18*gconst9*(cj1*cj1)*(px*px)))+(((-0.0050481152)*cj1*gconst4*px))+(((4.0)*gconst19*gconst8*(cj1*cj1)*(px*px)))+((gconst11*gconst13*gconst16*gconst2))+(((2.0)*cj1*gconst13*gconst19*gconst2*px))+(((2.0)*cj1*gconst14*gconst19*gconst4*px))+(((-1.0)*gconst12*gconst19*gconst4*gconst9))+(((-0.0020096)*gconst1*gconst10))+(((2.0)*cj1*gconst12*gconst15*gconst6*px))+(((-2.0)*cj1*gconst0*gconst15*gconst19*px))+(((-1.0)*gconst0*gconst11*gconst15*gconst16))+(((-2.0)*cj1*gconst17*gconst18*gconst2*px))+(((-0.0040192)*gconst10*gconst13))+((gconst13*gconst19*gconst4*gconst8))+(((-0.0050481152)*cj1*gconst1*px))+(((-1.0)*gconst1*gconst17*gconst18*gconst8))+(((-0.0032)*gconst10*gconst15))+(((2.0)*cj1*gconst0*gconst15*gconst18*px))+(((-2.0)*cj1*gconst16*gconst19*gconst3*px))+(((2.0)*cj1*gconst12*gconst18*gconst3*px))+(((-4.0)*gconst11*gconst15*(cj1*cj1)*(px*px)))+(((-0.0040192)*cj1*gconst6*px))+((gconst1*gconst11*gconst14*gconst16))+(((4.0)*gconst11*gconst14*(cj1*cj1)*(px*px)))+(((-0.0100962304)*cj1*gconst16*px))+(((-1.0)*gconst10*gconst13*gconst17*gconst2))+(((2.0)*cj1*gconst10*gconst12*gconst9*px))+(((2.0)*cj1*gconst1*gconst14*gconst19*px))+(((-2.0)*cj1*gconst15*gconst19*gconst4*px))+(((2.0)*cj1*gconst17*gconst18*gconst3*px))+(((-1.0)*gconst11*gconst12*gconst16*gconst3))+(((-2.0)*cj1*gconst15*gconst16*gconst7*px))+(((-0.0080384)*cj1*gconst18*px))+(((-2.0)*cj1*gconst1*gconst14*gconst18*px))+(((-0.0016)*gconst6*gconst9))+(((-2.0)*cj1*gconst12*gconst15*gconst7*px))+(((2.0)*cj1*gconst16*gconst19*gconst2*px))+(((-2.0)*cj1*gconst11*gconst16*gconst9*px)));
op[4]=((((-1.0)*gconst1*gconst10*gconst17*gconst8))+(((-0.0020096)*gconst15*gconst16))+(((2.0)*cj1*gconst11*gconst13*gconst2*px))+(((-2.0)*cj1*gconst0*gconst11*gconst15*px))+(((-0.0050481152)*gconst13*gconst4))+(((-2.0)*cj1*gconst19*gconst4*gconst9*px))+((gconst1*gconst14*gconst16*gconst7))+(((-4.0)*gconst19*gconst3*(cj1*cj1)*(px*px)))+(((-1.0)*gconst12*gconst15*gconst4*gconst7))+((gconst13*gconst19*gconst2*gconst4))+((gconst1*gconst14*gconst19*gconst4))+(((-2.0)*cj1*gconst11*gconst15*gconst4*px))+(((-1.0)*gconst1*gconst14*gconst17*gconst6))+((gconst1*gconst11*gconst16*gconst8))+(((4.0)*gconst14*gconst7*(cj1*cj1)*(px*px)))+(((2.0)*cj1*gconst17*gconst6*gconst9*px))+(((2.0)*cj1*gconst10*gconst12*gconst3*px))+((gconst0*gconst15*gconst18*gconst5))+(((-2.0)*cj1*gconst1*gconst10*gconst14*px))+(((-0.0016)*gconst3*gconst6))+((gconst13*gconst14*gconst4*gconst7))+((gconst0*gconst17*gconst18*gconst3))+(((-4.0)*gconst18*gconst2*(cj1*cj1)*(px*px)))+(((2.0)*cj1*gconst16*gconst7*gconst8*px))+(((-0.0032)*gconst10*gconst9))+(((-0.0025240576)*gconst13*gconst16))+((gconst12*gconst17*gconst3*gconst6))+((gconst10*gconst12*gconst5*gconst9))+(((-1.0)*gconst13*gconst18*gconst2*gconst5))+(((2.0)*cj1*gconst18*gconst5*gconst9*px))+(((-0.0201924608)*(cj1*cj1)*(px*px)))+(((-0.0080384)*cj1*gconst9*px))+(((-0.0032)*gconst15*gconst6))+(((-2.0)*cj1*gconst18*gconst5*gconst8*px))+(((2.0)*cj1*gconst10*gconst15*gconst5*px))+(((2.0)*cj1*gconst0*gconst10*gconst15*px))+(((-2.0)*cj1*gconst10*gconst13*gconst2*px))+(((-1.0)*gconst12*gconst19*gconst3*gconst4))+(((2.0)*cj1*gconst0*gconst18*gconst9*px))+(((-0.0032)*gconst18*gconst3))+(((-2.0)*cj1*gconst11*gconst12*gconst3*px))+(((4.0)*gconst18*gconst3*(cj1*cj1)*(px*px)))+(((2.0)*cj1*gconst12*gconst6*gconst9*px))+((gconst0*gconst10*gconst17*gconst9))+(((-0.0020096)*gconst13*gconst18))+((gconst13*gconst16*gconst2*gconst7))+(((-0.0016)*gconst15*gconst18))+(((-1.0)*gconst10*gconst13*gconst5*gconst8))+((gconst1*gconst16*gconst19*gconst2))+(((-1.0)*gconst0*gconst11*gconst16*gconst9))+(((-1.0)*gconst0*gconst16*gconst19*gconst3))+(((-0.0050481152)*gconst1*gconst16))+(((-0.0040192)*gconst16*gconst3))+(((-0.0040192)*gconst1*gconst18))+(((-2.0)*cj1*gconst10*gconst14*gconst5*px))+(((-2.0)*cj1*gconst0*gconst19*gconst9*px))+((gconst0*gconst15*gconst17*gconst6))+(((-1.0)*gconst0*gconst15*gconst19*gconst4))+(((2.0)*cj1*gconst1*gconst19*gconst8*px))+(((2.0)*cj1*gconst13*gconst7*gconst8*px))+(((-1.0)*gconst13*gconst17*gconst2*gconst6))+(((-1.0)*gconst1*gconst14*gconst18*gconst5))+(((-0.0020096)*gconst1*gconst6))+(((-0.0080384)*cj1*gconst10*px))+(((-0.0025240576)*gconst1*gconst4))+(((-4.0)*gconst15*gconst7*(cj1*cj1)*(px*px)))+(((2.0)*cj1*gconst10*gconst17*gconst3*px))+(((-1.0)*gconst11*gconst12*gconst4*gconst9))+(((-0.0020096)*gconst3*gconst4))+(((2.0)*cj1*gconst19*gconst4*gconst8*px))+(((-2.0)*cj1*gconst11*gconst16*gconst3*px))+(((4.0)*gconst15*gconst6*(cj1*cj1)*(px*px)))+(((-4.0)*gconst11*gconst9*(cj1*cj1)*(px*px)))+(((-1.0)*gconst13*gconst14*gconst5*gconst6))+((gconst12*gconst18*gconst3*gconst5))+(((-1.0)*gconst12*gconst16*gconst3*gconst7))+(((-1.0)*gconst1*gconst17*gconst18*gconst2))+(((-2.0)*cj1*gconst12*gconst7*gconst9*px))+(((-0.0040192)*gconst15*gconst4))+(((4.0)*gconst10*gconst9*(cj1*cj1)*(px*px)))+(((4.0)*gconst11*gconst8*(cj1*cj1)*(px*px)))+(((2.0)*cj1*gconst11*gconst16*gconst2*px))+(((4.0)*gconst19*gconst2*(cj1*cj1)*(px*px)))+(((2.0)*cj1*gconst11*gconst14*gconst4*px))+(((-4.0)*gconst14*gconst6*(cj1*cj1)*(px*px)))+(((2.0)*cj1*gconst1*gconst11*gconst14*px))+((gconst12*gconst15*gconst5*gconst6))+((gconst11*gconst13*gconst4*gconst8))+(((-4.0)*gconst10*gconst8*(cj1*cj1)*(px*px)))+(((-2.0)*cj1*gconst13*gconst6*gconst8*px))+(((-2.0)*cj1*gconst17*gconst6*gconst8*px))+(((-0.0040192)*gconst13*gconst6))+(((-1.0)*gconst0*gconst15*gconst16*gconst7))+(((-2.0)*cj1*gconst1*gconst18*gconst8*px))+(((-2.0)*cj1*gconst10*gconst17*gconst2*px))+(((-2.0)*cj1*gconst16*gconst7*gconst9*px)));
op[5]=((((-1.0)*gconst1*gconst10*gconst17*gconst2))+(((2.0)*cj1*gconst15*gconst5*gconst6*px))+(((-2.0)*cj1*gconst10*gconst5*gconst8*px))+(((-0.0080384)*cj1*gconst6*px))+(((2.0)*cj1*gconst16*gconst2*gconst7*px))+(((-4.0)*gconst6*gconst8*(cj1*cj1)*(px*px)))+(((-1.0)*gconst12*gconst4*gconst7*gconst9))+(((-0.0100962304)*cj1*gconst1*px))+((gconst1*gconst11*gconst16*gconst2))+(((-2.0)*cj1*gconst17*gconst2*gconst6*px))+(((-2.0)*cj1*gconst13*gconst2*gconst6*px))+(((-0.0020096)*gconst16*gconst9))+(((2.0)*cj1*gconst19*gconst2*gconst4*px))+(((2.0)*cj1*gconst0*gconst10*gconst9*px))+(((2.0)*cj1*gconst0*gconst15*gconst6*px))+(((-2.0)*cj1*gconst12*gconst3*gconst7*px))+(((-0.0032)*gconst10*gconst3))+(((2.0)*cj1*gconst0*gconst18*gconst3*px))+(((-1.0)*gconst1*gconst17*gconst6*gconst8))+((gconst12*gconst5*gconst6*gconst9))+((gconst11*gconst13*gconst2*gconst4))+(((2.0)*cj1*gconst18*gconst3*gconst5*px))+(((-2.0)*cj1*gconst1*gconst10*gconst8*px))+(((-2.0)*cj1*gconst16*gconst3*gconst7*px))+((gconst0*gconst10*gconst15*gconst5))+(((-1.0)*gconst1*gconst18*gconst5*gconst8))+(((-0.0016)*gconst10*gconst15))+(((-0.0020096)*gconst10*gconst13))+((gconst1*gconst11*gconst14*gconst4))+(((-1.0)*gconst13*gconst5*gconst6*gconst8))+(((-0.0040192)*cj1*gconst15*px))+(((-1.0)*gconst0*gconst19*gconst4*gconst9))+(((-0.0032)*gconst6*gconst9))+(((-0.0050481152)*cj1*gconst13*px))+(((-2.0)*cj1*gconst1*gconst18*gconst2*px))+(((-2.0)*cj1*gconst0*gconst11*gconst9*px))+(((-4.0)*gconst10*gconst2*(cj1*cj1)*(px*px)))+(((-2.0)*cj1*gconst0*gconst19*gconst3*px))+((gconst0*gconst10*gconst17*gconst3))+(((-2.0)*cj1*gconst1*gconst14*gconst6*px))+(((-0.0016)*gconst18*gconst9))+(((-2.0)*cj1*gconst0*gconst15*gconst7*px))+(((-1.0)*gconst0*gconst11*gconst16*gconst3))+(((-2.0)*cj1*gconst14*gconst5*gconst6*px))+(((-1.0)*gconst0*gconst16*gconst7*gconst9))+((gconst0*gconst18*gconst5*gconst9))+(((2.0)*cj1*gconst1*gconst19*gconst2*px))+(((2.0)*cj1*gconst1*gconst11*gconst8*px))+((gconst1*gconst19*gconst4*gconst8))+(((-0.0040192)*gconst1*gconst10))+((gconst10*gconst12*gconst3*gconst5))+(((-4.0)*gconst7*gconst9*(cj1*cj1)*(px*px)))+(((-0.0100962304)*cj1*gconst4*px))+((gconst1*gconst16*gconst7*gconst8))+(((2.0)*cj1*gconst13*gconst2*gconst7*px))+((gconst0*gconst17*gconst6*gconst9))+(((2.0)*cj1*gconst10*gconst5*gconst9*px))+(((4.0)*gconst10*gconst3*(cj1*cj1)*(px*px)))+((gconst13*gconst4*gconst7*gconst8))+(((-1.0)*gconst0*gconst11*gconst15*gconst4))+(((4.0)*gconst7*gconst8*(cj1*cj1)*(px*px)))+(((-2.0)*cj1*gconst15*gconst4*gconst7*px))+(((-1.0)*gconst10*gconst13*gconst2*gconst5))+(((2.0)*cj1*gconst12*gconst3*gconst6*px))+(((-2.0)*cj1*gconst19*gconst3*gconst4*px))+(((-0.0050481152)*cj1*gconst16*px))+(((4.0)*gconst6*gconst9*(cj1*cj1)*(px*px)))+(((-0.0040192)*gconst4*gconst9))+(((4.0)*gconst11*gconst2*(cj1*cj1)*(px*px)))+(((-2.0)*cj1*gconst11*gconst4*gconst9*px))+(((-1.0)*gconst11*gconst12*gconst3*gconst4))+(((-2.0)*cj1*gconst18*gconst2*gconst5*px))+(((-0.0080384)*cj1*gconst3*px))+(((-0.0040192)*cj1*gconst18*px))+(((-4.0)*gconst11*gconst3*(cj1*cj1)*(px*px)))+(((-1.0)*gconst1*gconst10*gconst14*gconst5))+(((2.0)*cj1*gconst11*gconst4*gconst8*px))+(((2.0)*cj1*gconst17*gconst3*gconst6*px))+(((2.0)*cj1*gconst1*gconst14*gconst7*px))+(((2.0)*cj1*gconst14*gconst4*gconst7*px)));
op[6]=((((-0.0050481152)*gconst1*gconst4))+(((-1.0)*gconst9*x114*x147))+((gconst7*x125*x147))+((gconst9*x100*x147))+(((-1.0)*x156))+(((-1.0)*gconst8*x100*x147))+((x100*x99))+(((-1.0)*x123*x155))+((x117*x155))+(((-1.0)*x122*x129))+((gconst2*gconst7*x155))+((x114*x127))+((x122*x132))+(((-1.0)*x108*x128))+((x108*x126))+((x114*x136))+((gconst11*x105*x147))+(((-1.0)*gconst6*x125*x147))+((x125*x129))+(((-1.0)*gconst17*x102*x123))+(((-1.0)*gconst10*x105*x147))+((gconst8*x114*x147))+(((-1.0)*x147*x149))+(((-0.0040192)*gconst3*gconst4))+(((-0.0032)*x117))+(((-1.0)*x100*x127))+((x108*x115))+((x105*x128))+(((-1.0)*x114*x99))+((x105*x134))+((gconst2*x129*x147))+(((-0.0040192)*gconst1*gconst6))+(((-1.0)*gconst3*x129*x147))+(((-1.0)*gconst2*x102*x115))+((gconst10*x108*x147))+(((-1.0)*gconst14*x100*x102))+((x100*x121))+((gconst3*x132*x147))+(((-1.0)*gconst11*x108*x147))+(((-1.0)*x114*x121))+(((-1.0)*x108*x148))+((gconst6*x122*x147))+(((-1.0)*gconst8*x102*x132))+(((-1.0)*gconst7*x122*x147))+(((-1.0)*gconst3*gconst7*x155)));
op[7]=((((-1.0)*gconst3*x114*x147))+((gconst6*x108*x147))+((gconst7*x105*x147))+((x114*x125))+(((-1.0)*gconst6*x105*x147))+(((-1.0)*x108*x129))+(((-1.0)*gconst4*x151))+(((-1.0)*x102*x149))+(((-1.0)*gconst10*x124))+((x108*x132))+((gconst3*x100*x147))+(((-1.0)*gconst7*x108*x147))+((x105*x129))+(((-1.0)*gconst3*x150))+(((-1.0)*gconst2*x100*x147))+(((-1.0)*gconst1*x151))+(((-1.0)*gconst6*x150))+(((-1.0)*gconst9*x130))+(((-1.0)*gconst9*x135))+(((-1.0)*gconst8*x100*x102))+((x100*x122))+(((-1.0)*x114*x122))+((gconst2*x114*x147))+(((-1.0)*gconst3*x118)));
op[8]=((((-1.0)*x108*x114))+(((-1.0)*gconst6*x124))+(((-1.0)*gconst1*x116))+(((-0.0016)*x117))+(((-1.0)*gconst4*x119))+((x105*x114))+(((-1.0)*gconst2*x100*x102))+((x100*x108)));
polyroots8(op,zeror,numroots);
IkReal j0array[8], cj0array[8], sj0array[8], tempj0array[1];
int numsolutions = 0;
for(int ij0 = 0; ij0 < numroots; ++ij0)
{
IkReal htj0 = zeror[ij0];
tempj0array[0]=((2.0)*(atan(htj0)));
for(int kj0 = 0; kj0 < 1; ++kj0)
{
j0array[numsolutions] = tempj0array[kj0];
if( j0array[numsolutions] > IKPI )
{
    j0array[numsolutions]-=IK2PI;
}
else if( j0array[numsolutions] < -IKPI )
{
    j0array[numsolutions]+=IK2PI;
}
sj0array[numsolutions] = IKsin(j0array[numsolutions]);
cj0array[numsolutions] = IKcos(j0array[numsolutions]);
numsolutions++;
}
}
bool j0valid[8]={true,true,true,true,true,true,true,true};
_nj0 = 8;
for(int ij0 = 0; ij0 < numsolutions; ++ij0)
    {
if( !j0valid[ij0] )
{
    continue;
}
    j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
htj0 = IKtan(j0/2);

_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < numsolutions; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x157=(cj0*px);
IkReal x158=(cj0*py);
IkReal x159=(px*sj0);
IkReal x160=((6.1857294826839)*cj1);
IkReal x161=(cj1*pz);
IkReal x162=((3.13226429218707)*sj1);
IkReal x163=((0.196997754225602)*sj1);
IkReal x164=(pz*sj1);
IkReal x165=((48.353098774674)*cj1);
IkReal x166=(py*sj0);
if( IKabs(((0.74407923249675)+(((3.13226429218707)*x161))+(((-19.5766518261692)*x159))+(((78.3066073046767)*pp))+(((-48.353098774674)*x164))+(((-1.0)*x159*x162))+(((-1.0)*x159*x165))+(((-1.40951893148418)*x166))+(((-1.40951893148418)*x157))+(((6.04413734683425)*cj1))+(((0.391533036523384)*sj1))+(((19.5766518261692)*x158))+((x158*x162))+((x158*x165)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.02164020330168)+(((-1.23123596391001)*x158))+(((-1.0)*x158*x160))+(((-1.0)*x158*x163))+(((6.1857294826839)*x164))+(((-0.773216185335487)*cj1))+(((1.23123596391001)*x159))+(((0.0886489894015208)*x166))+(((-0.196997754225602)*x161))+(((-0.0246247192782002)*sj1))+(((0.0886489894015208)*x157))+((x159*x163))+((x159*x160))+(((-4.92494385564005)*pp)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.74407923249675)+(((3.13226429218707)*x161))+(((-19.5766518261692)*x159))+(((78.3066073046767)*pp))+(((-48.353098774674)*x164))+(((-1.0)*x159*x162))+(((-1.0)*x159*x165))+(((-1.40951893148418)*x166))+(((-1.40951893148418)*x157))+(((6.04413734683425)*cj1))+(((0.391533036523384)*sj1))+(((19.5766518261692)*x158))+((x158*x162))+((x158*x165))))+IKsqr(((-1.02164020330168)+(((-1.23123596391001)*x158))+(((-1.0)*x158*x160))+(((-1.0)*x158*x163))+(((6.1857294826839)*x164))+(((-0.773216185335487)*cj1))+(((1.23123596391001)*x159))+(((0.0886489894015208)*x166))+(((-0.196997754225602)*x161))+(((-0.0246247192782002)*sj1))+(((0.0886489894015208)*x157))+((x159*x163))+((x159*x160))+(((-4.92494385564005)*pp))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((0.74407923249675)+(((3.13226429218707)*x161))+(((-19.5766518261692)*x159))+(((78.3066073046767)*pp))+(((-48.353098774674)*x164))+(((-1.0)*x159*x162))+(((-1.0)*x159*x165))+(((-1.40951893148418)*x166))+(((-1.40951893148418)*x157))+(((6.04413734683425)*cj1))+(((0.391533036523384)*sj1))+(((19.5766518261692)*x158))+((x158*x162))+((x158*x165))), ((-1.02164020330168)+(((-1.23123596391001)*x158))+(((-1.0)*x158*x160))+(((-1.0)*x158*x163))+(((6.1857294826839)*x164))+(((-0.773216185335487)*cj1))+(((1.23123596391001)*x159))+(((0.0886489894015208)*x166))+(((-0.196997754225602)*x161))+(((-0.0246247192782002)*sj1))+(((0.0886489894015208)*x157))+((x159*x163))+((x159*x160))+(((-4.92494385564005)*pp))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[2];
IkReal x167=IKcos(j3);
IkReal x168=IKsin(j3);
IkReal x169=(px*sj0);
IkReal x170=(cj0*py);
IkReal x171=((0.04)*sj1);
evalcond[0]=((-0.31)+(((-0.02)*x168))+(((-0.318)*x167))+(((-1.0)*cj1*x170))+((cj1*x169))+((pz*sj1))+(((-0.125)*cj1)));
evalcond[1]=((0.181918)+(((0.018)*cj0*px))+(((0.25)*x169))+(((0.02512)*x168))+((x169*x171))+(((0.19636)*x167))+(((-1.0)*x170*x171))+(((-1.0)*pp))+(((-0.25)*x170))+(((0.018)*py*sj0))+(((-0.005)*sj1))+(((-0.04)*cj1*pz)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j2eval[3];
IkReal x172=((1.0)*cj0);
j2eval[0]=((1.0)+(((15.9)*sj3))+(((-1.0)*cj3)));
j2eval[1]=IKsign(((0.02)+(((0.318)*sj3))+(((-0.02)*cj3))));
j2eval[2]=((IKabs(((0.009)+(((-1.0)*px*x172))+(((-1.0)*py*sj0)))))+(IKabs(((-0.02)+((px*sj0*sj1))+(((-1.0)*cj1*pz))+(((-1.0)*py*sj1*x172))+(((-0.125)*sj1))))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[2];
IkReal x173=((15.9)*sj3);
IkReal x174=((1.0)*cj3);
IkReal x175=((1766.66666666667)*sj3);
IkReal x176=(py*sj0);
IkReal x177=((1.0)+x173);
IkReal x178=((111.111111111111)*cj0*px);
j2eval[0]=((((-1.0)*x174))+x177);
j2eval[1]=((((-1.0)*x175*x176))+(((-1.0)*x178))+(((-1.0)*x174))+(((111.111111111111)*cj3*x176))+((cj3*x178))+x177+(((-1.0)*cj0*px*x175))+(((-111.111111111111)*x176)));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  )
{
{
IkReal j2eval[2];
IkReal x179=((15.9)*sj3);
IkReal x180=((50.0)*sj1);
IkReal x181=(px*sj0);
IkReal x182=(sj1*sj3);
IkReal x183=(cj0*py);
IkReal x184=((6.25)*sj1);
IkReal x185=((50.0)*cj1*pz);
j2eval[0]=((1.0)+x179+(((-1.0)*cj3)));
j2eval[1]=((-1.0)+((cj3*x180*x183))+((x180*x181))+(((-1.0)*cj3*x180*x181))+cj3+(((795.0)*x181*x182))+(((-1.0)*x179))+(((-1.0)*x185))+(((-1.0)*x184))+(((-795.0)*x182*x183))+(((-1.0)*x180*x183))+((cj3*x185))+((cj3*x184))+(((-795.0)*cj1*pz*sj3))+(((-99.375)*x182)));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
IkReal x186=(cj0*px);
IkReal x187=(cj1*pz);
IkReal x188=(py*sj0);
IkReal x189=(px*sj0);
IkReal x190=(cj0*py);
IkReal x191=(sj1*x190);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));
evalcond[1]=((-0.009)+x186+x188);
evalcond[2]=((-0.628)+((cj1*x189))+((pz*sj1))+(((-1.0)*cj1*x190))+(((-0.125)*cj1)));
evalcond[3]=((-0.02)+(((-1.0)*x191))+((sj1*x189))+(((-1.0)*x187))+(((-0.125)*sj1)));
evalcond[4]=((0.378278)+(((0.25)*x189))+(((-1.0)*pp))+(((-0.25)*x190))+(((0.04)*sj1*x189))+(((-0.005)*sj1))+(((-0.04)*x187))+(((-0.04)*x191))+(((0.018)*x188))+(((0.018)*x186)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[2];
sj3=0;
cj3=1.0;
j3=0;
IkReal x192=cj1*cj1;
IkReal x193=py*py;
IkReal x194=px*px;
IkReal x195=cj0*cj0;
IkReal x196=pz*pz;
IkReal x197=(cj0*px);
IkReal x198=(py*sj0);
IkReal x199=(cj0*py);
IkReal x200=((8.0)*sj1);
IkReal x201=(px*sj0);
IkReal x202=(cj1*pz);
IkReal x203=((0.0016)*sj1);
IkReal x204=((0.04)*x193);
IkReal x205=((200.0)*x195);
IkReal x206=(sj1*x202);
IkReal x207=((50.0)*x192);
IkReal x208=((0.01)*x192);
IkReal x209=(x192*x194);
IkReal x210=(x192*x196);
j2eval[0]=((-3.2212)+(((-400.0)*x199*x206))+(((-1.0)*sj1))+(((-200.0)*x210))+(((-1.0)*x201*x207))+(((-50.0)*x206))+((x200*x201))+(((-8.0)*x202))+(((200.0)*x209))+(((-400.0)*x192*x197*x198))+(((3.6)*x197))+(((3.6)*x198))+(((3.125)*x192))+(((-200.0)*x193))+(((-200.0)*x194))+(((400.0)*x201*x206))+((x192*x193*x205))+(((-1.0)*x205*x209))+(((-1.0)*x199*x200))+(((50.0)*x201))+(((-50.0)*x199))+((x199*x207)));
j2eval[1]=IKsign(((-0.00064424)+(((0.08)*x201*x206))+(((-0.08)*x199*x206))+(((-0.04)*x195*x209))+(((0.00072)*x198))+(((0.00072)*x197))+(((-1.0)*x201*x208))+(((-0.01)*x206))+(((-0.0002)*sj1))+(((-0.01)*x199))+((x192*x195*x204))+((x201*x203))+(((-0.04)*x210))+(((-1.0)*x204))+(((0.01)*x201))+(((-1.0)*x199*x203))+(((0.000625)*x192))+((x199*x208))+(((-0.0016)*x202))+(((-0.04)*x194))+(((-0.08)*x192*x197*x198))+(((0.04)*x209))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j2]

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x211 = IKatan2WithCheck(IkReal(((-9.9738e-5)+(((-0.62)*cj1*px*py))+(((0.08)*px*py*sj1*(cj0*cj0)))+(((0.011244)*cj0*px))+(((-0.62)*py*pz*sj0*sj1))+(((0.0775)*cj0*cj1*px))+(((0.005)*py*sj0*sj1))+(((0.011244)*py*sj0))+((pp*py*sj0))+(((0.00558)*cj1*px*sj0))+(((0.04)*cj1*py*pz*sj0))+(((0.0775)*cj1*py*sj0))+(((-0.25)*cj0*sj0*(px*px)))+(((0.00558)*pz*sj1))+(((1.24)*cj1*px*py*(cj0*cj0)))+(((-0.00225)*cj0*py))+(((-0.036)*cj0*px*py*sj0))+(((0.00225)*px*sj0))+(((0.04)*cj0*cj1*px*pz))+(((-0.018)*(cj0*cj0)*(px*px)))+(((-0.04)*cj0*sj0*sj1*(px*px)))+(((0.62)*cj0*cj1*sj0*(py*py)))+(((0.5)*px*py*(cj0*cj0)))+(((0.00036)*px*sj0*sj1))+(((-0.018)*(py*py)))+(((-0.009)*pp))+((cj0*pp*px))+(((0.04)*cj0*sj0*sj1*(py*py)))+(((-0.00036)*cj0*py*sj1))+(((-4.5e-5)*sj1))+(((-0.0006975)*cj1))+(((-0.25)*px*py))+(((0.25)*cj0*sj0*(py*py)))+(((-0.04)*px*py*sj1))+(((0.018)*(cj0*cj0)*(py*py)))+(((-0.62)*cj0*px*pz*sj1))+(((0.005)*cj0*px*sj1))+(((-0.00558)*cj0*cj1*py))+(((-0.00036)*cj1*pz))+(((-0.62)*cj0*cj1*sj0*(px*px))))),((0.00084664)+(((-0.00225)*py*sj0*sj1))+(((0.04)*(cj0*cj0)*(cj1*cj1)*(px*px)))+(((0.62)*cj1*sj1*(px*px)))+(((0.04)*(cj0*cj0)*(py*py)))+(((-0.04)*(cj0*cj0)*(px*px)))+(((0.25)*sj1*(cj0*cj0)*(py*py)))+(((-0.00036)*py*sj0))+(((0.00148525)*sj1))+(((-0.000625)*(cj1*cj1)))+(((-0.62)*cj0*py*pz))+(((-1.24)*cj0*cj1*px*py*sj0*sj1))+(((0.0124)*cj0*cj1*py))+(((-0.5)*cj0*px*py*sj0*sj1))+(((0.08)*cj0*cj1*py*pz*sj1))+(((0.01)*cj1*pz*sj1))+(((0.02)*pp))+(((-0.62)*cj1*sj1*(pz*pz)))+(((0.25)*cj0*cj1*py*pz))+(((-0.043132)*px*sj0*sj1))+(((0.155)*pz*(cj1*cj1)))+((cj0*pp*py*sj1))+(((-1.24)*px*pz*sj0*(cj1*cj1)))+(((0.015)*cj0*py))+(((-0.04)*(cj0*cj0)*(cj1*cj1)*(py*py)))+(((0.018)*cj0*sj0*sj1*(px*px)))+(((0.155)*cj0*cj1*py*sj1))+(((-0.015)*px*sj0))+(((0.08)*cj0*px*py*sj0*(cj1*cj1)))+((cj1*pp*pz))+(((0.01)*px*sj0*(cj1*cj1)))+(((-0.0775)*pz))+(((-0.036)*px*py*sj1*(cj0*cj0)))+(((0.011882)*cj1*pz))+(((-0.018)*cj1*py*pz*sj0))+(((-0.018)*cj0*sj0*sj1*(py*py)))+(((0.62)*px*pz*sj0))+(((0.25)*sj1*(px*px)))+(((0.00155)*cj1))+(((-0.155)*cj1*px*sj0*sj1))+(((-0.0124)*pz*sj1))+(((-0.00036)*cj0*px))+(((0.62)*cj1*sj1*(cj0*cj0)*(py*py)))+(((-0.018)*cj0*cj1*px*pz))+(((-1.0)*pp*px*sj0*sj1))+(((-0.62)*cj1*sj1*(cj0*cj0)*(px*px)))+(((-0.04)*(cj1*cj1)*(px*px)))+(((-0.0124)*cj1*px*sj0))+(((-0.25)*cj1*px*pz*sj0))+(((0.04)*(px*px)))+(((1.24)*cj0*py*pz*(cj1*cj1)))+(((0.018)*px*py*sj1))+(((-0.08)*cj0*px*py*sj0))+(((0.043132)*cj0*py*sj1))+(((0.125)*pp*sj1))+(((-0.25)*sj1*(cj0*cj0)*(px*px)))+(((-0.01)*cj0*py*(cj1*cj1)))+(((-0.00225)*cj0*px*sj1))+(((-0.08)*cj1*px*pz*sj0*sj1))+(((0.0096875)*cj1*sj1))+(((0.04)*(cj1*cj1)*(pz*pz)))),IKFAST_ATAN2_MAGTHRESH);
if(!x211.valid){
continue;
}
CheckValue<IkReal> x212=IKPowWithIntegerCheck(IKsign(((-0.00064424)+(((-0.04)*(cj1*cj1)*(pz*pz)))+(((-0.0016)*cj0*py*sj1))+(((-0.04)*(py*py)))+(((-0.01)*px*sj0*(cj1*cj1)))+(((-0.0002)*sj1))+(((0.00072)*py*sj0))+(((0.04)*(cj1*cj1)*(px*px)))+(((0.00072)*cj0*px))+(((-0.08)*cj0*cj1*py*pz*sj1))+(((-0.01)*cj1*pz*sj1))+(((0.0016)*px*sj0*sj1))+(((-0.04)*(px*px)))+(((-0.01)*cj0*py))+(((-0.0016)*cj1*pz))+(((0.01)*cj0*py*(cj1*cj1)))+(((-0.08)*cj0*px*py*sj0*(cj1*cj1)))+(((0.04)*(cj0*cj0)*(cj1*cj1)*(py*py)))+(((0.000625)*(cj1*cj1)))+(((0.01)*px*sj0))+(((-0.04)*(cj0*cj0)*(cj1*cj1)*(px*px)))+(((0.08)*cj1*px*pz*sj0*sj1)))),-1);
if(!x212.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(x211.value)+(((1.5707963267949)*(x212.value))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[3];
IkReal x213=IKsin(j2);
IkReal x214=IKcos(j2);
IkReal x215=((0.62)*cj1);
IkReal x216=(px*sj0);
IkReal x217=(py*sj1);
IkReal x218=((0.125)*sj1);
IkReal x219=(cj0*py);
IkReal x220=(py*sj0);
IkReal x221=(cj1*pz);
IkReal x222=((0.04)*cj0);
IkReal x223=(cj0*x213);
IkReal x224=((1.0)*x220);
IkReal x225=(sj1*x214);
IkReal x226=((1.0)*cj0*x214);
evalcond[0]=(((x213*x218))+(((-1.0)*x214*x224))+((x213*x221))+((x217*x223))+(((-1.0)*px*x226))+(((0.02)*x213))+(((0.009)*x214))+(((-1.0)*sj1*x213*x216)));
evalcond[1]=(((x216*x225))+(((-1.0)*px*x223))+(((-0.02)*x214))+(((-1.0)*x213*x224))+(((-1.0)*x217*x226))+(((-1.0)*x214*x218))+(((0.009)*x213))+(((-1.0)*x214*x221)));
evalcond[2]=((-0.011082)+(((0.018)*cj0*px))+(((0.018)*x220))+(((-1.0)*x214*x217*x222))+(((-0.005)*x225))+(((0.04)*x216*x225))+(((-0.04)*x214*x221))+(((0.00036)*x213))+((x215*x216))+(((-1.0)*px*x213*x222))+(((0.62)*pz*sj1))+(((-0.04)*x213*x220))+(((0.04)*sj1*x216))+(((-1.0)*pp))+(((-0.0008)*x214))+(((-0.005)*sj1))+(((-1.0)*x217*x222))+(((-0.25)*x219))+(((-0.04)*x221))+(((0.25)*x216))+(((-0.0775)*cj1))+(((-1.0)*x215*x219)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x635=(cj0*px);
IkReal x636=(cj1*pz);
IkReal x637=(py*sj0);
IkReal x638=(px*sj0);
IkReal x639=(cj0*py);
IkReal x640=(sj1*x639);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-5.84719389130854e-18)+j3)))), 6.28318530717959)));
evalcond[1]=((-0.009)+x637+x635);
evalcond[2]=((-0.628)+(((-1.0)*cj1*x639))+((pz*sj1))+(((-0.125)*cj1))+((cj1*x638)));
evalcond[3]=((-0.02)+(((-1.0)*x640))+((sj1*x638))+(((-1.0)*x636))+(((-0.125)*sj1)));
evalcond[4]=((0.378278)+(((-0.04)*x640))+(((0.25)*x638))+(((-1.0)*pp))+(((0.018)*x637))+(((0.018)*x635))+(((-0.005)*sj1))+(((-0.04)*x636))+(((-0.25)*x639))+(((0.04)*sj1*x638)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[2];
sj3=0;
cj3=1.0;
j3=3.58986287782067e-8;
IkReal x641=cj1*cj1;
IkReal x642=py*py;
IkReal x643=px*px;
IkReal x644=cj0*cj0;
IkReal x645=pz*pz;
IkReal x646=(cj0*px);
IkReal x647=(py*sj0);
IkReal x648=(cj0*py);
IkReal x649=((8.0)*sj1);
IkReal x650=(px*sj0);
IkReal x651=(cj1*pz);
IkReal x652=((0.0016)*sj1);
IkReal x653=((0.04)*x642);
IkReal x654=((200.0)*x644);
IkReal x655=(sj1*x651);
IkReal x656=((50.0)*x641);
IkReal x657=((0.01)*x641);
IkReal x658=(x641*x643);
IkReal x659=(x641*x645);
j2eval[0]=((-3.2212)+(((3.6)*x646))+(((3.6)*x647))+(((50.0)*x650))+(((-1.0)*sj1))+(((-400.0)*x648*x655))+(((-50.0)*x655))+(((-50.0)*x648))+((x649*x650))+((x648*x656))+(((-1.0)*x648*x649))+(((-1.0)*x650*x656))+(((400.0)*x650*x655))+(((-200.0)*x643))+(((-200.0)*x642))+(((-200.0)*x659))+(((200.0)*x658))+(((3.125)*x641))+(((-8.0)*x651))+(((-400.0)*x641*x646*x647))+(((-1.0)*x654*x658))+((x641*x642*x654)));
j2eval[1]=IKsign(((-0.00064424)+(((-0.08)*x648*x655))+(((-0.01)*x655))+(((-0.01)*x648))+(((-0.0016)*x651))+(((-0.0002)*sj1))+(((-0.04)*x643))+(((-0.04)*x644*x658))+((x641*x644*x653))+(((0.000625)*x641))+(((-0.04)*x659))+(((-0.08)*x641*x646*x647))+((x648*x657))+(((-1.0)*x653))+(((0.04)*x658))+(((0.00072)*x646))+(((0.00072)*x647))+(((0.01)*x650))+(((0.08)*x650*x655))+(((-1.0)*x650*x657))+(((-1.0)*x648*x652))+((x650*x652))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j2]

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x660 = IKatan2WithCheck(IkReal(((-9.9738e-5)+(((-0.62)*cj1*px*py))+(((0.08)*px*py*sj1*(cj0*cj0)))+(((0.011244)*cj0*px))+(((-0.62)*py*pz*sj0*sj1))+(((0.0775)*cj0*cj1*px))+(((0.005)*py*sj0*sj1))+(((0.011244)*py*sj0))+((pp*py*sj0))+(((0.00558)*cj1*px*sj0))+(((0.04)*cj1*py*pz*sj0))+(((0.0775)*cj1*py*sj0))+(((-0.25)*cj0*sj0*(px*px)))+(((0.00558)*pz*sj1))+(((1.24)*cj1*px*py*(cj0*cj0)))+(((-0.00225)*cj0*py))+(((-0.036)*cj0*px*py*sj0))+(((0.00225)*px*sj0))+(((0.04)*cj0*cj1*px*pz))+(((-0.018)*(cj0*cj0)*(px*px)))+(((-0.04)*cj0*sj0*sj1*(px*px)))+(((0.62)*cj0*cj1*sj0*(py*py)))+(((0.5)*px*py*(cj0*cj0)))+(((0.00036)*px*sj0*sj1))+(((-0.018)*(py*py)))+(((-0.009)*pp))+((cj0*pp*px))+(((0.04)*cj0*sj0*sj1*(py*py)))+(((-0.00036)*cj0*py*sj1))+(((-4.5e-5)*sj1))+(((-0.0006975)*cj1))+(((-0.25)*px*py))+(((0.25)*cj0*sj0*(py*py)))+(((-0.04)*px*py*sj1))+(((0.018)*(cj0*cj0)*(py*py)))+(((-0.62)*cj0*px*pz*sj1))+(((0.005)*cj0*px*sj1))+(((-0.00558)*cj0*cj1*py))+(((-0.00036)*cj1*pz))+(((-0.62)*cj0*cj1*sj0*(px*px))))),((0.00084664)+(((-0.00225)*py*sj0*sj1))+(((0.04)*(cj0*cj0)*(cj1*cj1)*(px*px)))+(((0.62)*cj1*sj1*(px*px)))+(((0.04)*(cj0*cj0)*(py*py)))+(((-0.04)*(cj0*cj0)*(px*px)))+(((0.25)*sj1*(cj0*cj0)*(py*py)))+(((-0.00036)*py*sj0))+(((0.00148525)*sj1))+(((-0.000625)*(cj1*cj1)))+(((-0.62)*cj0*py*pz))+(((-1.24)*cj0*cj1*px*py*sj0*sj1))+(((0.0124)*cj0*cj1*py))+(((-0.5)*cj0*px*py*sj0*sj1))+(((0.08)*cj0*cj1*py*pz*sj1))+(((0.01)*cj1*pz*sj1))+(((0.02)*pp))+(((-0.62)*cj1*sj1*(pz*pz)))+(((0.25)*cj0*cj1*py*pz))+(((-0.043132)*px*sj0*sj1))+(((0.155)*pz*(cj1*cj1)))+((cj0*pp*py*sj1))+(((-1.24)*px*pz*sj0*(cj1*cj1)))+(((0.015)*cj0*py))+(((-0.04)*(cj0*cj0)*(cj1*cj1)*(py*py)))+(((0.018)*cj0*sj0*sj1*(px*px)))+(((0.155)*cj0*cj1*py*sj1))+(((-0.015)*px*sj0))+(((0.08)*cj0*px*py*sj0*(cj1*cj1)))+((cj1*pp*pz))+(((0.01)*px*sj0*(cj1*cj1)))+(((-0.0775)*pz))+(((-0.036)*px*py*sj1*(cj0*cj0)))+(((0.011882)*cj1*pz))+(((-0.018)*cj1*py*pz*sj0))+(((-0.018)*cj0*sj0*sj1*(py*py)))+(((0.62)*px*pz*sj0))+(((0.25)*sj1*(px*px)))+(((0.00155)*cj1))+(((-0.155)*cj1*px*sj0*sj1))+(((-0.0124)*pz*sj1))+(((-0.00036)*cj0*px))+(((0.62)*cj1*sj1*(cj0*cj0)*(py*py)))+(((-0.018)*cj0*cj1*px*pz))+(((-1.0)*pp*px*sj0*sj1))+(((-0.62)*cj1*sj1*(cj0*cj0)*(px*px)))+(((-0.04)*(cj1*cj1)*(px*px)))+(((-0.0124)*cj1*px*sj0))+(((-0.25)*cj1*px*pz*sj0))+(((0.04)*(px*px)))+(((1.24)*cj0*py*pz*(cj1*cj1)))+(((0.018)*px*py*sj1))+(((-0.08)*cj0*px*py*sj0))+(((0.043132)*cj0*py*sj1))+(((0.125)*pp*sj1))+(((-0.25)*sj1*(cj0*cj0)*(px*px)))+(((-0.01)*cj0*py*(cj1*cj1)))+(((-0.00225)*cj0*px*sj1))+(((-0.08)*cj1*px*pz*sj0*sj1))+(((0.0096875)*cj1*sj1))+(((0.04)*(cj1*cj1)*(pz*pz)))),IKFAST_ATAN2_MAGTHRESH);
if(!x660.valid){
continue;
}
CheckValue<IkReal> x661=IKPowWithIntegerCheck(IKsign(((-0.00064424)+(((-0.04)*(cj1*cj1)*(pz*pz)))+(((-0.0016)*cj0*py*sj1))+(((-0.04)*(py*py)))+(((-0.01)*px*sj0*(cj1*cj1)))+(((-0.0002)*sj1))+(((0.00072)*py*sj0))+(((0.04)*(cj1*cj1)*(px*px)))+(((0.00072)*cj0*px))+(((-0.08)*cj0*cj1*py*pz*sj1))+(((-0.01)*cj1*pz*sj1))+(((0.0016)*px*sj0*sj1))+(((-0.04)*(px*px)))+(((-0.01)*cj0*py))+(((-0.0016)*cj1*pz))+(((0.01)*cj0*py*(cj1*cj1)))+(((-0.08)*cj0*px*py*sj0*(cj1*cj1)))+(((0.04)*(cj0*cj0)*(cj1*cj1)*(py*py)))+(((0.000625)*(cj1*cj1)))+(((0.01)*px*sj0))+(((-0.04)*(cj0*cj0)*(cj1*cj1)*(px*px)))+(((0.08)*cj1*px*pz*sj0*sj1)))),-1);
if(!x661.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(x660.value)+(((1.5707963267949)*(x661.value))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[3];
IkReal x662=IKsin(j2);
IkReal x663=IKcos(j2);
IkReal x664=((0.62)*cj1);
IkReal x665=(px*sj0);
IkReal x666=(py*sj1);
IkReal x667=((0.125)*sj1);
IkReal x668=(cj0*py);
IkReal x669=(py*sj0);
IkReal x670=(cj1*pz);
IkReal x671=((0.04)*cj0);
IkReal x672=(cj0*x662);
IkReal x673=((1.0)*x669);
IkReal x674=(sj1*x663);
IkReal x675=((1.0)*cj0*x663);
evalcond[0]=((((0.009)*x663))+((x662*x670))+((x662*x667))+(((-1.0)*x663*x673))+((x666*x672))+(((-1.0)*px*x675))+(((0.02)*x662))+(((-1.0)*sj1*x662*x665)));
evalcond[1]=(((x665*x674))+(((0.009)*x662))+(((-1.0)*x663*x667))+(((-1.0)*x662*x673))+(((-1.0)*px*x672))+(((-1.0)*x666*x675))+(((-1.0)*x663*x670))+(((-0.02)*x663)));
evalcond[2]=((-0.011082)+(((0.018)*cj0*px))+(((0.018)*x669))+(((-0.04)*x662*x669))+((x664*x665))+(((0.25)*x665))+(((0.04)*sj1*x665))+(((0.62)*pz*sj1))+(((-0.0008)*x663))+(((-1.0)*x663*x666*x671))+(((-1.0)*pp))+(((0.00036)*x662))+(((-1.0)*x666*x671))+(((-0.25)*x668))+(((-1.0)*px*x662*x671))+(((-0.04)*x670))+(((-0.005)*x674))+(((-0.005)*sj1))+(((0.04)*x665*x674))+(((-0.04)*x663*x670))+(((-1.0)*x664*x668))+(((-0.0775)*cj1)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x676=(px*sj0);
IkReal x677=(cj0*py);
IkReal x678=((0.04)*sj1);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.26721335889799)+j3)))), 6.28318530717959)));
evalcond[1]=((0.00799999885047098)+((pz*sj1))+(((-1.0)*cj1*x677))+(((-0.125)*cj1))+((cj1*x676)));
evalcond[2]=((-0.0160419992903604)+(((0.018)*cj0*px))+(((-0.25)*x677))+((x676*x678))+(((-1.0)*pp))+(((0.018)*py*sj0))+(((-0.005)*sj1))+(((-0.04)*cj1*pz))+(((0.25)*x676))+(((-1.0)*x677*x678)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x679=((13036080734.8056)*py);
IkReal x680=((13036080734.8056)*px);
if( IKabs(((-117324726.61325)+((cj0*x680))+((sj0*x679)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((260721614.696111)+(((13036080734.8056)*cj1*pz))+(((-1.0)*sj0*sj1*x680))+(((1629510091.8507)*sj1))+((cj0*sj1*x679)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-117324726.61325)+((cj0*x680))+((sj0*x679))))+IKsqr(((260721614.696111)+(((13036080734.8056)*cj1*pz))+(((-1.0)*sj0*sj1*x680))+(((1629510091.8507)*sj1))+((cj0*sj1*x679))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((-117324726.61325)+((cj0*x680))+((sj0*x679))), ((260721614.696111)+(((13036080734.8056)*cj1*pz))+(((-1.0)*sj0*sj1*x680))+(((1629510091.8507)*sj1))+((cj0*sj1*x679))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[5];
IkReal x681=IKcos(j2);
IkReal x682=IKsin(j2);
IkReal x683=((0.62)*cj1);
IkReal x684=(px*sj0);
IkReal x685=(py*sj1);
IkReal x686=((0.125)*sj1);
IkReal x687=(cj0*py);
IkReal x688=(py*sj0);
IkReal x689=(cj0*px);
IkReal x690=(cj1*pz);
IkReal x691=(cj0*x682);
IkReal x692=((1.0)*x688);
IkReal x693=((1.0)*x690);
IkReal x694=(sj1*x681);
IkReal x695=((0.04)*x681);
IkReal x696=((1.0)*cj0*x681);
evalcond[0]=((-0.009)+(((-7.67101723549516e-11)*x682))+x689+x688);
evalcond[1]=((-0.02)+(((7.67101723549516e-11)*x681))+(((-1.0)*x686))+(((-1.0)*cj0*x685))+(((-1.0)*x693))+((sj1*x684)));
evalcond[2]=(((x682*x690))+(((-1.0)*x681*x689))+((x682*x686))+(((-1.0)*sj1*x682*x684))+(((0.02)*x682))+(((0.009)*x681))+((x685*x691))+(((-1.0)*x681*x692)));
evalcond[3]=((7.67101723549516e-11)+(((-1.0)*x681*x686))+((x684*x694))+(((-0.02)*x681))+(((-1.0)*x682*x692))+(((-1.0)*x685*x696))+(((0.009)*x682))+(((-1.0)*x681*x693))+(((-1.0)*x682*x689)));
evalcond[4]=((-0.011082)+(((-0.005)*x694))+(((-0.04)*x690))+((x683*x684))+(((0.62)*pz*sj1))+(((0.018)*x688))+(((0.018)*x689))+(((-1.0)*cj0*x685*x695))+(((-1.0)*pp))+(((-0.04)*cj0*x685))+(((0.25)*x684))+(((0.04)*x684*x694))+(((0.04)*sj1*x684))+(((-0.005)*sj1))+(((-1.0)*x690*x695))+(((-0.04)*x682*x689))+(((-0.04)*x682*x688))+(((-1.0)*x683*x687))+(((0.00036)*x682))+(((-0.0008)*x681))+(((-0.25)*x687))+(((-0.0775)*cj1)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j2]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x697=py*py;
IkReal x698=cj0*cj0;
IkReal x699=(px*sj0);
IkReal x700=((0.0025)*sj1);
IkReal x701=(cj0*py);
IkReal x702=((0.02)*sj1);
IkReal x703=((0.01272)*sj3);
IkReal x704=(cj1*pz);
IkReal x705=((0.318)*sj3);
IkReal x706=(py*sj0);
IkReal x707=(cj0*px);
IkReal x708=((0.02)*cj3);
IkReal x709=(sj1*x705);
CheckValue<IkReal> x710=IKPowWithIntegerCheck(((0.02)+(((-1.0)*x708))+x705),-1);
if(!x710.valid){
continue;
}
CheckValue<IkReal> x711=IKPowWithIntegerCheck(((-0.0004)+(((-0.00636)*sj3))+(((0.0004)*cj3))+(((-0.02)*x704))+(((-1.0)*x700))+(((-1.0)*x704*x705))+((x704*x708))+(((-1.0)*cj3*x699*x702))+(((-0.03975)*sj1*sj3))+((cj3*x701*x702))+((cj3*x700))+(((-1.0)*x701*x709))+(((-1.0)*x701*x702))+((x699*x702))+((x699*x709))),-1);
if(!x711.valid){
continue;
}
if( IKabs(((x710.value)*(((0.009)+(((-1.0)*x706))+(((-1.0)*x707)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x711.value)*(((0.101443)+(((0.018)*x706))+(((0.018)*x707))+(((-2.0)*x699*x701))+((x697*x698))+(((-0.0008)*cj3))+(((-0.100724)*(cj3*cj3)))+(((-1.0)*cj3*x703))+(((-1.0)*x698*(px*px)))+x703+(((-1.0)*x697)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x710.value)*(((0.009)+(((-1.0)*x706))+(((-1.0)*x707))))))+IKsqr(((x711.value)*(((0.101443)+(((0.018)*x706))+(((0.018)*x707))+(((-2.0)*x699*x701))+((x697*x698))+(((-0.0008)*cj3))+(((-0.100724)*(cj3*cj3)))+(((-1.0)*cj3*x703))+(((-1.0)*x698*(px*px)))+x703+(((-1.0)*x697))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((x710.value)*(((0.009)+(((-1.0)*x706))+(((-1.0)*x707))))), ((x711.value)*(((0.101443)+(((0.018)*x706))+(((0.018)*x707))+(((-2.0)*x699*x701))+((x697*x698))+(((-0.0008)*cj3))+(((-0.100724)*(cj3*cj3)))+(((-1.0)*cj3*x703))+(((-1.0)*x698*(px*px)))+x703+(((-1.0)*x697))))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[5];
IkReal x712=IKsin(j2);
IkReal x713=IKcos(j2);
IkReal x714=((0.62)*cj1);
IkReal x715=(px*sj0);
IkReal x716=(py*sj1);
IkReal x717=((0.125)*sj1);
IkReal x718=((0.318)*sj3);
IkReal x719=(cj0*py);
IkReal x720=(py*sj0);
IkReal x721=((0.005)*sj1);
IkReal x722=(cj1*pz);
IkReal x723=(cj0*px);
IkReal x724=((0.02)*x712);
IkReal x725=((0.02)*x713);
IkReal x726=(cj0*x712);
IkReal x727=((1.0)*x713);
IkReal x728=((1.0)*x712);
IkReal x729=(sj1*x713);
IkReal x730=((0.04)*x713);
IkReal x731=(cj0*x727);
evalcond[0]=((-0.009)+(((-1.0)*cj3*x724))+x720+x723+x724+((x712*x718)));
evalcond[1]=((-0.02)+(((-1.0)*x725))+(((-1.0)*x722))+(((-1.0)*cj0*x716))+(((-1.0)*x717))+((sj1*x715))+((cj3*x725))+(((-1.0)*x713*x718)));
evalcond[2]=(((x712*x722))+(((-1.0)*x723*x727))+(((-1.0)*x720*x727))+(((0.009)*x713))+x724+(((-1.0)*sj1*x715*x728))+((x712*x717))+((x716*x726)));
evalcond[3]=((-0.02)+(((-1.0)*x723*x728))+(((-1.0)*x722*x727))+(((0.02)*cj3))+(((-1.0)*x725))+(((-1.0)*x718))+(((-1.0)*x716*x731))+(((-1.0)*x720*x728))+(((0.009)*x712))+(((-1.0)*x713*x717))+((x715*x729)));
evalcond[4]=((-0.011082)+(((-0.04)*x712*x720))+(((-0.04)*x712*x723))+(((-1.0)*x714*x719))+(((-1.0)*x713*x721))+(((0.04)*x715*x729))+((x714*x715))+(((-0.0008)*x713))+(((0.00036)*x712))+(((-0.25)*x719))+(((-0.04)*x722))+(((-1.0)*x722*x730))+(((0.62)*pz*sj1))+(((-1.0)*x721))+(((-0.04)*cj0*x716))+(((-1.0)*pp))+(((0.04)*sj1*x715))+(((-1.0)*cj0*x716*x730))+(((0.25)*x715))+(((0.018)*x720))+(((0.018)*x723))+(((-0.0775)*cj1)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x732=(py*sj0);
IkReal x733=(cj1*pz);
IkReal x734=(py*sj1);
IkReal x735=(cj0*px);
IkReal x736=((0.125)*sj1);
IkReal x737=((0.02)*cj3);
IkReal x738=(sj0*sj1);
IkReal x739=((0.318)*sj3);
IkReal x740=((0.02)*x732);
IkReal x741=((0.02)*x735);
IkReal x742=(x740+x741);
CheckValue<IkReal> x743=IKPowWithIntegerCheck(((0.02)+(((-1.0)*x737))+x739),-1);
if(!x743.valid){
continue;
}
CheckValue<IkReal> x744=IKPowWithIntegerCheck(((0.00018)+(((-1.0)*x732*x739))+(((-1.0)*x735*x739))+((x735*x737))+(((0.002862)*sj3))+(((-1.0)*x742))+((x732*x737))+(((-0.00018)*cj3))),-1);
if(!x744.valid){
continue;
}
if( IKabs(((x743.value)*(((0.009)+(((-1.0)*x735))+(((-1.0)*x732)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x744.value)*(((-0.00018)+(((-0.009)*cj0*x734))+((x735*x736))+(((0.009)*px*x738))+(((-0.001125)*sj1))+((x733*x735))+(((2.0)*cj0*x734*x735))+(((-1.0)*px*x735*x738))+x742+(((-1.0)*px*x734))+(((-0.009)*x733))+((x732*x733))+((x732*x736))+((cj0*x732*x734)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x743.value)*(((0.009)+(((-1.0)*x735))+(((-1.0)*x732))))))+IKsqr(((x744.value)*(((-0.00018)+(((-0.009)*cj0*x734))+((x735*x736))+(((0.009)*px*x738))+(((-0.001125)*sj1))+((x733*x735))+(((2.0)*cj0*x734*x735))+(((-1.0)*px*x735*x738))+x742+(((-1.0)*px*x734))+(((-0.009)*x733))+((x732*x733))+((x732*x736))+((cj0*x732*x734))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((x743.value)*(((0.009)+(((-1.0)*x735))+(((-1.0)*x732))))), ((x744.value)*(((-0.00018)+(((-0.009)*cj0*x734))+((x735*x736))+(((0.009)*px*x738))+(((-0.001125)*sj1))+((x733*x735))+(((2.0)*cj0*x734*x735))+(((-1.0)*px*x735*x738))+x742+(((-1.0)*px*x734))+(((-0.009)*x733))+((x732*x733))+((x732*x736))+((cj0*x732*x734))))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[5];
IkReal x745=IKsin(j2);
IkReal x746=IKcos(j2);
IkReal x747=((0.62)*cj1);
IkReal x748=(px*sj0);
IkReal x749=(py*sj1);
IkReal x750=((0.125)*sj1);
IkReal x751=((0.318)*sj3);
IkReal x752=(cj0*py);
IkReal x753=(py*sj0);
IkReal x754=((0.005)*sj1);
IkReal x755=(cj1*pz);
IkReal x756=(cj0*px);
IkReal x757=((0.02)*x745);
IkReal x758=((0.02)*x746);
IkReal x759=(cj0*x745);
IkReal x760=((1.0)*x746);
IkReal x761=((1.0)*x745);
IkReal x762=(sj1*x746);
IkReal x763=((0.04)*x746);
IkReal x764=(cj0*x760);
evalcond[0]=((-0.009)+((x745*x751))+(((-1.0)*cj3*x757))+x757+x756+x753);
evalcond[1]=((-0.02)+(((-1.0)*cj0*x749))+(((-1.0)*x746*x751))+((sj1*x748))+((cj3*x758))+(((-1.0)*x755))+(((-1.0)*x750))+(((-1.0)*x758)));
evalcond[2]=(((x745*x750))+((x745*x755))+(((-1.0)*x756*x760))+(((-1.0)*x753*x760))+(((-1.0)*sj1*x748*x761))+x757+((x749*x759))+(((0.009)*x746)));
evalcond[3]=((-0.02)+(((-1.0)*x756*x761))+(((-1.0)*x755*x760))+(((-1.0)*x753*x761))+(((-1.0)*x746*x750))+(((0.02)*cj3))+((x748*x762))+(((-1.0)*x751))+(((-1.0)*x758))+(((0.009)*x745))+(((-1.0)*x749*x764)));
evalcond[4]=((-0.011082)+(((-0.04)*cj0*x749))+(((-0.04)*x745*x753))+(((-0.04)*x745*x756))+(((-1.0)*cj0*x749*x763))+((x747*x748))+(((-0.04)*x755))+(((0.62)*pz*sj1))+(((-1.0)*x755*x763))+(((-1.0)*x746*x754))+(((-1.0)*pp))+(((-0.0008)*x746))+(((-1.0)*x747*x752))+(((0.00036)*x745))+(((0.018)*x756))+(((0.018)*x753))+(((0.04)*x748*x762))+(((0.25)*x748))+(((-1.0)*x754))+(((-0.0775)*cj1))+(((0.04)*sj1*x748))+(((-0.25)*x752)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x765=((1.0)*cj0);
CheckValue<IkReal> x766=IKPowWithIntegerCheck(IKsign(((0.02)+(((0.318)*sj3))+(((-0.02)*cj3)))),-1);
if(!x766.valid){
continue;
}
CheckValue<IkReal> x767 = IKatan2WithCheck(IkReal(((0.009)+(((-1.0)*px*x765))+(((-1.0)*py*sj0)))),((-0.02)+((px*sj0*sj1))+(((-1.0)*cj1*pz))+(((-1.0)*py*sj1*x765))+(((-0.125)*sj1))),IKFAST_ATAN2_MAGTHRESH);
if(!x767.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x766.value)))+(x767.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[5];
IkReal x768=IKsin(j2);
IkReal x769=IKcos(j2);
IkReal x770=((0.62)*cj1);
IkReal x771=(px*sj0);
IkReal x772=(py*sj1);
IkReal x773=((0.125)*sj1);
IkReal x774=((0.318)*sj3);
IkReal x775=(cj0*py);
IkReal x776=(py*sj0);
IkReal x777=((0.005)*sj1);
IkReal x778=(cj1*pz);
IkReal x779=(cj0*px);
IkReal x780=((0.02)*x768);
IkReal x781=((0.02)*x769);
IkReal x782=(cj0*x768);
IkReal x783=((1.0)*x769);
IkReal x784=((1.0)*x768);
IkReal x785=(sj1*x769);
IkReal x786=((0.04)*x769);
IkReal x787=(cj0*x783);
evalcond[0]=((-0.009)+(((-1.0)*cj3*x780))+x776+x779+x780+((x768*x774)));
evalcond[1]=((-0.02)+(((-1.0)*cj0*x772))+(((-1.0)*x781))+((sj1*x771))+(((-1.0)*x769*x774))+(((-1.0)*x773))+(((-1.0)*x778))+((cj3*x781)));
evalcond[2]=((((-1.0)*sj1*x771*x784))+(((0.009)*x769))+(((-1.0)*x776*x783))+x780+((x772*x782))+((x768*x778))+((x768*x773))+(((-1.0)*x779*x783)));
evalcond[3]=((-0.02)+(((-1.0)*x781))+(((0.009)*x768))+(((0.02)*cj3))+(((-1.0)*x776*x784))+(((-1.0)*x772*x787))+(((-1.0)*x769*x773))+(((-1.0)*x774))+((x771*x785))+(((-1.0)*x778*x783))+(((-1.0)*x779*x784)));
evalcond[4]=((-0.011082)+(((0.00036)*x768))+(((-0.25)*x775))+((x770*x771))+(((-1.0)*cj0*x772*x786))+(((-0.04)*cj0*x772))+(((0.62)*pz*sj1))+(((0.04)*x771*x785))+(((-1.0)*pp))+(((-0.04)*x778))+(((-0.0008)*x769))+(((-1.0)*x769*x777))+(((0.018)*x776))+(((0.018)*x779))+(((-0.04)*x768*x779))+(((-0.04)*x768*x776))+(((-1.0)*x777))+(((0.25)*x771))+(((0.04)*sj1*x771))+(((-1.0)*x778*x786))+(((-1.0)*x770*x775))+(((-0.0775)*cj1)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}
    }
}
return solutions.GetNumSolutions()>0;
}
inline void rotationfunction0(IkSolutionListBase<IkReal>& solutions) {
for(int rotationiter = 0; rotationiter < 1; ++rotationiter) {
IkReal x227=(cj3*sj1);
IkReal x228=(sj0*sj2);
IkReal x229=((1.0)*sj3);
IkReal x230=(cj1*cj3);
IkReal x231=(cj0*sj2);
IkReal x232=((1.0)*cj1*sj2);
IkReal x233=(((cj2*sj0))+(((-1.0)*sj1*x231)));
IkReal x234=(((cj0*cj2))+((sj1*x228)));
IkReal x235=(((cj2*x227))+(((-1.0)*cj1*x229)));
IkReal x236=(((cj2*x230))+((sj1*sj3)));
IkReal x237=((((-1.0)*cj1*cj2*x229))+x227);
IkReal x238=((((-1.0)*cj2*sj1*x229))+(((-1.0)*x230)));
IkReal x239=(((cj3*x228))+((cj0*x235)));
IkReal x240=(((cj3*x231))+(((-1.0)*sj0*x235)));
IkReal x241=((((-1.0)*x228*x229))+((cj0*x238)));
IkReal x242=((((-1.0)*sj0*x238))+(((-1.0)*sj3*x231)));
new_r00=(((r10*x233))+((r00*x234))+(((-1.0)*r20*x232)));
new_r01=(((r11*x233))+((r01*x234))+(((-1.0)*r21*x232)));
new_r02=(((r02*x234))+(((-1.0)*r22*x232))+((r12*x233)));
new_r10=(((r10*x239))+((r20*x236))+((r00*x240)));
new_r11=(((r11*x239))+((r01*x240))+((r21*x236)));
new_r12=(((r02*x240))+((r12*x239))+((r22*x236)));
new_r20=(((r20*x237))+((r00*x242))+((r10*x241)));
new_r21=(((r01*x242))+((r11*x241))+((r21*x237)));
new_r22=(((r02*x242))+((r12*x241))+((r22*x237)));
{
IkReal j5array[2], cj5array[2], sj5array[2];
bool j5valid[2]={false};
_nj5 = 2;
cj5array[0]=new_r22;
if( cj5array[0] >= -1-IKFAST_SINCOS_THRESH && cj5array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j5valid[0] = j5valid[1] = true;
    j5array[0] = IKacos(cj5array[0]);
    sj5array[0] = IKsin(j5array[0]);
    cj5array[1] = cj5array[0];
    j5array[1] = -j5array[0];
    sj5array[1] = -sj5array[0];
}
else if( isnan(cj5array[0]) )
{
    // probably any value will work
    j5valid[0] = true;
    cj5array[0] = 1; sj5array[0] = 0; j5array[0] = 0;
}
for(int ij5 = 0; ij5 < 2; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 2; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
IkReal j4eval[2];
IkReal x243=(cj3*sj1);
IkReal x244=(sj0*sj2);
IkReal x245=((1.0)*sj3);
IkReal x246=(cj1*cj3);
IkReal x247=(cj0*sj2);
IkReal x248=((1.0)*cj1*sj2);
IkReal x249=x233;
IkReal x250=x234;
IkReal x251=x235;
IkReal x252=x236;
IkReal x253=x237;
IkReal x254=x238;
IkReal x255=(((cj0*x251))+((cj3*x244)));
IkReal x256=((((-1.0)*sj0*x251))+((cj3*x247)));
IkReal x257=(((cj0*x254))+(((-1.0)*x244*x245)));
IkReal x258=((((-1.0)*sj0*x254))+(((-1.0)*sj3*x247)));
new_r00=(((r00*x250))+((r10*x249))+(((-1.0)*r20*x248)));
new_r01=(((r01*x250))+((r11*x249))+(((-1.0)*r21*x248)));
new_r02=(((r12*x249))+(((-1.0)*r22*x248))+((r02*x250)));
new_r10=(((r20*x252))+((r00*x256))+((r10*x255)));
new_r11=(((r21*x252))+((r11*x255))+((r01*x256)));
new_r12=(((r12*x255))+((r22*x252))+((r02*x256)));
new_r20=(((r20*x253))+((r00*x258))+((r10*x257)));
new_r21=(((r21*x253))+((r11*x257))+((r01*x258)));
new_r22=(((r12*x257))+((r22*x253))+((r02*x258)));
j4eval[0]=sj5;
j4eval[1]=IKsign(sj5);
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
{
IkReal j4eval[1];
IkReal x259=(cj3*sj1);
IkReal x260=(sj0*sj2);
IkReal x261=((1.0)*sj3);
IkReal x262=(cj1*cj3);
IkReal x263=(cj0*sj2);
IkReal x264=((1.0)*cj1*sj2);
IkReal x265=x233;
IkReal x266=x234;
IkReal x267=x235;
IkReal x268=x236;
IkReal x269=x237;
IkReal x270=x238;
IkReal x271=(((cj0*x267))+((cj3*x260)));
IkReal x272=((((-1.0)*sj0*x267))+((cj3*x263)));
IkReal x273=((((-1.0)*x260*x261))+((cj0*x270)));
IkReal x274=((((-1.0)*sj0*x270))+(((-1.0)*sj3*x263)));
new_r00=(((r00*x266))+((r10*x265))+(((-1.0)*r20*x264)));
new_r01=(((r11*x265))+((r01*x266))+(((-1.0)*r21*x264)));
new_r02=(((r02*x266))+((r12*x265))+(((-1.0)*r22*x264)));
new_r10=(((r00*x272))+((r10*x271))+((r20*x268)));
new_r11=(((r21*x268))+((r01*x272))+((r11*x271)));
new_r12=(((r02*x272))+((r22*x268))+((r12*x271)));
new_r20=(((r00*x274))+((r10*x273))+((r20*x269)));
new_r21=(((r21*x269))+((r01*x274))+((r11*x273)));
new_r22=(((r02*x274))+((r22*x269))+((r12*x273)));
j4eval[0]=sj5;
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[6];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j5))), 6.28318530717959)));
evalcond[1]=((-1.0)+new_r22);
evalcond[2]=new_r20;
evalcond[3]=new_r02;
evalcond[4]=new_r12;
evalcond[5]=new_r21;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[2], cj4array[2], sj4array[2];
bool j4valid[2]={false};
_nj4 = 2;
CheckValue<IkReal> x276 = IKatan2WithCheck(IkReal(new_r02),new_r12,IKFAST_ATAN2_MAGTHRESH);
if(!x276.valid){
continue;
}
IkReal x275=x276.value;
j4array[0]=((-1.0)*x275);
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
j4array[1]=((3.14159265358979)+(((-1.0)*x275)));
sj4array[1]=IKsin(j4array[1]);
cj4array[1]=IKcos(j4array[1]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
if( j4array[1] > IKPI )
{
    j4array[1]-=IK2PI;
}
else if( j4array[1] < -IKPI )
{    j4array[1]+=IK2PI;
}
j4valid[1] = true;
for(int ij4 = 0; ij4 < 2; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 2; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[1];
evalcond[0]=(((new_r12*(IKcos(j4))))+(((-1.0)*new_r02*(IKsin(j4)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x277=((1.0)*new_r01);
if( IKabs(((((-1.0)*cj4*x277))+(((-1.0)*new_r00*sj4)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj4*new_r00))+(((-1.0)*sj4*x277)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj4*x277))+(((-1.0)*new_r00*sj4))))+IKsqr((((cj4*new_r00))+(((-1.0)*sj4*x277))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((((-1.0)*cj4*x277))+(((-1.0)*new_r00*sj4))), (((cj4*new_r00))+(((-1.0)*sj4*x277))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x278=IKsin(j6);
IkReal x279=IKcos(j6);
IkReal x280=((1.0)*sj4);
IkReal x281=((1.0)*x279);
IkReal x282=(sj4*x278);
IkReal x283=(sj4*x279);
IkReal x284=(cj4*x278);
IkReal x285=(cj4*x281);
evalcond[0]=(((cj4*new_r01))+((new_r11*sj4))+x278);
evalcond[1]=(x284+x283+new_r01);
evalcond[2]=(((cj4*new_r00))+((new_r10*sj4))+(((-1.0)*x281)));
evalcond[3]=((((-1.0)*x278))+((cj4*new_r10))+(((-1.0)*new_r00*x280)));
evalcond[4]=(((cj4*new_r11))+(((-1.0)*new_r01*x280))+(((-1.0)*x281)));
evalcond[5]=(x282+(((-1.0)*x285))+new_r00);
evalcond[6]=(x282+(((-1.0)*x285))+new_r11);
evalcond[7]=((((-1.0)*x284))+new_r10+(((-1.0)*x279*x280)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j5)))), 6.28318530717959)));
evalcond[1]=((1.0)+new_r22);
evalcond[2]=new_r20;
evalcond[3]=new_r02;
evalcond[4]=new_r12;
evalcond[5]=new_r21;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[2], cj4array[2], sj4array[2];
bool j4valid[2]={false};
_nj4 = 2;
CheckValue<IkReal> x287 = IKatan2WithCheck(IkReal(new_r02),new_r12,IKFAST_ATAN2_MAGTHRESH);
if(!x287.valid){
continue;
}
IkReal x286=x287.value;
j4array[0]=((-1.0)*x286);
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
j4array[1]=((3.14159265358979)+(((-1.0)*x286)));
sj4array[1]=IKsin(j4array[1]);
cj4array[1]=IKcos(j4array[1]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
if( j4array[1] > IKPI )
{
    j4array[1]-=IK2PI;
}
else if( j4array[1] < -IKPI )
{    j4array[1]+=IK2PI;
}
j4valid[1] = true;
for(int ij4 = 0; ij4 < 2; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 2; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[1];
evalcond[0]=(((new_r12*(IKcos(j4))))+(((-1.0)*new_r02*(IKsin(j4)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x288=((1.0)*new_r00);
if( IKabs((((cj4*new_r01))+(((-1.0)*sj4*x288)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r01*sj4))+(((-1.0)*cj4*x288)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((cj4*new_r01))+(((-1.0)*sj4*x288))))+IKsqr(((((-1.0)*new_r01*sj4))+(((-1.0)*cj4*x288))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2((((cj4*new_r01))+(((-1.0)*sj4*x288))), ((((-1.0)*new_r01*sj4))+(((-1.0)*cj4*x288))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x289=IKcos(j6);
IkReal x290=IKsin(j6);
IkReal x291=((1.0)*sj4);
IkReal x292=((1.0)*x290);
IkReal x293=(sj4*x289);
IkReal x294=((1.0)*x289);
IkReal x295=(cj4*x292);
evalcond[0]=(((cj4*new_r00))+((new_r10*sj4))+x289);
evalcond[1]=(((cj4*new_r01))+((new_r11*sj4))+(((-1.0)*x292)));
evalcond[2]=(((sj4*x290))+new_r00+((cj4*x289)));
evalcond[3]=(((cj4*new_r10))+(((-1.0)*x292))+(((-1.0)*new_r00*x291)));
evalcond[4]=((((-1.0)*new_r01*x291))+((cj4*new_r11))+(((-1.0)*x294)));
evalcond[5]=((((-1.0)*x295))+x293+new_r01);
evalcond[6]=((((-1.0)*x295))+x293+new_r10);
evalcond[7]=((((-1.0)*x290*x291))+(((-1.0)*cj4*x294))+new_r11);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j4, j6]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x297=IKPowWithIntegerCheck(sj5,-1);
if(!x297.valid){
continue;
}
IkReal x296=x297.value;
CheckValue<IkReal> x298=IKPowWithIntegerCheck(new_r12,-1);
if(!x298.valid){
continue;
}
if( IKabs((x296*(x298.value)*(((1.0)+(((-1.0)*(new_r02*new_r02)))+(((-1.0)*(cj5*cj5))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r02*x296)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x296*(x298.value)*(((1.0)+(((-1.0)*(new_r02*new_r02)))+(((-1.0)*(cj5*cj5)))))))+IKsqr((new_r02*x296))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2((x296*(x298.value)*(((1.0)+(((-1.0)*(new_r02*new_r02)))+(((-1.0)*(cj5*cj5)))))), (new_r02*x296));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x299=IKcos(j4);
IkReal x300=IKsin(j4);
IkReal x301=((1.0)*sj5);
IkReal x302=((1.0)*cj5);
IkReal x303=(new_r12*x300);
IkReal x304=(new_r02*x299);
evalcond[0]=((((-1.0)*x299*x301))+new_r02);
evalcond[1]=(new_r12+(((-1.0)*x300*x301)));
evalcond[2]=(((new_r12*x299))+(((-1.0)*new_r02*x300)));
evalcond[3]=(x304+x303+(((-1.0)*x301)));
evalcond[4]=((((-1.0)*new_r22*x301))+((cj5*x304))+((cj5*x303)));
evalcond[5]=((((-1.0)*new_r10*x300*x301))+(((-1.0)*new_r00*x299*x301))+(((-1.0)*new_r20*x302)));
evalcond[6]=((((-1.0)*new_r01*x299*x301))+(((-1.0)*new_r21*x302))+(((-1.0)*new_r11*x300*x301)));
evalcond[7]=((1.0)+(((-1.0)*x301*x304))+(((-1.0)*x301*x303))+(((-1.0)*new_r22*x302)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j6eval[2];
IkReal x305=(cj3*sj1);
IkReal x306=(sj0*sj2);
IkReal x307=((1.0)*sj3);
IkReal x308=(cj1*cj3);
IkReal x309=(cj0*sj2);
IkReal x310=((1.0)*cj1*sj2);
IkReal x311=x233;
IkReal x312=x234;
IkReal x313=x235;
IkReal x314=x236;
IkReal x315=x237;
IkReal x316=x238;
IkReal x317=(((cj3*x306))+((cj0*x313)));
IkReal x318=(((cj3*x309))+(((-1.0)*sj0*x313)));
IkReal x319=((((-1.0)*x306*x307))+((cj0*x316)));
IkReal x320=((((-1.0)*sj3*x309))+(((-1.0)*sj0*x316)));
new_r00=((((-1.0)*r20*x310))+((r00*x312))+((r10*x311)));
new_r01=(((r11*x311))+(((-1.0)*r21*x310))+((r01*x312)));
new_r02=(((r02*x312))+((r12*x311))+(((-1.0)*r22*x310)));
new_r10=(((r20*x314))+((r00*x318))+((r10*x317)));
new_r11=(((r11*x317))+((r01*x318))+((r21*x314)));
new_r12=(((r02*x318))+((r12*x317))+((r22*x314)));
new_r20=(((r00*x320))+((r20*x315))+((r10*x319)));
new_r21=(((r11*x319))+((r01*x320))+((r21*x315)));
new_r22=(((r02*x320))+((r12*x319))+((r22*x315)));
j6eval[0]=sj5;
j6eval[1]=IKsign(sj5);
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  )
{
{
IkReal j6eval[2];
IkReal x321=(cj3*sj1);
IkReal x322=(sj0*sj2);
IkReal x323=((1.0)*sj3);
IkReal x324=(cj1*cj3);
IkReal x325=(cj0*sj2);
IkReal x326=((1.0)*cj1*sj2);
IkReal x327=x233;
IkReal x328=x234;
IkReal x329=x235;
IkReal x330=x236;
IkReal x331=x237;
IkReal x332=x238;
IkReal x333=(((cj0*x329))+((cj3*x322)));
IkReal x334=((((-1.0)*sj0*x329))+((cj3*x325)));
IkReal x335=((((-1.0)*x322*x323))+((cj0*x332)));
IkReal x336=((((-1.0)*sj0*x332))+(((-1.0)*sj3*x325)));
new_r00=(((r00*x328))+((r10*x327))+(((-1.0)*r20*x326)));
new_r01=(((r11*x327))+((r01*x328))+(((-1.0)*r21*x326)));
new_r02=(((r02*x328))+((r12*x327))+(((-1.0)*r22*x326)));
new_r10=(((r00*x334))+((r20*x330))+((r10*x333)));
new_r11=(((r01*x334))+((r11*x333))+((r21*x330)));
new_r12=(((r22*x330))+((r12*x333))+((r02*x334)));
new_r20=(((r00*x336))+((r20*x331))+((r10*x335)));
new_r21=(((r01*x336))+((r11*x335))+((r21*x331)));
new_r22=(((r22*x331))+((r12*x335))+((r02*x336)));
j6eval[0]=sj4;
j6eval[1]=sj5;
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  )
{
{
IkReal j6eval[3];
IkReal x337=(cj3*sj1);
IkReal x338=(sj0*sj2);
IkReal x339=((1.0)*sj3);
IkReal x340=(cj1*cj3);
IkReal x341=(cj0*sj2);
IkReal x342=((1.0)*cj1*sj2);
IkReal x343=x233;
IkReal x344=x234;
IkReal x345=x235;
IkReal x346=x236;
IkReal x347=x237;
IkReal x348=x238;
IkReal x349=(((cj3*x338))+((cj0*x345)));
IkReal x350=((((-1.0)*sj0*x345))+((cj3*x341)));
IkReal x351=((((-1.0)*x338*x339))+((cj0*x348)));
IkReal x352=((((-1.0)*sj3*x341))+(((-1.0)*sj0*x348)));
new_r00=((((-1.0)*r20*x342))+((r00*x344))+((r10*x343)));
new_r01=(((r01*x344))+((r11*x343))+(((-1.0)*r21*x342)));
new_r02=((((-1.0)*r22*x342))+((r02*x344))+((r12*x343)));
new_r10=(((r00*x350))+((r20*x346))+((r10*x349)));
new_r11=(((r21*x346))+((r01*x350))+((r11*x349)));
new_r12=(((r22*x346))+((r12*x349))+((r02*x350)));
new_r20=(((r00*x352))+((r10*x351))+((r20*x347)));
new_r21=(((r21*x347))+((r01*x352))+((r11*x351)));
new_r22=(((r12*x351))+((r22*x347))+((r02*x352)));
j6eval[0]=cj4;
j6eval[1]=cj5;
j6eval[2]=sj5;
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[12];
bool bgotonextstatement = true;
do
{
IkReal x353=(new_r22+(((-1.0)*cj5)));
IkReal x354=((((-1.0)*sj5))+new_r12);
IkReal x355=((1.0)*cj5);
IkReal x356=((1.0)*sj5);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j4)))), 6.28318530717959)));
evalcond[1]=x353;
evalcond[2]=x353;
evalcond[3]=new_r02;
evalcond[4]=x354;
evalcond[5]=x354;
evalcond[6]=((((-1.0)*new_r22*x356))+((cj5*new_r12)));
evalcond[7]=((((-1.0)*new_r10*x356))+(((-1.0)*new_r20*x355)));
evalcond[8]=((((-1.0)*new_r11*x356))+(((-1.0)*new_r21*x355)));
evalcond[9]=((1.0)+(((-1.0)*new_r22*x355))+(((-1.0)*new_r12*x356)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x357 = IKatan2WithCheck(IkReal(new_r21),((-1.0)*new_r20),IKFAST_ATAN2_MAGTHRESH);
if(!x357.valid){
continue;
}
CheckValue<IkReal> x358=IKPowWithIntegerCheck(IKsign(new_r12),-1);
if(!x358.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x357.value)+(((1.5707963267949)*(x358.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x359=IKsin(j6);
IkReal x360=IKcos(j6);
IkReal x361=((1.0)*new_r12);
IkReal x362=((1.0)*x360);
evalcond[0]=(new_r20+((new_r12*x360)));
evalcond[1]=(((new_r22*x359))+new_r11);
evalcond[2]=((((-1.0)*x359*x361))+new_r21);
evalcond[3]=((((-1.0)*new_r22*x362))+new_r10);
evalcond[4]=((((-1.0)*x359))+(((-1.0)*new_r00)));
evalcond[5]=((((-1.0)*x362))+(((-1.0)*new_r01)));
evalcond[6]=(x359+((new_r11*new_r22))+(((-1.0)*new_r21*x361)));
evalcond[7]=((((-1.0)*new_r20*x361))+(((-1.0)*x362))+((new_r10*new_r22)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x363=(new_r22+(((-1.0)*cj5)));
IkReal x364=((1.0)*cj5);
IkReal x365=((1.0)*sj5);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j4)))), 6.28318530717959)));
evalcond[1]=x363;
evalcond[2]=x363;
evalcond[3]=new_r02;
evalcond[4]=(sj5+new_r12);
evalcond[5]=((((-1.0)*x365))+(((-1.0)*new_r12)));
evalcond[6]=((((-1.0)*new_r22*x365))+(((-1.0)*new_r12*x364)));
evalcond[7]=((((-1.0)*new_r20*x364))+((new_r10*sj5)));
evalcond[8]=(((new_r11*sj5))+(((-1.0)*new_r21*x364)));
evalcond[9]=((1.0)+((new_r12*sj5))+(((-1.0)*new_r22*x364)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r00)+IKsqr(new_r01)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(new_r00, new_r01);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x366=IKsin(j6);
IkReal x367=IKcos(j6);
IkReal x368=((1.0)*new_r22);
IkReal x369=((1.0)*x367);
evalcond[0]=(new_r21+((new_r12*x366)));
evalcond[1]=((((-1.0)*x366))+new_r00);
evalcond[2]=((((-1.0)*x369))+new_r01);
evalcond[3]=((((-1.0)*new_r12*x369))+new_r20);
evalcond[4]=(((new_r22*x366))+(((-1.0)*new_r11)));
evalcond[5]=((((-1.0)*x367*x368))+(((-1.0)*new_r10)));
evalcond[6]=(x366+((new_r12*new_r21))+(((-1.0)*new_r11*x368)));
evalcond[7]=((((-1.0)*x369))+((new_r12*new_r20))+(((-1.0)*new_r10*x368)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x370=((1.0)*cj4);
IkReal x371=((1.0)*sj4);
IkReal x372=(((cj4*new_r12))+(((-1.0)*new_r02*x371)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j5)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=((((-1.0)*x370))+new_r02);
evalcond[3]=((((-1.0)*x371))+new_r12);
evalcond[4]=x372;
evalcond[5]=x372;
evalcond[6]=((-1.0)+((new_r12*sj4))+((cj4*new_r02)));
evalcond[7]=(((cj4*new_r01))+((new_r11*sj4)));
evalcond[8]=(((cj4*new_r00))+((new_r10*sj4)));
evalcond[9]=((((-1.0)*new_r00*x370))+(((-1.0)*new_r10*x371)));
evalcond[10]=((((-1.0)*new_r11*x371))+(((-1.0)*new_r01*x370)));
evalcond[11]=((1.0)+(((-1.0)*new_r12*x371))+(((-1.0)*new_r02*x370)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*new_r20))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(new_r21, ((-1.0)*new_r20));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x373=IKcos(j6);
IkReal x374=IKsin(j6);
IkReal x375=((1.0)*new_r12);
IkReal x376=((1.0)*x374);
IkReal x377=((1.0)*x373);
evalcond[0]=(x373+new_r20);
evalcond[1]=((((-1.0)*x376))+new_r21);
evalcond[2]=(((new_r12*x373))+new_r01);
evalcond[3]=(((new_r12*x374))+new_r00);
evalcond[4]=(new_r11+(((-1.0)*new_r02*x377)));
evalcond[5]=(new_r10+(((-1.0)*new_r02*x376)));
evalcond[6]=((((-1.0)*new_r00*x375))+(((-1.0)*x376))+((new_r02*new_r10)));
evalcond[7]=((((-1.0)*x377))+((new_r02*new_r11))+(((-1.0)*new_r01*x375)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x378=((((-1.0)*new_r02*sj4))+((cj4*new_r12)));
IkReal x379=(((cj4*new_r00))+((new_r10*sj4)));
IkReal x380=(((cj4*new_r01))+((new_r11*sj4)));
IkReal x381=((1.0)+((new_r12*sj4))+((cj4*new_r02)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j5)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=(cj4+new_r02);
evalcond[3]=(sj4+new_r12);
evalcond[4]=x378;
evalcond[5]=x378;
evalcond[6]=x381;
evalcond[7]=x380;
evalcond[8]=x379;
evalcond[9]=x379;
evalcond[10]=x380;
evalcond[11]=x381;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r21), new_r20);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x382=IKcos(j6);
IkReal x383=IKsin(j6);
IkReal x384=((1.0)*new_r02);
IkReal x385=((1.0)*new_r12);
IkReal x386=((1.0)*x382);
evalcond[0]=(x383+new_r21);
evalcond[1]=((((-1.0)*x386))+new_r20);
evalcond[2]=(((new_r02*x382))+new_r11);
evalcond[3]=(((new_r02*x383))+new_r10);
evalcond[4]=(new_r01+(((-1.0)*x382*x385)));
evalcond[5]=(new_r00+(((-1.0)*x383*x385)));
evalcond[6]=((((-1.0)*new_r10*x384))+((new_r00*new_r12))+(((-1.0)*x383)));
evalcond[7]=((((-1.0)*new_r11*x384))+((new_r01*new_r12))+(((-1.0)*x386)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x387=((((-1.0)*new_r02*sj4))+((cj4*new_r12)));
IkReal x388=(((new_r12*sj4))+((cj4*new_r02)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j5))), 6.28318530717959)));
evalcond[1]=((-1.0)+new_r22);
evalcond[2]=new_r20;
evalcond[3]=new_r02;
evalcond[4]=new_r12;
evalcond[5]=new_r21;
evalcond[6]=x387;
evalcond[7]=x387;
evalcond[8]=x388;
evalcond[9]=x388;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x389=((1.0)*new_r01);
if( IKabs(((((-1.0)*cj4*x389))+(((-1.0)*new_r00*sj4)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj4*new_r00))+(((-1.0)*sj4*x389)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj4*x389))+(((-1.0)*new_r00*sj4))))+IKsqr((((cj4*new_r00))+(((-1.0)*sj4*x389))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((((-1.0)*cj4*x389))+(((-1.0)*new_r00*sj4))), (((cj4*new_r00))+(((-1.0)*sj4*x389))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x390=IKsin(j6);
IkReal x391=IKcos(j6);
IkReal x392=((1.0)*sj4);
IkReal x393=((1.0)*x391);
IkReal x394=(sj4*x390);
IkReal x395=(sj4*x391);
IkReal x396=(cj4*x390);
IkReal x397=(cj4*x393);
evalcond[0]=(((cj4*new_r01))+((new_r11*sj4))+x390);
evalcond[1]=(x395+x396+new_r01);
evalcond[2]=((((-1.0)*x393))+((cj4*new_r00))+((new_r10*sj4)));
evalcond[3]=((((-1.0)*x390))+((cj4*new_r10))+(((-1.0)*new_r00*x392)));
evalcond[4]=((((-1.0)*new_r01*x392))+(((-1.0)*x393))+((cj4*new_r11)));
evalcond[5]=((((-1.0)*x397))+x394+new_r00);
evalcond[6]=((((-1.0)*x397))+x394+new_r11);
evalcond[7]=((((-1.0)*x396))+(((-1.0)*x391*x392))+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x398=(cj4*new_r02);
IkReal x399=(new_r12*sj4);
IkReal x400=((((-1.0)*new_r02*sj4))+((cj4*new_r12)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j5)))), 6.28318530717959)));
evalcond[1]=((1.0)+new_r22);
evalcond[2]=new_r20;
evalcond[3]=new_r02;
evalcond[4]=new_r12;
evalcond[5]=new_r21;
evalcond[6]=x400;
evalcond[7]=x400;
evalcond[8]=(x399+x398);
evalcond[9]=((((-1.0)*x399))+(((-1.0)*x398)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x401=((1.0)*new_r00);
if( IKabs((((cj4*new_r01))+(((-1.0)*sj4*x401)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r01*sj4))+(((-1.0)*cj4*x401)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((cj4*new_r01))+(((-1.0)*sj4*x401))))+IKsqr(((((-1.0)*new_r01*sj4))+(((-1.0)*cj4*x401))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2((((cj4*new_r01))+(((-1.0)*sj4*x401))), ((((-1.0)*new_r01*sj4))+(((-1.0)*cj4*x401))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x402=IKcos(j6);
IkReal x403=IKsin(j6);
IkReal x404=((1.0)*sj4);
IkReal x405=((1.0)*x403);
IkReal x406=(sj4*x402);
IkReal x407=((1.0)*x402);
IkReal x408=(cj4*x405);
evalcond[0]=(((cj4*new_r00))+((new_r10*sj4))+x402);
evalcond[1]=(((cj4*new_r01))+((new_r11*sj4))+(((-1.0)*x405)));
evalcond[2]=(((cj4*x402))+new_r00+((sj4*x403)));
evalcond[3]=(((cj4*new_r10))+(((-1.0)*new_r00*x404))+(((-1.0)*x405)));
evalcond[4]=(((cj4*new_r11))+(((-1.0)*new_r01*x404))+(((-1.0)*x407)));
evalcond[5]=(x406+new_r01+(((-1.0)*x408)));
evalcond[6]=(x406+new_r10+(((-1.0)*x408)));
evalcond[7]=((((-1.0)*x403*x404))+new_r11+(((-1.0)*cj4*x407)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x409=(new_r22+(((-1.0)*cj5)));
IkReal x410=((((-1.0)*sj5))+new_r02);
IkReal x411=((1.0)*cj5);
IkReal x412=((1.0)*sj5);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j4))), 6.28318530717959)));
evalcond[1]=x409;
evalcond[2]=x409;
evalcond[3]=x410;
evalcond[4]=new_r12;
evalcond[5]=x410;
evalcond[6]=(((cj5*new_r02))+(((-1.0)*new_r22*x412)));
evalcond[7]=((((-1.0)*new_r20*x411))+(((-1.0)*new_r00*x412)));
evalcond[8]=((((-1.0)*new_r21*x411))+(((-1.0)*new_r01*x412)));
evalcond[9]=((1.0)+(((-1.0)*new_r02*x412))+(((-1.0)*new_r22*x411)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r10)+IKsqr(new_r11)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(new_r10, new_r11);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x413=IKcos(j6);
IkReal x414=IKsin(j6);
IkReal x415=((1.0)*new_r02);
IkReal x416=((1.0)*x413);
evalcond[0]=(new_r20+((new_r02*x413)));
evalcond[1]=(new_r10+(((-1.0)*x414)));
evalcond[2]=(new_r11+(((-1.0)*x416)));
evalcond[3]=(((new_r22*x414))+new_r01);
evalcond[4]=(new_r21+(((-1.0)*x414*x415)));
evalcond[5]=(new_r00+(((-1.0)*new_r22*x416)));
evalcond[6]=(((new_r01*new_r22))+x414+(((-1.0)*new_r21*x415)));
evalcond[7]=(((new_r00*new_r22))+(((-1.0)*new_r20*x415))+(((-1.0)*x416)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x417=(new_r22+(((-1.0)*cj5)));
IkReal x418=((1.0)*cj5);
IkReal x419=((1.0)*sj5);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j4)))), 6.28318530717959)));
evalcond[1]=x417;
evalcond[2]=x417;
evalcond[3]=(sj5+new_r02);
evalcond[4]=new_r12;
evalcond[5]=((((-1.0)*new_r02))+(((-1.0)*x419)));
evalcond[6]=((((-1.0)*new_r02*x418))+(((-1.0)*new_r22*x419)));
evalcond[7]=(((new_r00*sj5))+(((-1.0)*new_r20*x418)));
evalcond[8]=(((new_r01*sj5))+(((-1.0)*new_r21*x418)));
evalcond[9]=((1.0)+((new_r02*sj5))+(((-1.0)*new_r22*x418)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x420 = IKatan2WithCheck(IkReal(((-1.0)*new_r21)),new_r20,IKFAST_ATAN2_MAGTHRESH);
if(!x420.valid){
continue;
}
CheckValue<IkReal> x421=IKPowWithIntegerCheck(IKsign(new_r02),-1);
if(!x421.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x420.value)+(((1.5707963267949)*(x421.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x422=IKsin(j6);
IkReal x423=IKcos(j6);
IkReal x424=((1.0)*new_r01);
IkReal x425=((1.0)*new_r00);
IkReal x426=((1.0)*x423);
evalcond[0]=(new_r21+((new_r02*x422)));
evalcond[1]=((((-1.0)*new_r02*x426))+new_r20);
evalcond[2]=((((-1.0)*x422))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*x426))+(((-1.0)*new_r11)));
evalcond[4]=(((new_r22*x422))+(((-1.0)*x424)));
evalcond[5]=((((-1.0)*new_r22*x426))+(((-1.0)*x425)));
evalcond[6]=((((-1.0)*new_r22*x424))+x422+((new_r02*new_r21)));
evalcond[7]=((((-1.0)*new_r22*x425))+(((-1.0)*x426))+((new_r02*new_r20)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j6]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x428=IKPowWithIntegerCheck(sj5,-1);
if(!x428.valid){
continue;
}
IkReal x427=x428.value;
CheckValue<IkReal> x429=IKPowWithIntegerCheck(cj4,-1);
if(!x429.valid){
continue;
}
CheckValue<IkReal> x430=IKPowWithIntegerCheck(cj5,-1);
if(!x430.valid){
continue;
}
if( IKabs((x427*(x429.value)*(x430.value)*((((new_r20*sj4))+(((-1.0)*new_r01*sj5)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*x427)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x427*(x429.value)*(x430.value)*((((new_r20*sj4))+(((-1.0)*new_r01*sj5))))))+IKsqr(((-1.0)*new_r20*x427))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2((x427*(x429.value)*(x430.value)*((((new_r20*sj4))+(((-1.0)*new_r01*sj5))))), ((-1.0)*new_r20*x427));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[12];
IkReal x431=IKsin(j6);
IkReal x432=IKcos(j6);
IkReal x433=((1.0)*sj5);
IkReal x434=((1.0)*sj4);
IkReal x435=(cj5*sj4);
IkReal x436=(cj4*new_r01);
IkReal x437=(cj4*new_r00);
IkReal x438=((1.0)*x432);
IkReal x439=(cj5*x431);
IkReal x440=((1.0)*x431);
evalcond[0]=(new_r20+((sj5*x432)));
evalcond[1]=((((-1.0)*x431*x433))+new_r21);
evalcond[2]=(((new_r11*sj4))+x439+x436);
evalcond[3]=((((-1.0)*new_r00*x434))+(((-1.0)*x440))+((cj4*new_r10)));
evalcond[4]=((((-1.0)*x438))+(((-1.0)*new_r01*x434))+((cj4*new_r11)));
evalcond[5]=(((sj4*x432))+((cj4*x439))+new_r01);
evalcond[6]=(((new_r10*sj4))+(((-1.0)*cj5*x438))+x437);
evalcond[7]=(((sj4*x431))+new_r00+(((-1.0)*cj4*cj5*x438)));
evalcond[8]=((((-1.0)*cj4*x438))+((x431*x435))+new_r11);
evalcond[9]=((((-1.0)*cj4*x440))+(((-1.0)*cj5*x432*x434))+new_r10);
evalcond[10]=(((cj5*x436))+((new_r11*x435))+x431+(((-1.0)*new_r21*x433)));
evalcond[11]=((((-1.0)*x438))+((cj5*x437))+((new_r10*x435))+(((-1.0)*new_r20*x433)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x442=IKPowWithIntegerCheck(sj5,-1);
if(!x442.valid){
continue;
}
IkReal x441=x442.value;
CheckValue<IkReal> x443=IKPowWithIntegerCheck(sj4,-1);
if(!x443.valid){
continue;
}
if( IKabs((x441*(x443.value)*(((((-1.0)*new_r00*sj5))+(((-1.0)*cj4*cj5*new_r20)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*x441)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x441*(x443.value)*(((((-1.0)*new_r00*sj5))+(((-1.0)*cj4*cj5*new_r20))))))+IKsqr(((-1.0)*new_r20*x441))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2((x441*(x443.value)*(((((-1.0)*new_r00*sj5))+(((-1.0)*cj4*cj5*new_r20))))), ((-1.0)*new_r20*x441));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[12];
IkReal x444=IKsin(j6);
IkReal x445=IKcos(j6);
IkReal x446=((1.0)*sj5);
IkReal x447=((1.0)*sj4);
IkReal x448=(cj5*sj4);
IkReal x449=(cj4*new_r01);
IkReal x450=(cj4*new_r00);
IkReal x451=((1.0)*x445);
IkReal x452=(cj5*x444);
IkReal x453=((1.0)*x444);
evalcond[0]=(((sj5*x445))+new_r20);
evalcond[1]=((((-1.0)*x444*x446))+new_r21);
evalcond[2]=(((new_r11*sj4))+x449+x452);
evalcond[3]=((((-1.0)*new_r00*x447))+((cj4*new_r10))+(((-1.0)*x453)));
evalcond[4]=((((-1.0)*new_r01*x447))+((cj4*new_r11))+(((-1.0)*x451)));
evalcond[5]=(((sj4*x445))+((cj4*x452))+new_r01);
evalcond[6]=(((new_r10*sj4))+(((-1.0)*cj5*x451))+x450);
evalcond[7]=(((sj4*x444))+(((-1.0)*cj4*cj5*x451))+new_r00);
evalcond[8]=((((-1.0)*cj4*x451))+((x444*x448))+new_r11);
evalcond[9]=((((-1.0)*cj4*x453))+(((-1.0)*cj5*x445*x447))+new_r10);
evalcond[10]=(((cj5*x449))+((new_r11*x448))+x444+(((-1.0)*new_r21*x446)));
evalcond[11]=(((cj5*x450))+(((-1.0)*x451))+((new_r10*x448))+(((-1.0)*new_r20*x446)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x454=IKPowWithIntegerCheck(IKsign(sj5),-1);
if(!x454.valid){
continue;
}
CheckValue<IkReal> x455 = IKatan2WithCheck(IkReal(new_r21),((-1.0)*new_r20),IKFAST_ATAN2_MAGTHRESH);
if(!x455.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(((1.5707963267949)*(x454.value)))+(x455.value));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[12];
IkReal x456=IKsin(j6);
IkReal x457=IKcos(j6);
IkReal x458=((1.0)*sj5);
IkReal x459=((1.0)*sj4);
IkReal x460=(cj5*sj4);
IkReal x461=(cj4*new_r01);
IkReal x462=(cj4*new_r00);
IkReal x463=((1.0)*x457);
IkReal x464=(cj5*x456);
IkReal x465=((1.0)*x456);
evalcond[0]=(new_r20+((sj5*x457)));
evalcond[1]=((((-1.0)*x456*x458))+new_r21);
evalcond[2]=(((new_r11*sj4))+x461+x464);
evalcond[3]=(((cj4*new_r10))+(((-1.0)*x465))+(((-1.0)*new_r00*x459)));
evalcond[4]=(((cj4*new_r11))+(((-1.0)*new_r01*x459))+(((-1.0)*x463)));
evalcond[5]=(((cj4*x464))+((sj4*x457))+new_r01);
evalcond[6]=(((new_r10*sj4))+(((-1.0)*cj5*x463))+x462);
evalcond[7]=(((sj4*x456))+(((-1.0)*cj4*cj5*x463))+new_r00);
evalcond[8]=(((x456*x460))+(((-1.0)*cj4*x463))+new_r11);
evalcond[9]=((((-1.0)*cj4*x465))+(((-1.0)*cj5*x457*x459))+new_r10);
evalcond[10]=((((-1.0)*new_r21*x458))+((new_r11*x460))+((cj5*x461))+x456);
evalcond[11]=(((cj5*x462))+((new_r10*x460))+(((-1.0)*new_r20*x458))+(((-1.0)*x463)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x466=IKPowWithIntegerCheck(IKsign(sj5),-1);
if(!x466.valid){
continue;
}
CheckValue<IkReal> x467 = IKatan2WithCheck(IkReal(new_r12),new_r02,IKFAST_ATAN2_MAGTHRESH);
if(!x467.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(((1.5707963267949)*(x466.value)))+(x467.value));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x468=IKcos(j4);
IkReal x469=IKsin(j4);
IkReal x470=((1.0)*sj5);
IkReal x471=((1.0)*cj5);
IkReal x472=(new_r12*x469);
IkReal x473=(new_r02*x468);
evalcond[0]=((((-1.0)*x468*x470))+new_r02);
evalcond[1]=((((-1.0)*x469*x470))+new_r12);
evalcond[2]=(((new_r12*x468))+(((-1.0)*new_r02*x469)));
evalcond[3]=((((-1.0)*x470))+x472+x473);
evalcond[4]=(((cj5*x473))+((cj5*x472))+(((-1.0)*new_r22*x470)));
evalcond[5]=((((-1.0)*new_r00*x468*x470))+(((-1.0)*new_r10*x469*x470))+(((-1.0)*new_r20*x471)));
evalcond[6]=((((-1.0)*new_r11*x469*x470))+(((-1.0)*new_r21*x471))+(((-1.0)*new_r01*x468*x470)));
evalcond[7]=((1.0)+(((-1.0)*new_r22*x471))+(((-1.0)*x470*x472))+(((-1.0)*x470*x473)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j6eval[2];
IkReal x474=(cj3*sj1);
IkReal x475=(sj0*sj2);
IkReal x476=((1.0)*sj3);
IkReal x477=(cj1*cj3);
IkReal x478=(cj0*sj2);
IkReal x479=((1.0)*cj1*sj2);
IkReal x480=x233;
IkReal x481=x234;
IkReal x482=x235;
IkReal x483=x236;
IkReal x484=x237;
IkReal x485=x238;
IkReal x486=(((cj0*x482))+((cj3*x475)));
IkReal x487=(((cj3*x478))+(((-1.0)*sj0*x482)));
IkReal x488=(((cj0*x485))+(((-1.0)*x475*x476)));
IkReal x489=((((-1.0)*sj0*x485))+(((-1.0)*sj3*x478)));
new_r00=(((r10*x480))+((r00*x481))+(((-1.0)*r20*x479)));
new_r01=((((-1.0)*r21*x479))+((r11*x480))+((r01*x481)));
new_r02=(((r02*x481))+((r12*x480))+(((-1.0)*r22*x479)));
new_r10=(((r20*x483))+((r10*x486))+((r00*x487)));
new_r11=(((r11*x486))+((r21*x483))+((r01*x487)));
new_r12=(((r02*x487))+((r12*x486))+((r22*x483)));
new_r20=(((r20*x484))+((r10*x488))+((r00*x489)));
new_r21=(((r11*x488))+((r21*x484))+((r01*x489)));
new_r22=(((r02*x489))+((r12*x488))+((r22*x484)));
j6eval[0]=sj5;
j6eval[1]=IKsign(sj5);
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  )
{
{
IkReal j6eval[2];
IkReal x490=(cj3*sj1);
IkReal x491=(sj0*sj2);
IkReal x492=((1.0)*sj3);
IkReal x493=(cj1*cj3);
IkReal x494=(cj0*sj2);
IkReal x495=((1.0)*cj1*sj2);
IkReal x496=x233;
IkReal x497=x234;
IkReal x498=x235;
IkReal x499=x236;
IkReal x500=x237;
IkReal x501=x238;
IkReal x502=(((cj0*x498))+((cj3*x491)));
IkReal x503=((((-1.0)*sj0*x498))+((cj3*x494)));
IkReal x504=((((-1.0)*x491*x492))+((cj0*x501)));
IkReal x505=((((-1.0)*sj0*x501))+(((-1.0)*sj3*x494)));
new_r00=(((r10*x496))+((r00*x497))+(((-1.0)*r20*x495)));
new_r01=((((-1.0)*r21*x495))+((r11*x496))+((r01*x497)));
new_r02=(((r02*x497))+((r12*x496))+(((-1.0)*r22*x495)));
new_r10=(((r10*x502))+((r00*x503))+((r20*x499)));
new_r11=(((r01*x503))+((r11*x502))+((r21*x499)));
new_r12=(((r22*x499))+((r12*x502))+((r02*x503)));
new_r20=(((r20*x500))+((r10*x504))+((r00*x505)));
new_r21=(((r21*x500))+((r01*x505))+((r11*x504)));
new_r22=(((r22*x500))+((r12*x504))+((r02*x505)));
j6eval[0]=sj4;
j6eval[1]=sj5;
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  )
{
{
IkReal j6eval[3];
IkReal x506=(cj3*sj1);
IkReal x507=(sj0*sj2);
IkReal x508=((1.0)*sj3);
IkReal x509=(cj1*cj3);
IkReal x510=(cj0*sj2);
IkReal x511=((1.0)*cj1*sj2);
IkReal x512=x233;
IkReal x513=x234;
IkReal x514=x235;
IkReal x515=x236;
IkReal x516=x237;
IkReal x517=x238;
IkReal x518=(((cj3*x507))+((cj0*x514)));
IkReal x519=(((cj3*x510))+(((-1.0)*sj0*x514)));
IkReal x520=(((cj0*x517))+(((-1.0)*x507*x508)));
IkReal x521=((((-1.0)*sj3*x510))+(((-1.0)*sj0*x517)));
new_r00=(((r10*x512))+(((-1.0)*r20*x511))+((r00*x513)));
new_r01=(((r01*x513))+((r11*x512))+(((-1.0)*r21*x511)));
new_r02=((((-1.0)*r22*x511))+((r02*x513))+((r12*x512)));
new_r10=(((r20*x515))+((r10*x518))+((r00*x519)));
new_r11=(((r01*x519))+((r11*x518))+((r21*x515)));
new_r12=(((r02*x519))+((r22*x515))+((r12*x518)));
new_r20=(((r20*x516))+((r10*x520))+((r00*x521)));
new_r21=(((r11*x520))+((r21*x516))+((r01*x521)));
new_r22=(((r02*x521))+((r12*x520))+((r22*x516)));
j6eval[0]=cj4;
j6eval[1]=cj5;
j6eval[2]=sj5;
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[12];
bool bgotonextstatement = true;
do
{
IkReal x522=(new_r22+(((-1.0)*cj5)));
IkReal x523=((((-1.0)*sj5))+new_r12);
IkReal x524=((1.0)*cj5);
IkReal x525=((1.0)*sj5);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j4)))), 6.28318530717959)));
evalcond[1]=x522;
evalcond[2]=x522;
evalcond[3]=new_r02;
evalcond[4]=x523;
evalcond[5]=x523;
evalcond[6]=((((-1.0)*new_r22*x525))+((cj5*new_r12)));
evalcond[7]=((((-1.0)*new_r20*x524))+(((-1.0)*new_r10*x525)));
evalcond[8]=((((-1.0)*new_r11*x525))+(((-1.0)*new_r21*x524)));
evalcond[9]=((1.0)+(((-1.0)*new_r22*x524))+(((-1.0)*new_r12*x525)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x526 = IKatan2WithCheck(IkReal(new_r21),((-1.0)*new_r20),IKFAST_ATAN2_MAGTHRESH);
if(!x526.valid){
continue;
}
CheckValue<IkReal> x527=IKPowWithIntegerCheck(IKsign(new_r12),-1);
if(!x527.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x526.value)+(((1.5707963267949)*(x527.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x528=IKsin(j6);
IkReal x529=IKcos(j6);
IkReal x530=((1.0)*new_r12);
IkReal x531=((1.0)*x529);
evalcond[0]=(((new_r12*x529))+new_r20);
evalcond[1]=(new_r11+((new_r22*x528)));
evalcond[2]=((((-1.0)*x528*x530))+new_r21);
evalcond[3]=((((-1.0)*new_r22*x531))+new_r10);
evalcond[4]=((((-1.0)*x528))+(((-1.0)*new_r00)));
evalcond[5]=((((-1.0)*x531))+(((-1.0)*new_r01)));
evalcond[6]=((((-1.0)*new_r21*x530))+x528+((new_r11*new_r22)));
evalcond[7]=((((-1.0)*x531))+(((-1.0)*new_r20*x530))+((new_r10*new_r22)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x532=(new_r22+(((-1.0)*cj5)));
IkReal x533=((1.0)*cj5);
IkReal x534=((1.0)*sj5);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j4)))), 6.28318530717959)));
evalcond[1]=x532;
evalcond[2]=x532;
evalcond[3]=new_r02;
evalcond[4]=(sj5+new_r12);
evalcond[5]=((((-1.0)*x534))+(((-1.0)*new_r12)));
evalcond[6]=((((-1.0)*new_r22*x534))+(((-1.0)*new_r12*x533)));
evalcond[7]=(((new_r10*sj5))+(((-1.0)*new_r20*x533)));
evalcond[8]=(((new_r11*sj5))+(((-1.0)*new_r21*x533)));
evalcond[9]=((1.0)+(((-1.0)*new_r22*x533))+((new_r12*sj5)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r00)+IKsqr(new_r01)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(new_r00, new_r01);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x535=IKsin(j6);
IkReal x536=IKcos(j6);
IkReal x537=((1.0)*new_r22);
IkReal x538=((1.0)*x536);
evalcond[0]=(((new_r12*x535))+new_r21);
evalcond[1]=((((-1.0)*x535))+new_r00);
evalcond[2]=((((-1.0)*x538))+new_r01);
evalcond[3]=((((-1.0)*new_r12*x538))+new_r20);
evalcond[4]=((((-1.0)*new_r11))+((new_r22*x535)));
evalcond[5]=((((-1.0)*new_r10))+(((-1.0)*x536*x537)));
evalcond[6]=((((-1.0)*new_r11*x537))+((new_r12*new_r21))+x535);
evalcond[7]=((((-1.0)*x538))+(((-1.0)*new_r10*x537))+((new_r12*new_r20)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x539=((1.0)*cj4);
IkReal x540=((1.0)*sj4);
IkReal x541=(((cj4*new_r12))+(((-1.0)*new_r02*x540)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j5)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=((((-1.0)*x539))+new_r02);
evalcond[3]=((((-1.0)*x540))+new_r12);
evalcond[4]=x541;
evalcond[5]=x541;
evalcond[6]=((-1.0)+((new_r12*sj4))+((cj4*new_r02)));
evalcond[7]=(((cj4*new_r01))+((new_r11*sj4)));
evalcond[8]=(((cj4*new_r00))+((new_r10*sj4)));
evalcond[9]=((((-1.0)*new_r00*x539))+(((-1.0)*new_r10*x540)));
evalcond[10]=((((-1.0)*new_r01*x539))+(((-1.0)*new_r11*x540)));
evalcond[11]=((1.0)+(((-1.0)*new_r12*x540))+(((-1.0)*new_r02*x539)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*new_r20))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(new_r21, ((-1.0)*new_r20));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x542=IKcos(j6);
IkReal x543=IKsin(j6);
IkReal x544=((1.0)*new_r12);
IkReal x545=((1.0)*x543);
IkReal x546=((1.0)*x542);
evalcond[0]=(x542+new_r20);
evalcond[1]=((((-1.0)*x545))+new_r21);
evalcond[2]=(((new_r12*x542))+new_r01);
evalcond[3]=(((new_r12*x543))+new_r00);
evalcond[4]=(new_r11+(((-1.0)*new_r02*x546)));
evalcond[5]=(new_r10+(((-1.0)*new_r02*x545)));
evalcond[6]=((((-1.0)*new_r00*x544))+(((-1.0)*x545))+((new_r02*new_r10)));
evalcond[7]=((((-1.0)*new_r01*x544))+(((-1.0)*x546))+((new_r02*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x547=((((-1.0)*new_r02*sj4))+((cj4*new_r12)));
IkReal x548=(((cj4*new_r00))+((new_r10*sj4)));
IkReal x549=(((cj4*new_r01))+((new_r11*sj4)));
IkReal x550=((1.0)+((new_r12*sj4))+((cj4*new_r02)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j5)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=(cj4+new_r02);
evalcond[3]=(sj4+new_r12);
evalcond[4]=x547;
evalcond[5]=x547;
evalcond[6]=x550;
evalcond[7]=x549;
evalcond[8]=x548;
evalcond[9]=x548;
evalcond[10]=x549;
evalcond[11]=x550;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r21), new_r20);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x551=IKcos(j6);
IkReal x552=IKsin(j6);
IkReal x553=((1.0)*new_r02);
IkReal x554=((1.0)*new_r12);
IkReal x555=((1.0)*x551);
evalcond[0]=(x552+new_r21);
evalcond[1]=((((-1.0)*x555))+new_r20);
evalcond[2]=(((new_r02*x551))+new_r11);
evalcond[3]=(((new_r02*x552))+new_r10);
evalcond[4]=((((-1.0)*x551*x554))+new_r01);
evalcond[5]=((((-1.0)*x552*x554))+new_r00);
evalcond[6]=((((-1.0)*x552))+(((-1.0)*new_r10*x553))+((new_r00*new_r12)));
evalcond[7]=((((-1.0)*new_r11*x553))+((new_r01*new_r12))+(((-1.0)*x555)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x556=((((-1.0)*new_r02*sj4))+((cj4*new_r12)));
IkReal x557=(((new_r12*sj4))+((cj4*new_r02)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j5))), 6.28318530717959)));
evalcond[1]=((-1.0)+new_r22);
evalcond[2]=new_r20;
evalcond[3]=new_r02;
evalcond[4]=new_r12;
evalcond[5]=new_r21;
evalcond[6]=x556;
evalcond[7]=x556;
evalcond[8]=x557;
evalcond[9]=x557;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x558=((1.0)*new_r01);
if( IKabs(((((-1.0)*new_r00*sj4))+(((-1.0)*cj4*x558)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj4*new_r00))+(((-1.0)*sj4*x558)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r00*sj4))+(((-1.0)*cj4*x558))))+IKsqr((((cj4*new_r00))+(((-1.0)*sj4*x558))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((((-1.0)*new_r00*sj4))+(((-1.0)*cj4*x558))), (((cj4*new_r00))+(((-1.0)*sj4*x558))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x559=IKsin(j6);
IkReal x560=IKcos(j6);
IkReal x561=((1.0)*sj4);
IkReal x562=((1.0)*x560);
IkReal x563=(sj4*x559);
IkReal x564=(sj4*x560);
IkReal x565=(cj4*x559);
IkReal x566=(cj4*x562);
evalcond[0]=(((cj4*new_r01))+((new_r11*sj4))+x559);
evalcond[1]=(x564+x565+new_r01);
evalcond[2]=(((cj4*new_r00))+((new_r10*sj4))+(((-1.0)*x562)));
evalcond[3]=((((-1.0)*new_r00*x561))+(((-1.0)*x559))+((cj4*new_r10)));
evalcond[4]=(((cj4*new_r11))+(((-1.0)*x562))+(((-1.0)*new_r01*x561)));
evalcond[5]=(x563+new_r00+(((-1.0)*x566)));
evalcond[6]=(x563+new_r11+(((-1.0)*x566)));
evalcond[7]=((((-1.0)*x560*x561))+(((-1.0)*x565))+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x567=(cj4*new_r02);
IkReal x568=(new_r12*sj4);
IkReal x569=((((-1.0)*new_r02*sj4))+((cj4*new_r12)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j5)))), 6.28318530717959)));
evalcond[1]=((1.0)+new_r22);
evalcond[2]=new_r20;
evalcond[3]=new_r02;
evalcond[4]=new_r12;
evalcond[5]=new_r21;
evalcond[6]=x569;
evalcond[7]=x569;
evalcond[8]=(x568+x567);
evalcond[9]=((((-1.0)*x567))+(((-1.0)*x568)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x570=((1.0)*new_r00);
if( IKabs((((cj4*new_r01))+(((-1.0)*sj4*x570)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r01*sj4))+(((-1.0)*cj4*x570)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((cj4*new_r01))+(((-1.0)*sj4*x570))))+IKsqr(((((-1.0)*new_r01*sj4))+(((-1.0)*cj4*x570))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2((((cj4*new_r01))+(((-1.0)*sj4*x570))), ((((-1.0)*new_r01*sj4))+(((-1.0)*cj4*x570))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x571=IKcos(j6);
IkReal x572=IKsin(j6);
IkReal x573=((1.0)*sj4);
IkReal x574=((1.0)*x572);
IkReal x575=(sj4*x571);
IkReal x576=((1.0)*x571);
IkReal x577=(cj4*x574);
evalcond[0]=(((cj4*new_r00))+((new_r10*sj4))+x571);
evalcond[1]=(((cj4*new_r01))+((new_r11*sj4))+(((-1.0)*x574)));
evalcond[2]=(((sj4*x572))+new_r00+((cj4*x571)));
evalcond[3]=(((cj4*new_r10))+(((-1.0)*x574))+(((-1.0)*new_r00*x573)));
evalcond[4]=(((cj4*new_r11))+(((-1.0)*x576))+(((-1.0)*new_r01*x573)));
evalcond[5]=((((-1.0)*x577))+x575+new_r01);
evalcond[6]=((((-1.0)*x577))+x575+new_r10);
evalcond[7]=((((-1.0)*cj4*x576))+new_r11+(((-1.0)*x572*x573)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x578=(new_r22+(((-1.0)*cj5)));
IkReal x579=((((-1.0)*sj5))+new_r02);
IkReal x580=((1.0)*cj5);
IkReal x581=((1.0)*sj5);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j4))), 6.28318530717959)));
evalcond[1]=x578;
evalcond[2]=x578;
evalcond[3]=x579;
evalcond[4]=new_r12;
evalcond[5]=x579;
evalcond[6]=(((cj5*new_r02))+(((-1.0)*new_r22*x581)));
evalcond[7]=((((-1.0)*new_r20*x580))+(((-1.0)*new_r00*x581)));
evalcond[8]=((((-1.0)*new_r01*x581))+(((-1.0)*new_r21*x580)));
evalcond[9]=((1.0)+(((-1.0)*new_r22*x580))+(((-1.0)*new_r02*x581)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r10)+IKsqr(new_r11)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(new_r10, new_r11);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x582=IKcos(j6);
IkReal x583=IKsin(j6);
IkReal x584=((1.0)*new_r02);
IkReal x585=((1.0)*x582);
evalcond[0]=(((new_r02*x582))+new_r20);
evalcond[1]=((((-1.0)*x583))+new_r10);
evalcond[2]=(new_r11+(((-1.0)*x585)));
evalcond[3]=(((new_r22*x583))+new_r01);
evalcond[4]=((((-1.0)*x583*x584))+new_r21);
evalcond[5]=((((-1.0)*new_r22*x585))+new_r00);
evalcond[6]=(((new_r01*new_r22))+(((-1.0)*new_r21*x584))+x583);
evalcond[7]=(((new_r00*new_r22))+(((-1.0)*new_r20*x584))+(((-1.0)*x585)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x586=(new_r22+(((-1.0)*cj5)));
IkReal x587=((1.0)*cj5);
IkReal x588=((1.0)*sj5);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j4)))), 6.28318530717959)));
evalcond[1]=x586;
evalcond[2]=x586;
evalcond[3]=(sj5+new_r02);
evalcond[4]=new_r12;
evalcond[5]=((((-1.0)*new_r02))+(((-1.0)*x588)));
evalcond[6]=((((-1.0)*new_r22*x588))+(((-1.0)*new_r02*x587)));
evalcond[7]=(((new_r00*sj5))+(((-1.0)*new_r20*x587)));
evalcond[8]=(((new_r01*sj5))+(((-1.0)*new_r21*x587)));
evalcond[9]=((1.0)+((new_r02*sj5))+(((-1.0)*new_r22*x587)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x589 = IKatan2WithCheck(IkReal(((-1.0)*new_r21)),new_r20,IKFAST_ATAN2_MAGTHRESH);
if(!x589.valid){
continue;
}
CheckValue<IkReal> x590=IKPowWithIntegerCheck(IKsign(new_r02),-1);
if(!x590.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x589.value)+(((1.5707963267949)*(x590.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x591=IKsin(j6);
IkReal x592=IKcos(j6);
IkReal x593=((1.0)*new_r01);
IkReal x594=((1.0)*new_r00);
IkReal x595=((1.0)*x592);
evalcond[0]=(((new_r02*x591))+new_r21);
evalcond[1]=((((-1.0)*new_r02*x595))+new_r20);
evalcond[2]=((((-1.0)*x591))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*x595))+(((-1.0)*new_r11)));
evalcond[4]=((((-1.0)*x593))+((new_r22*x591)));
evalcond[5]=((((-1.0)*x594))+(((-1.0)*new_r22*x595)));
evalcond[6]=(x591+(((-1.0)*new_r22*x593))+((new_r02*new_r21)));
evalcond[7]=((((-1.0)*x595))+(((-1.0)*new_r22*x594))+((new_r02*new_r20)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j6]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x597=IKPowWithIntegerCheck(sj5,-1);
if(!x597.valid){
continue;
}
IkReal x596=x597.value;
CheckValue<IkReal> x598=IKPowWithIntegerCheck(cj4,-1);
if(!x598.valid){
continue;
}
CheckValue<IkReal> x599=IKPowWithIntegerCheck(cj5,-1);
if(!x599.valid){
continue;
}
if( IKabs((x596*(x598.value)*(x599.value)*((((new_r20*sj4))+(((-1.0)*new_r01*sj5)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*x596)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x596*(x598.value)*(x599.value)*((((new_r20*sj4))+(((-1.0)*new_r01*sj5))))))+IKsqr(((-1.0)*new_r20*x596))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2((x596*(x598.value)*(x599.value)*((((new_r20*sj4))+(((-1.0)*new_r01*sj5))))), ((-1.0)*new_r20*x596));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[12];
IkReal x600=IKsin(j6);
IkReal x601=IKcos(j6);
IkReal x602=((1.0)*sj5);
IkReal x603=((1.0)*sj4);
IkReal x604=(cj5*sj4);
IkReal x605=(cj4*new_r01);
IkReal x606=(cj4*new_r00);
IkReal x607=((1.0)*x601);
IkReal x608=(cj5*x600);
IkReal x609=((1.0)*x600);
evalcond[0]=(((sj5*x601))+new_r20);
evalcond[1]=((((-1.0)*x600*x602))+new_r21);
evalcond[2]=(((new_r11*sj4))+x605+x608);
evalcond[3]=(((cj4*new_r10))+(((-1.0)*x609))+(((-1.0)*new_r00*x603)));
evalcond[4]=(((cj4*new_r11))+(((-1.0)*x607))+(((-1.0)*new_r01*x603)));
evalcond[5]=(((sj4*x601))+new_r01+((cj4*x608)));
evalcond[6]=(((new_r10*sj4))+x606+(((-1.0)*cj5*x607)));
evalcond[7]=(((sj4*x600))+new_r00+(((-1.0)*cj4*cj5*x607)));
evalcond[8]=(((x600*x604))+(((-1.0)*cj4*x607))+new_r11);
evalcond[9]=((((-1.0)*cj5*x601*x603))+(((-1.0)*cj4*x609))+new_r10);
evalcond[10]=(((cj5*x605))+((new_r11*x604))+x600+(((-1.0)*new_r21*x602)));
evalcond[11]=(((cj5*x606))+(((-1.0)*new_r20*x602))+((new_r10*x604))+(((-1.0)*x607)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x611=IKPowWithIntegerCheck(sj5,-1);
if(!x611.valid){
continue;
}
IkReal x610=x611.value;
CheckValue<IkReal> x612=IKPowWithIntegerCheck(sj4,-1);
if(!x612.valid){
continue;
}
if( IKabs((x610*(x612.value)*(((((-1.0)*new_r00*sj5))+(((-1.0)*cj4*cj5*new_r20)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*x610)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x610*(x612.value)*(((((-1.0)*new_r00*sj5))+(((-1.0)*cj4*cj5*new_r20))))))+IKsqr(((-1.0)*new_r20*x610))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2((x610*(x612.value)*(((((-1.0)*new_r00*sj5))+(((-1.0)*cj4*cj5*new_r20))))), ((-1.0)*new_r20*x610));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[12];
IkReal x613=IKsin(j6);
IkReal x614=IKcos(j6);
IkReal x615=((1.0)*sj5);
IkReal x616=((1.0)*sj4);
IkReal x617=(cj5*sj4);
IkReal x618=(cj4*new_r01);
IkReal x619=(cj4*new_r00);
IkReal x620=((1.0)*x614);
IkReal x621=(cj5*x613);
IkReal x622=((1.0)*x613);
evalcond[0]=(new_r20+((sj5*x614)));
evalcond[1]=((((-1.0)*x613*x615))+new_r21);
evalcond[2]=(((new_r11*sj4))+x618+x621);
evalcond[3]=(((cj4*new_r10))+(((-1.0)*x622))+(((-1.0)*new_r00*x616)));
evalcond[4]=(((cj4*new_r11))+(((-1.0)*x620))+(((-1.0)*new_r01*x616)));
evalcond[5]=(((sj4*x614))+((cj4*x621))+new_r01);
evalcond[6]=(((new_r10*sj4))+(((-1.0)*cj5*x620))+x619);
evalcond[7]=(((sj4*x613))+(((-1.0)*cj4*cj5*x620))+new_r00);
evalcond[8]=((((-1.0)*cj4*x620))+((x613*x617))+new_r11);
evalcond[9]=((((-1.0)*cj5*x614*x616))+(((-1.0)*cj4*x622))+new_r10);
evalcond[10]=((((-1.0)*new_r21*x615))+((new_r11*x617))+x613+((cj5*x618)));
evalcond[11]=((((-1.0)*x620))+((new_r10*x617))+((cj5*x619))+(((-1.0)*new_r20*x615)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x623=IKPowWithIntegerCheck(IKsign(sj5),-1);
if(!x623.valid){
continue;
}
CheckValue<IkReal> x624 = IKatan2WithCheck(IkReal(new_r21),((-1.0)*new_r20),IKFAST_ATAN2_MAGTHRESH);
if(!x624.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(((1.5707963267949)*(x623.value)))+(x624.value));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[12];
IkReal x625=IKsin(j6);
IkReal x626=IKcos(j6);
IkReal x627=((1.0)*sj5);
IkReal x628=((1.0)*sj4);
IkReal x629=(cj5*sj4);
IkReal x630=(cj4*new_r01);
IkReal x631=(cj4*new_r00);
IkReal x632=((1.0)*x626);
IkReal x633=(cj5*x625);
IkReal x634=((1.0)*x625);
evalcond[0]=(((sj5*x626))+new_r20);
evalcond[1]=((((-1.0)*x625*x627))+new_r21);
evalcond[2]=(((new_r11*sj4))+x633+x630);
evalcond[3]=((((-1.0)*new_r00*x628))+((cj4*new_r10))+(((-1.0)*x634)));
evalcond[4]=((((-1.0)*new_r01*x628))+((cj4*new_r11))+(((-1.0)*x632)));
evalcond[5]=(((sj4*x626))+((cj4*x633))+new_r01);
evalcond[6]=(((new_r10*sj4))+(((-1.0)*cj5*x632))+x631);
evalcond[7]=(((sj4*x625))+new_r00+(((-1.0)*cj4*cj5*x632)));
evalcond[8]=(((x625*x629))+(((-1.0)*cj4*x632))+new_r11);
evalcond[9]=((((-1.0)*cj4*x634))+(((-1.0)*cj5*x626*x628))+new_r10);
evalcond[10]=(((cj5*x630))+(((-1.0)*new_r21*x627))+((new_r11*x629))+x625);
evalcond[11]=((((-1.0)*x632))+((cj5*x631))+((new_r10*x629))+(((-1.0)*new_r20*x627)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}
}
}
}
}static inline void polyroots3(IkReal rawcoeffs[3+1], IkReal rawroots[3], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots2(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[3];
    const int maxsteps = 110;
    for(int i = 0; i < 3; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[3];
    IkReal err[3];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 3; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 3; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 3; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 3; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[3] = {false};
    for(int i = 0; i < 3; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 3; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots2(IkReal rawcoeffs[2+1], IkReal rawroots[2], int& numroots) {
    IkReal det = rawcoeffs[1]*rawcoeffs[1]-4*rawcoeffs[0]*rawcoeffs[2];
    if( det < 0 ) {
        numroots=0;
    }
    else if( det == 0 ) {
        rawroots[0] = -0.5*rawcoeffs[1]/rawcoeffs[0];
        numroots = 1;
    }
    else {
        det = IKsqrt(det);
        rawroots[0] = (-rawcoeffs[1]+det)/(2*rawcoeffs[0]);
        rawroots[1] = (-rawcoeffs[1]-det)/(2*rawcoeffs[0]);//rawcoeffs[2]/(rawcoeffs[0]*rawroots[0]);
        numroots = 2;
    }
}
static inline void polyroots5(IkReal rawcoeffs[5+1], IkReal rawroots[5], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots4(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[5];
    const int maxsteps = 110;
    for(int i = 0; i < 5; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[5];
    IkReal err[5];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 5; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 5; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 5; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 5; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[5] = {false};
    for(int i = 0; i < 5; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 5; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots4(IkReal rawcoeffs[4+1], IkReal rawroots[4], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots3(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[4];
    const int maxsteps = 110;
    for(int i = 0; i < 4; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[4];
    IkReal err[4];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 4; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 4; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 4; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 4; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[4] = {false};
    for(int i = 0; i < 4; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 4; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots7(IkReal rawcoeffs[7+1], IkReal rawroots[7], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots6(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[7];
    const int maxsteps = 110;
    for(int i = 0; i < 7; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[7];
    IkReal err[7];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 7; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 7; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 7; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 7; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[7] = {false};
    for(int i = 0; i < 7; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 7; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots6(IkReal rawcoeffs[6+1], IkReal rawroots[6], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots5(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[6];
    const int maxsteps = 110;
    for(int i = 0; i < 6; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[6];
    IkReal err[6];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 6; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 6; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 6; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 6; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[6] = {false};
    for(int i = 0; i < 6; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 6; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots8(IkReal rawcoeffs[8+1], IkReal rawroots[8], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots7(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[8];
    const int maxsteps = 110;
    for(int i = 0; i < 8; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[8];
    IkReal err[8];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 8; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 8; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 8; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 8; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[8] = {false};
    for(int i = 0; i < 8; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 8; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
};


/// solves the inverse kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API bool ComputeIk2(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions, void* pOpenRAVEManip) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API const char* GetKinematicsHash() { return "<robot:GenericRobot - tiago (52f72caad381e7543aa8e1a0d39be57b)>"; }

IKFAST_API const char* GetIkFastVersion() { return "0x10000048"; }

#ifdef IKFAST_NAMESPACE
} // end namespace
#endif

#ifndef IKFAST_NO_MAIN
#include <stdio.h>
#include <stdlib.h>
#ifdef IKFAST_NAMESPACE
using namespace IKFAST_NAMESPACE;
#endif
int main(int argc, char** argv)
{
    if( argc != 12+GetNumFreeParameters()+1 ) {
        printf("\nUsage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\n\n"
               "Returns the ik solutions given the transformation of the end effector specified by\n"
               "a 3x3 rotation R (rXX), and a 3x1 translation (tX).\n"
               "There are %d free parameters that have to be specified.\n\n",GetNumFreeParameters());
        return 1;
    }

    IkSolutionList<IkReal> solutions;
    std::vector<IkReal> vfree(GetNumFreeParameters());
    IkReal eerot[9],eetrans[3];
    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);
    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);
    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);
    for(std::size_t i = 0; i < vfree.size(); ++i)
        vfree[i] = atof(argv[13+i]);
    bool bSuccess = ComputeIk(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, solutions);

    if( !bSuccess ) {
        fprintf(stderr,"Failed to get ik solution\n");
        return -1;
    }

    printf("Found %d ik solutions:\n", (int)solutions.GetNumSolutions());
    std::vector<IkReal> solvalues(GetNumJoints());
    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {
        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);
        printf("sol%d (free=%d): ", (int)i, (int)sol.GetFree().size());
        std::vector<IkReal> vsolfree(sol.GetFree().size());
        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);
        for( std::size_t j = 0; j < solvalues.size(); ++j)
            printf("%.15f, ", solvalues[j]);
        printf("\n");
    }
    return 0;
}

#endif
